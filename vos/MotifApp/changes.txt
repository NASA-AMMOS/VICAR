<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>New modules</TITLE>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
   <META NAME="Generator" CONTENT="Microsoft Word 97">
   <META NAME="Template" CONTENT="D:\MICROSOFT OFFICE\OFFICE\html.dot">
   <META NAME="GENERATOR" CONTENT="Mozilla/3.01Gold (X11; I; SunOS 5.3 sun4m) [Netscape]">
</HEAD>
<BODY LINK="#0000FF" VLINK="#800080">

<!-- Note:  This file should be copied to rushmore sage/prog_notes and >
<!-- renamed ma_changes.html whenever it changes so the web server can find it.>

<H1 ALIGN=CENTER><FONT FACE="Arial">MotifApp Changes</FONT></H1>

<P><FONT FACE="Arial">This file describes all of the changes to the MotifApp
application framework that were made by the JPL-MIPS programming staff.
MotifApp was originally designed and published by Douglas A. Young in
&quot;Object-Oriented Programming with C++ and OSF/Motif&quot; (Prentice Hall,
1992). Here, the changes are presented in chronological order, with the
latest changes at the end.  The programmer's initials appears in parentheses
(defaulting to rgd if not present), and each delivery is separated with a
line filled with #s.</FONT></P>

<H3><FONT FACE="Arial">New modules</FONT></H3>

<P><FONT FACE="Courier New"><FONT SIZE=-1>-----------</FONT></FONT></P>

<P>ErrorDialogManager.h</P>

<P>ErrorDialogManager.cc</P>

<P>ListInterface.h</P>

<P>ListInterface.cc</P>

<P>NoOpCmd.h</P>

<P>NoOpCmd.cc</P>

<P>SeparatorCmd.h</P>

<P>SeparatorCmd.cc</P>

<P>SeparatorInterface.h</P>

<P>SeparatorInterface.cc</P>

<P>ToggleInterface.h</P>

<P>ToggleInterface.cc</P>

<P>ValueCmd.h</P>

<P>ValueCmd.cc</P>

<P>ValueCmdInterface.h</P>

<P>ValueCmdInterface.cc</P>

<P>CheckBoxInterface.h</P>

<P>CheckBoxInterface.cc</P>

<P>RadioButtonInterface.h</P>

<P>RadioButtonInterface.cc</P>

<P>RadioCmd.h</P>

<P>RadioCmd.cc</P>

<P>CascadeInterface.h</P>

<P>CascadeInterface.cc</P>

<P>MenuItem.h</P>

<P>MenuItem.cc</P>

<P>MenuCmdList.h</P>

<P>MenuCmdList.cc</P>

<P>KeyinView.h</P>

<P>KeyinView.cc</P>

<P>ErrorData.h</P>

<P>ErrorData.cc</P>

<P>ErrorManager.h</P>

<P>ErrorManager.cc</P>

<P>&gt;&gt;&gt; added to Makefile</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** Doug Young Changes ***</P>

<h2>CmdList.h CmdList.cc MenuBar.h MenuBar.cc</h2>

<P>Added D. Young's patch to allow submenus See README below.</P>

<P>--- C++Motif/Extras/SubMenus/README ---</P>

<P>The files in this directory contained modifications that allow the menuBar
class to support cascading submenus. The changes are:</P>

<P>Change CmdList to derive from Cmd. This is interesting in several ways,
because it makes a CmdList be a Cmd itself. That is, you can execute a
CmdList. This opens the door to all kinds of possibilities - creating &quot;macros&quot;
that consist of lists of Cmds that can be executed in sequence, history
mechanisms, multi-level undo, etc. With respect to supporting submenus,
it specifically allows a CmdList to contain other CmdList objects.</P>

<P>Change MenuBar to &quot;know&quot; that CmdLists may contain other CmdLists.
The new implementation works recursively to create a submenu for each CmdList
it encounters. So if a CmdList contains nested CmdLists, cascading menus
will be created. The only reasonable way I have come up with to do this
is to have MenuBar explicitly test the type of each object on a list, using
the className() method, and to cast any CmdList object as needed. While
a bit ugly, this approach is consistent with the design of the Cmd architecture.
Cmd's don't know anything about thier presentation - classes like MenuBar
have to know what they are working with and create the appropriate presentation.</P>

<P>MenuDemoWindow.C deomstrates how to construct a nest list of Cmds based
on these changes.</P>

<P>To try these features, move the four MotifApp files into the MotifApp
directory and rebuild. Move MenuDemoWindow to the ch9 directory and rebuild.</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** (mas)***</P>

<h2>ButtonInterface.h ButtonInterface.cc</h2>

<P>Added operator=== to allow use with RogueWave templates</P>

<h2>ErrorDialogManager.h ErrorDialogManager.cc</h2>

<P>New class to manage error dialogs. Dialogs are modal and have only one
button</P>

<h2>InfoDialogManager.cc</h2>

<P>Removed cancel button</P>

<h2>ListInterface.h ListInterface.cc</h2>

<P>New class to manage a scrolled list interface to a Command object</P>

<h2>NoOpCmd.h NoOpCmd.cc</h2>

<P>Dummy command that does nothing. Should only be used as placeholders
during development because it prints out a message in doit() and undoit()</P>

<h2>SelectFileCmd.h SelectFileCmd.cc</h2>

<P>Add return value to file callbacks: return TRUE if the file is good
Make the dialog go away if the user hits cancel</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** (vxp)***</P>

<h2>Application.h Application.cc</h2>

<P>Added int getArgc() and char *getParam(int n) to handle command line
params</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** (rgd) ***</P>

<h2>CmdInterface.h CmdInterface.cc</h2>

<P>Added new constructor with name but no Cmd so interface can be created
before the Cmd is. Cmd is set via new setCommand() member function</P>

<h2>MainWindow.cc</h2>

<P>Set XmNallowShellResize to True on popup shell</P>

<h2>MenuBar.h MenuBar.cc</h2>

<P>Added optional argument &quot;int help_menu = FALSE&quot; to addCommands.
Set it to TRUE for help menus to put it on the right side of the menu bar.
</P>

<P>Added Separator interface. Put SeparatorCmd in CmdList and a SeparatorInterface
will appear in the menu. Handled similarly to submenus</P>

<h2>SeparatorCmd.h,.cc</h2>

<P>New command class for Separators in menus. Command doesn't do anything,
and everything is inline. The .cc implementation file merely defines a
global theSeparatorCmd for use with the menu system.</P>

<h2>SeparatorInterface.h SeparatorInterface.cc</h2>

<P>New CmdInterface class for separators, usually for menus.</P>

<h2>ToggleInterface.h ToggleInterface.cc</h2>

<P>New CmdInterface class for toggle (radio) buttons, usually in menus.</P>

<h2>CmdList.h</h2>

<P>Added #ifndef wrapper around file (Young didn't supply it!!)</P>

<h2>BasicComponent.h,.cc</h2>

<P>Added int isManaged() to check managed state (returns FALSE if widget
not</P>

<P>created yet).</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** ValueCmd changes ***</P>

<h2>ValueCmd.h,.cc, ValueCmdInterface.h,.cc</h2>

<P>Adds the concept of a command that takes a value. Examples are a command
requiring a filename or an integer value, although it could be as complex
as the entire contents of a dialog box. The basic idea is that the ValueCmdInterface
extracts the value from its widgets, and then passes the value (which is
of type CmdValue, a void *) into ValueCmd::executeValue(). This value is
saved in ValueCmd::_value, which can then be retrieved, cast to the appropriate
type, and used by doit(). The value is not an argument to doit(), which
allows a &quot;starting&quot; value to be set via the constructor (note:
&quot;starting&quot; not &quot;default&quot; because if changed by any
execute() call, it will stay changed. This in turn allows a ValueCmd to
be used from a CmdInterface with a default value which never changes. For
example, a ZoomCmd class could be written, which is then used via a ButtonInterface
to zoom to a constant 2 (set in the constructor for the command). The same
class could be used with a dialog box derived from ValueCmdInterface, which
would set the value based on user input. Note that it would be impossible
to use the same ZoomCmd *object* for these two cases, as the dialog box
would change the value inside the command, and the next invocation of the
button would use that value. However, you could write a ButtonInterface
derived from ValueCmdInterface that set value to a constant.</P>

<P>Note that due to a weirdness in the compiler, the execute() that takes
a value is actually called executeValue(). </P>

<P>The ValueCmd will notify all of its CmdInterface's (via setValues) whenever
the value changes. This allows all the multiple interfaces connected to
a single command to update to reflect the current value (a given interface
could ignore this, of course). Since the interface that generated this
update is also called, it is important to make sure that the update of
the interface does not trigger another call to execute the command! The
setValues function is *not* called by registerInterface (although it is
by setCommand), because registerInterface gets called by the CmdInterface
constructor, before the rest of the ValueCmdInterface has been constructed!
So, if important, the interface's constructor should call getValue on the
command to get the current state, and initialize appropriately.</P>

<P>The previous &quot;value&quot; is *not* saved for Undo. It is the responsibility
of the derived class to save anything required to implement Undo. </P>

<P>A note regarding memory management (if &quot;value&quot; is not a pointer
then ignore this paragraph): since &quot;value&quot; is saved inside the
ValueCmd object, whatever it points at must not disappear while ValueCmd
points at it. If it can be guaranteed that no ValueCmdInterface's will
be deleted before the ValueCmd is, then &quot;value&quot; can be a pointer
to a data memeber of the interface. However, this is not generally the
case, and so &quot;value&quot; really should be dynamically allocated by
the interface. For this reason, a freeValue virtual function in ValueCmd
is called whenever an old value is about to be destroyed. This function
should be overridden to check for a null pointer, cast it to the appropriate
type, and delete the object.</P>

<P>It is up to the derived classes of the command and interface to agree
on the type of &quot;value&quot;, and whether it is dynamically allocated
or not. </P>

<h2>Cmd.h</h2>

<P>added definition of NULL</P>

<P>Moved _active, _ci, _numInterfaces from private to protected section</P>

<P>Added executeValue(void *) and getValue() to make valueCmd's life easier</P>

<h2>CmdInterface.h</h2>

<P>Add &quot;virtual void setValue(void *) { }&quot; to resolve links (does
nothing). </P>

<P>Made setCommand() virtual.</P>

<h2>CheckBoxInterface.h,.cc</h2>

<P>Checkbox command interface derived from ValueCmdInterface. The value
is an integer True or False based on the state.</P>

<h2>RadioButtonInterface.h,.cc</h2>

<P>Radio button interface derived from CheckBoxInterface. The only difference
is the shape of the indicator.</P>

<h2>RadioCmd.h,.cc</h2>

<P>Command that implements radio bank behavior. It assumes its commands
are ValueCmd's with an integer True or False value. It contains a CmdList
which is a list of all commands in the same &quot;radio bank&quot;. Whenever
the command is executed (with value True), it executes all the other commands
in the list with value False. The list is set either via the constructor
or via setRadioList(). This command implements Undo by calling executeValue(True)
for the previously-true command, so derived classes do not need an undoit()
function.</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** MenuCmdList changes ***</P>

<h2>MenuBar.h,.cc</h2>

<h2>MenuCmdList.h,.cc</h2>

<P>Added new way of implementing menus. Instead of creating a CmdList,
you create a MenuCmdList. Then, instead of list-&gt;add(), you have a variety
of functions, like list-&gt;addButton(), list-&gt;addCheckBox(), list-&gt;addRadioButton(),
list-&gt;addSubmenu(), list-&gt;addSeparator(). Each one takes a Cmd (or
MenuCmdList in the case of addSubmenu()), and creates the given type of
interface for that command. Additional information can optionally be given
for each command type, which currently consists of mnemonic, accelerator,
and accelerator text. (It is not recommended that these be used - use resource
files instead so that they can be internationalized). The addCommands()
function has been overloaded so that if given a CmdList, it does the old
thing, and if given a MenuCmdList, it does the new menus. Note that MenuCmdList-&gt;add()
still exists and adds a button. But, addButton should be used instead.</P>

<h2>CascadeInterface.h,.cc</h2>

<P>Cascade button interface. Expects a MenuCmdList as its command and creates
a submenu for the list.</P>

<h2>MenuItem.h,.cc</h2>

<P>Collection of small classes to maintain info about and to create menu
items. Used by MenuCmdList to keep track of the info provided by addButton(),
etc. Adding a new interface type to a menu is a simple matter of adding
a class to these files (the new class can have more data items if desired),
and adding an add*() routine to MenuCmdList.</P>

<h2>CmdList.h</h2>

<P>Made add() virtual</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** Deferred command execution ***</P>

<P>Commands that exist in dialog boxes should not be executed immediately,
but only when OK or Apply are pressed. In order to support this, CmdInterface
now supports deferred execution of commands. When a command is deferred,
attempts by the interface to execute the command will put it onto a CmdList
instead. This CmdList is then executed at a later time, usually by the
OK/Apply buttons. Undoing this CmdList undoes all commands that make it
up, allowing the entire dialog to be undone.</P>

<P>This behavior is automatic. CmdInterfaces do what they normally would,
using executeCmdCallback to run the commands (if you use your own callback,
you must call runCmd() instead of _cmd-&gt;execute(); see incompatible
change note below). If deferred mode is set (via setDeferredExec()), the
CmdInterface classes trap the attempt at execution and put the command,
with its value, onto the given CmdList. If the command already exists on
the list, it is not added twice. Instead, the command value is replaced
with the new one.</P>

<P>If command is executed by some other interface while it is sitting on
the deferred list (i.e. if interface-&gt;setValue() is called), then the
command is automatically removed from the list, because presumably the
action has taken effect, and the interface has been updated to reflect
the new state of things. Subclasses can override setValue() to change this
behavior, but it is not recommended. Most subclasses should call CmdInterface::setValue()
from their own setValue() in order to get the command removed from the
list. </P>

<P>If the command uses a CmdValue, the CmdValue must either be always dynamically
allocated, or never dynamically allocated. Iff it is dynamic, freeValue()
must free an instance of the value. The CmdList is managing these values
(they are not part of the command while on the list), and it will call
freeValue() to discard any CmdValue's that are not needed any more. </P>

<P>If a RadioButtonInterface is set up to use deferred execution, then
the interface must be set up to be a Motif radio button as well as via
the RadioCmd mechanism. This is so that the proper radio behavior will
happen in the dialog before the command is executed.</P>

<P>Interfaces in a dialog should try to execute their commands any time
any of their values change. But, they should not execute their commands
if the value changes due to a setValue() call from some other interface.
They should just set their current state to reflect the value. </P>

<h2>CmdInterface.h,.cc</h2>

<P><B>*INCOMPATIBLE CHANGE*</B> CmdInterface::executeCmdCallback now calls
virtual executeCmd(), which calls runCmd(), instead of directly calling
_cmd-&gt;execute(). Any subclasses that have their own callbacks must be
modified to call runCmd() instead of calling _cmd-&gt;execute() directly
if they want to participate in deferred command execution.</P>

<h2>CmdInterface.h,.cc</h2>

<P>Folded all ValueCmdInterface functionality into CmdInterface so ValueCmdInterface
can be deleted. Changes are 100% backward compatible with old CmdInterface.</P>

<P>Changed executeCmdCallback to call executeCmd() so it can be overridden
by subclasses.</P>

<P>Added executeCmd() which calls runCmd() to actually execute the command.
executeCmd() should be overridden by subclasses to gather up the CmdValue
(if needed) to send to runCmd(). The argument to executeCmd() is the call_data
from the callback.</P>

<P>Added runCmd() which decides whether the execution should be deferred
or not, and either executes it or adds it to the deferred list. This function
should be called by all subclasses instead of calling _cmd-&gt;execute()
directly. </P>

<P>Added setDeferredExec(CmdList *) to set deferred mode. Passing in a
NULL turns deferred mode back off.</P>

<P>Modified setValue() to remove command from deferred list.</P>

<h2>Cmd.h,.cc</h2>

<P>Folded all ValueCmd functionality into Cmd so ValueCmd can be deleted.
Changes are 100% backward compatible with old Cmd, with the exception that
any class overriding execute() must put CmdValue=NULL in the argument list.
</P>

<P>Added reset() to set all interfaces back to &quot;current&quot; values.
Useful for Cancel from dialogs.</P>

<h2>CmdList.h,.cc</h2>

<P>Added second list of CmdValues, parallel to main command list. Execution
of the list supplies each Cmd with its corresponding CmdValue.</P>

<P>Execution of list copies lists first so they don't get messed up by
commands being deleted during execution. Saved list is used for undo (same
reason).</P>

<P>Added addUnique(Cmd *, CmdValue *) to add a command and value uniquely
to the list. If the command already exists on the list, the value is replaced.</P>

<P>Added remove(Cmd *) to remove a command (and value) from the list.</P>

<P>Added clear() to remove all commands but not the undo list.</P>

<P>Destructor destroys all CmdValue's.</P>

<P>Added optional CmdValue to add().</P>

<P>Moved _ci and _numInterfaces back to private section</P>

<P>Added reset() to restore interfaces back to saved values (via cmd-&gt;newValue()).
Useful for Cancel from dialogs.</P>

<P>Moved newValue() to public</P>

<h2>CheckBoxInterface.h,.cc</h2>

<P>Changed references from ValueCmd(Interface) to Cmd(Interface)</P>

<h2>RadioButtonInterface.h,.cc</h2>

<P>Changed references from ValueCmd(Interface) to Cmd(Interface)</P>

<h2>RadioCmd.h,.cc</h2>

<P>Changed references from ValueCmd(Interface) to Cmd(Interface)</P>

<P>Override reset() so that all interfaces in the radio bank get reset</P>

<h2>AskFirstCmd.h,.cc</h2>

<h2>InterruptibleCmd.h,.cc</h2>

<h2>RadioCmd.h,.cc</h2>

<P>Added CmdValue=NULL argument to overridden execute() functions</P>

<h2>CheckBoxInterface.h,.cc</h2>

<h2>RadioButtonInterface.h,.cc</h2>

<h2>ToggleInterface.h,.cc</h2>

<P>Changed to call runCmd() instead of directly executing command</P>

<h2>MenuCmdList.h,.cc</h2>

<P>Added CmdValue=NULL arg to overridden add() function</P>

<h2>ValueCmd.h,.cc</h2>

<h2>ValueCmdInterface.h,.cc</h2>

<P><B>*INCOMPATIBLE CHANGE*</B> Deleted these two classes after merging
functionality with Cmd/CmdInterface. Changes are backwards compatible,
so just replace all occurrences of ValueCmd with Cmd, ValueCmdInterface
with CmdInterface, and executeValue with execute. Any overrides of the
old Cmd::execute() will need a CmdValue=NULL parameter added.</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** Dialog handling changes ***</P>

<h2>CustomDialog.h,.cc</h2>

<P>Abstract class to handle dialog boxes that use deferred execution to
handle OK and Apply. Public interface is simple: post() and unpost() do
what they say. isPosted() returns whether or not the dialog is currently
posted. The dialog is automatically unposted on Apply or Cancel.</P>

<P>Subclass interface is also pretty simple. The constructor should take
whatever values it needs (usually Cmd pointers) and save them away, because
the dialog is not built until it is first posted (and it is generally never
destroyed). When calling CustomDialog's constructor, it should indicate
what the state of the 5 possible buttons are (OK, Apply, Reset, Cancel,
Help). The states are Invisible (it just doesn't exist), Visible (normal),
and Default (visible plus has Default semantics). The real work is done
in createWorkArea(), which (just like MainWindow) should create and return
any (unmanaged) manager you want, with any contents you want. Typically
there will be a bunch of CmdInterface's created in here. The function getApplyList()
will return the _applyCmdList (or subclasses can get it directly) for use
in setDeferredExec() calls. </P>

<P>The Ok/Apply/Reset/Cancel buttons are handled automatically by CustomDialog.
Apply runs the command list and then clears the list. Reset sets all interfaces
back to the current values in their commands, and clears the list. Cancel
resets and unposts the dialog. OK does Apply then unposts. One side effect
of Reset/Cancel is that if multiple dialogs are active using the same Command,
a Cancel will set *all* interfaces of that Command back to the current
value. Thus, Cancel in one dialog can have an effect in another. But, since
this problem is not likely to occur, and is not that serious if it does,
and would be very difficult to fix, it is not going to be fixed at this
time.</P>

<P>The Help button is not implemented. It can be created but the callback
currently does nothing.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>KeyinView.h,.cc</h2>

<P>A UIComponent class that supports two widgets: a label and a text field.
It can be used for data entry of a field. The widgets appear as: label
inputArea In order to specify the size of the input area, set XmNcolumns
for the &quot;field&quot; widget. The label name has to be set via XmNlabelString
for the &quot;label&quot; widget. The component can also be used for text
output by setting XmNeditable to False and XmNcursorPositionVisible to
False. Derived classes will determine the value to be displayed. Example:</P>

<P>Code:</P>

<P><TT>KeyinView *dnvalue = new KeyinView (parent, &quot;dnvalue&quot;);</TT></P>

<P><TT>dnvalue-&gt;manage();</TT></P>

<P>Resource: </P>

<P><TT>*dnvalue*labelString: DN Value:</TT></P>

<P>This component is mainly intended as a base class but can be used standalone
via the access functions for the two widgets. The installCallback() function
will install a callback on activate and losingFocus. The default function
is only useful if subclasses override update() but base class users can
supply their own function to installCallback().</P>

<P>Please note that anyone using the getFieldValue() function must call
XtFree() on the returned string when they are done with it.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(per mas)</P>

<h2>Main.cc</h2>

<h2>Application.h</h2>

<P>Changed main from returning &quot;void&quot; to returning &quot;int&quot;
for compatibility with new Sun C++ compiler.</P>

<h2>DialogManager.cc</h2>

<P>Changed XmStringCreateSimple() to XmStringCreateLtoR() to allow multi-line
strings with embedded newlines.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(gac)</P>

<h2>RadioCmd.cc</h2>

<P>Supplying a radioList on the constructor will cause the RadioCmd to
automatically add itself to the list. Using setRadioList is not automatic;
you must add the command to the list manually if you use setRadioList.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>RadioCmdBox.h,.cc</h2>

<P>New convenience class for creating radio banks from a list of RadioCmd's.
All items in the list must be RadioCmd's, but this is not checked for in
the code. The provided list will typically be a MenuList or the actual
radio list (the one that specifies which commands make up the mutual-exclude
set). RadioButtonInterface's are created in the order given in the list.
The created RowColumn widget may be obtained via baseWidget() to, for example,
change the orientation or number of columns. If you want separators or
other things embedded in the radio bank, you must create it manually.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>OptionCmdMenu.h</h2>

<h2>OptionInterface.h,.cc</h2>

<P>Component for easy creation of option menus for RadioCmd's. To create
an option menu, first create either a MenuCmdList with addOption(), or
a standard CmdList. Using MenuCmdList allows you to put separators, mnemonics,
and accelerators in the menu, while the CmdList interface is often easier
because you can use the existing RadioCmd's mutual-exclude list (mnemonics
and accelerators are specified in the resource file, which is where they
should be anyway). Then, pass the list into the OptionCmdMenu constructor,
and manage the result. The label of the option menu must be set via a resource
file.</P>

<P>The resulting option menu will behave just like a radio bank. Only one
option will be active at a time, and its associated command will be executed
with True. Other options will be executed with False. If you wish to set
deferred execution of these commands, specify the list on MenuCmdList::addOption(),
or on the OptionCmdMenu's constructor if using a simple CmdList.</P>

<P>OptionInterface creates a single entry in an option menu and can be
used to create an option menu manually. </P>

<h2>MenuItem.h,.cc</h2>

<P>Added MenuItemOption class; added &quot;Widget option=NULL&quot; to
all createItem calls (ignored by all but Option; Option needs it so buttons
can set themselves as the current value of the option menu).</P>

<h2>MenuCmdList.h,.cc</h2>

<P>Added addOption() function and added default &quot;Widget option=NULL&quot;
argument to createMenuPane().</P>

<!-- ########################################################################>
<hr width="100%">

<h2>PopupMenu.h,.cc</h2>

<P>A class to assist in creating Popup menus. The popup should be constructed
with a MenuCmdList. Then, call popup-&gt;attachPopup(w) to attach the popup
to widget &quot;w&quot; via an event handler on button 3. This is done
in a separate routine instead of in the constructor in order to 1) allow
other events to pop up the menu (although that would violate the Motif
style guide, baseWidget() will return the widget for the menu), 2) to possibly
allow attachment to a different widget than the parent (although I don't
know if that's legal or not), and 3) to allow control over when the menu
is enabled and disabled (detachPopup() will remove the event handler).
Note that Cmd's for Popup menus cannot be deferred as that does not make
sense for the way popups are used (it could be done if needed, however
- it's a matter of not having a clean interface to do so).</P>

<!-- ########################################################################>
<hr width="100%">

<h2>Application.cc</h2>

<P>Modified initialize() to save a copy of the window list before calling
initialize() and manage() on them all. This allows MainWindow subclasses
to create their own MainWindow (e.g. popup/dialog) children in their createWorkArea
routines without getting them automatically initialized and managed by
Application.</P>

<h2>MainWindow.cc</h2>

<P>Modified initialize() to create a topLevelShell instead of an applicationShell.
The only difference between the two is in how resources are handled. ApplicationShell
starts a new widget tree, while TopLevelShell doesn't. Since most resources
are specified starting with &quot;*&quot; anyway, this shouldn't matter.
The change was made because Motif recommends that applications generally
have only one ApplicationShell, using TopLevelShell's for other windows.
The ApplicationShell in MotifApp is the (unmanaged) shell created by XtAppInitialize().</P>

<h2>Application.cc</h2>

<h2>MainWindow.h,.cc</h2>

<P>Motif has the wonderful feature of exiting the application when an ApplicationShell
is destroyed. Unfortunately, it doesn't do the same for TopLevelShells.
So, a function setExitOnDestroy() was added to MainWindow so that it will
exit the application when the widget is destroyed (UIComponent::widgetDestroyed
was overridden to do this). Additionally, Application was modified to call
setExitOnDestroy() for all of its initial startup windows, on the theory
that those are the true &quot;main&quot; windows. Applications can override
by setting XmNdeleteResponse to XmUNMAP to prevent the shell from being
destroyed (and thus prevent the application from exiting) when the close
box is hit.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>RadioCmd.h,.cc</h2>

<h2>Cmd.h</h2>

<P>Made undo() virtual, and copied most of undo() to RadioCmd. The difference
is that RadioCmd::undo() doesn't run through the activation/deactivation
list. Since RadioCmd's are undone by executing whatever was last True,
that execution will reset all the dependent sensitivities.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>Application.cc</h2>

<P>Added call to XmRepTypeInstallTearOffModelConverter() in intialize()
if we're in Motif 1.2 or later. Installing the type converter never hurts,
since you can always turn tear-offs off via the resources.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>RadioCmdBox.h</h2>

<P>Moved data elements from private to protected.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>KeyinView.h,.cc</h2>

<P>Added another argument to installCallback() which is normally (XtPointer)this.
This allows the callbacks to be set from classes other than a KeyinView
subclass.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>RadioCmd.cc</h2>

<P>If the command is executed twice in succession, the undo will be set
up to re-execute the command again. This is usually a no-op but can be
useful for subclasses that need to do something else with undo.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>CmdList.h</h2>

<h2>RadioCmd.h</h2>

<P>Made all private members protected instead</P>

<!-- ########################################################################>
<hr width="100%">

<P>(pma)</P>

<h2>ArrowButtonInterface.h,.cc</h2>

<P>The ArrowButtonInterface class defines only a constructor. All other
facilities are inherited from CmdInterface. The constructor expects a parent
widget and a pointer to a Cmd object. The constructor creates an XmArrowButton
widget and installs a callback to handle</P>

<P>unexpected widget destruction, using the convenience function defined
by UIComponent. Once the widget has been created, the constructor sets
the widget's sensitivity according to the current value of the &quot;_active&quot;
flag, which is initialized when the object is registered with a Cmd object.
Finally, the constructor installs the &quot;executeCallback()&quot; function,
which executes the associated Cmd object when the base widget is activated.</P>

<P>Use just like ButtonInterface, except the arrow direction must be set
via resources.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>BasicComponent.h</h2>

<P>Changes to allow compilation on Alpha/VMS. Alpha/VMS (6.1 at least)
does not support strdup(), so an inline implementation was added with #ifdef's
for VMS around it.</P>

<h2>Clock.cc</h2>

<h2>InterruptibleCmd.cc</h2>

<h2>WorkingDialogManager.cc</h2>

<P>Changes to allow compilation on Alpha/VMS. Changed initialization of
&quot;long&quot; variables (e.g. XtIntervalId) from NULL to None since
NULL is defined to be a pointer in VMS, whereas None (an X symbol) is not.
They are both 0.</P>

<h2>HSVView.cc</h2>

<P>Changes to allow compilation on Alpha/VMS. Put &quot;#ifndef&quot; protection
around defines of MAX and MIN.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>CustomDialog.h,.cc</h2>

<P>Added protected virtual help() to allow subclasses to implement functionality
for the Help button. Commands to implement context-sensitive help exist
but are not in MotifApp in an attempt to keep it policy-neutral.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>MenuWindow.h</h2>

<P>Added hideMenuBar(), showMenuBar(), and isMenuBarVisible() member functions.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>KeyinView.cc</h2>

<P>Changed manager from a RowColumn to a Form to improve alignment (fields
are now right-justified within the manager, so if all TextFields' XmNcolumns
are the same, it should line up. This may be difficult with a RowColumn
parent but a Form parent works fine).</P>

<!-- ########################################################################>
<hr width="100%">

<P>*** Help Browser ***</P>

<h2>HelpBrowser.h,.cc</h2>

<h2>HelpOnContextCmd.h,.cc</h2>

<h2>HelpSelfCmd.h,.cc</h2>

<h2>PrintWidgetTreeCmd.h,.cc</h2>

<P>Moved HelpBrowser, HelpOnContextCmd, HelpSelfCmd, and PrintWidgetTreeCmd
from GUI library to MotifApp library.</P>

<P>HelpBrowser implements help via a WWW browser such as Mosaic. Synthetic
resources are attached to every widget to specify the browser to use, whether
or not it has Mosaic-style remote control, and the base and specific URL
for the help associated with the widget. So, help locations for context-sensitive
or standard help can be specified in the resource file and overridden via</P>

<P>standard X resource mechanisms. The browser process will be created
as needed, and subsequent help requests will either remote-control the
browser (if available), or will start a new browser process. A global object,
theHelpBrowser, is used to control the help browser.</P>

<P>HelpOnContextCmd implements context-sensitive help by changing the cursor
to a question mark, obtaining the widget under the next mouse click, and
invoking theHelpBrowser with that widget. The command is suitable for direct
inclusion in a menu.</P>

<P>HelpSelfCmd implements non-context-sensitive help by invoking theHelpBrowser
with the widget specified in the constructor (which is usually itself).
The command is suitable for direct inclusion in a menu.</P>

<P>PrintWidgetTreeCmd works like HelpOnContextCmd, but instead of obtaining
help for the widget clicked on, it prints out the name and class of the
widget and every parent in the hierarchy. This is a very useful capability
when building resource files. The command is suitable for direct inclusion
in a menu. However, it is recommended that an application resource be used
to control whether or not this command is present, so the implementers
have access to it during debugging but it doesn't confuse the end user.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(lep)</P>

<h2>HelpBrowser.h,.cc</h2>

<P>Implemented killBrowser(), which will terminate the browser process,
usually upon program exit. The VMS portion is not functional but could
be enabled if needed. If multiple browsers are active (if for example remote
control is not available), only the last one started will be killed.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>FramedButtonInterface.h,.cc</h2>

<P>CmdInterface class implementing a push button with a frame around it
(instead of the normal shadow). The frame does not &quot;push in&quot;,
although the color of the button does change (as usual) when armed. It
is used to get different visual effects around a button.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>StringKeyinInterface.h,.cc</h2>

<P>CmdInterface class implementing a TextField, which talks to a Cmd object
expecting a dynamically allocated string (freed via XtFree()) as its CmdValue.
The command is activated on both losingFocus and activate callbacks, but
is not activated more than once with the same string, thus preventing the
command from executing every time the mouse is moved out of the window.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(hbm)</P>

<h2>ListInterface.h,.cc</h2>

<P>Changed ListInterface so _w (baseWidget()) is the scrolled window parent
of the List, not the List itself. This was done to make baseWidget() more
consistent as the actual top-level widget of the component, which is what
is used for form attachments, etc. Also, added a listWidget() function
to return a pointer to the actual List widget.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>MenuDialog.h,.cc</h2>

<h2>CustomDialog.h,.cc</h2>

<P>New class (MenuDialog, subclassed from CustomDialog) which implements
menubars in a dialog window. The pure virtual function createMenuPanes()
should be implemented in a subclass to create a command list, and call
_menuBar-&gt;addCommands(), just like MenuWindow::createMenuPanes().</P>

<P>CustomDialog was slightly modified to support this subclass. The changes
should be transparent.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>PostSingleFileDialogCmd.h,.cc</h2>

<h2>SingleFileSelWindow.h,.cc</h2>

<h2>SingleFileSelBox.h,.cc</h2>

<P>This component implements commands for posting a Motif file selection
dialog. The caller has to create two command classes in his code. First,
a Cmd object has to be created that accepts string 'filename' as a dynamically
created CmdValue (free it using XtFree()). Then a PostSingleFileDialogCmd
object can be created with the previous Cmd as an argument. Note that SingleFileSelWindow
or even SingleFileSelBox can be used independently of PostSingleFileDialogCmd
if desired, for example if the dialog is posted in other ways or if the
file selection box is to be part of a larger dialog.</P>

<P>PostSingleFileDialogCmd posts the file selection dialog.</P>

<P>SingleFileSelWindow is a subclass of MainWindow. The purpose of this
class is to create a dialog window around a SingleFileSelBox component.</P>

<P>SingleFileSelBox is a subclass of CmdInterface. The class uses the standard
callbacks provided by file selection box Motif widget. It takes command
as an argument, which is executed when the Ok button is pressed. No public
functions or members (except for the constructor). This class is intended
to be used mainly by SingleFileSelWindow.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>Application.h,.cc</h2>

<P>Added virtual getOptions() and getNumOptions() so a subclass of Application
can supply command-line options to set resources. The values returned by
these functions are passed in to the XtAppInitialize() call. If the array
is dynamically allocated (which usually will not be the case), it can be
freed in the destructor - but since these functions are only called once
for the entire application, this small leak will not hurt.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>Application.h,.cc</h2>

<P>Added initialize_hook() function so subclasses of Application can do
their own initialization before the MainWindows are initialized, but after
X is set up.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>CmdInterface.h,.cc</h2>

<P>Added another constructor (Cmd *,char *) for use when the Cmd is optional.
If the Cmd is not specified, either it better not be run (requiring special
care on the part of the CmdInterface subclass), or setCommand() should
be called to define the command.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>Application.h,.cc</h2>

<P>Added initialize_X() function so subclasses of Application can do their
own X initialization, e.g. to set up to use a specific display. Normally
this function just calls XtAppInitialize().</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>CustomDialog.h,.cc</h2>

<P>Moved the Action area widgets from private section into protected, enabling
subclasses to gray out Apply button if the deferred mode is off.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>TextView.h,.cc</h2>

<P>Removed hard coded resources and replaced them with component default
resources.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(hbm)</P>

<h2>StringKeyinInterface.h,.cc</h2>

<P>Added new virtual function setValueAndRun(CmdValue) to set the value
of the string keyin text field and execute the command as if the value
had been typed in.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>BasicComponent.h</h2>

<P>Added #ifndef VMS_STRDUP_SIM_DEFINED around VMS strdup simulation</P>

<!-- ########################################################################>
<hr width="100%">

<h2>KeyinView.h</h2>

<P>Made static function for installCallback public instead of private to
work around bug in Sun C++ 4.0.1.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>PostSingleFileDialogCmd.cc</h2>

<P>Changed name of window from &quot;FileSelWindow&quot; to the name of
the command so that different windows can be distinguished in the resource
file (for e.g. window title).</P>

<!-- ########################################################################>
<hr width="100%">

<P>(eml)</P>

<h2>PopupMenu.h</h2>

<P>Added menu() function to return the widget ID fo the created menu. Could
be done via baseWidget() but menu() makes more semantic sense.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>CmdInterface.h,.cc</h2>

<P>Added virtual destructor that unregisters interface from the CmdList.
This enables a proper deletion of CmdInterface objects.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>Cmd.h,.cc</h2>

<P>Implemented a function that deletes an interface from its CmdList.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>ButtonInterface.h,.cc</h2>

<P>Added an empty virtual destructor. This enables the destructor for the
superclass to be executed. Added setButtonLabel function to set the button's
label string.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>FramedButtonInterface.h</h2>

<P>Added an empty virtual destructor. This enables the destructor for the
superclass to be executed.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>CustomDialog.cc</h2>

<P>Moved location where XmNpaneMinimum and XmNpaneMaximum resources for
_actionArea widget are set to before it is managed. Works around bug in
Solaris 2.4 Motif where the work area ended up with size 0.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>CustomDialog.h</h2>

<P>Made apply() and reset() into virtual functions.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>KeyinViewBlanked.h,.cc</h2>

<P>New class derived from KeyinView that blanks out the text string as
it is being entered. Intended for entering passwords. Used exactly like
KeyinView with the addition of an additional (optional) parameter on the
constructor which specifies what character to use for blanking (defaults
to ' ').</P>

<h2>KeyinView.h</h2>

<P>Made setFieldValue() and getFieldValue() virtual.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>CmdInterface.cc</h2>

<P>Enabled setCommand() to be called more than once by unregistering with
any old command before registering with the new one.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>PostDialogCmd.h</h2>

<P>A command to post a dialog provided in the command constructor. The
dialog must be a subclass of CustomDialog (or MenuDialog).</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>AskFirstCmd.h,.cc</h2>

<P>Added an optional command value parameter to the execute function, so
that commands with values could subclass from AskFirstCmd class.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>CloseCmd.h</h2>

<P>When invoked, exits application without first checking with user.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(emm)</P>

<h2>Application.h,.cc</h2>

<h2>MainWindow.h,.cc</h2>

<P>Added setBusyCursor() and removeBusyCursor() functions which set a &quot;busy
cursor&quot; on a window or application by putting an InputOnly window
on top of the existing windows and changing its cursor to a watch. MainWindow
routines do the work; Application routines call MainWindow routines for
each registered window. Users should use theApplication-&gt;(set|remove)BusyCursor()
instead of MainWindow routines in order to cover all windows. Make sure
that *all* flows of control out of the &quot;busy&quot; area of code turn
it off!</P>

<h2>CustomDialog.h,.cc</h2>

<P>CustomDialog is now derived from MainWindow instead of directly from
UIComponent. This allows the busy cursor on MainWindow's to apply to dialogs
as well.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>CustomDialog.cc</h2>

<P>Forgot to initialize _posted in constructor.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>MainWindow.cc</h2>

<P>Fixed minor bug in busy cursor code.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>InterruptibleCmd.h</h2>

<P>Moved all the private attributes and functions to protected area in
order to allow subclasses to override execute() function and change the
appearance of the working dialog.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(lep)</P>

<h2>UIComponent.h,.cc</h2>

<P>This class has been changed to be compatable with the lastest version
of Builder Xcessory (3.51). This is their distibution code. the major changes
are:</P>

<P>Added:</P>

<P><TT>UIComponent::initAppDefaults(const Widget parent, const char *cname,
</TT></P>

<DIR>
<DIR>
<DIR>
<DIR>
<P><TT>UIAppDefault *defs)</TT></P>
</DIR>
</DIR>
</DIR>
</DIR>

<P>// This method gets all the resources from the app-defaults file </P>

<P>// (resource databse) and fills in the table (defs) if the app default
</P>

<P>// value exists.</P>

<P>and</P>

<P><TT>UIComponent::setAppDefaults(const Widget w, UIAppDefault *defs,
</TT></P>

<DIR>
<DIR>
<DIR>
<DIR>
<P><TT>const char*inst_name )</TT></P>
</DIR>
</DIR>
</DIR>
</DIR>

<P>// This method applies the app defaults for the class to a specific</P>

<P>// instance. All the widgets in the path are loosly coupled (use *).</P>

<P>// To override a specific instance, use a tightly coupled app defaults</P>

<P>// resource line (use .).</P>

<P>The change is expected to be transparent and downwardly compatible.
They have been tested with dbWindows and no adverse effects have been noted.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(prs)</P>

<h2>QuitCmd.h,.cc</h2>

<P>Added additional constructor to set the message text.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>
<B><I></I></B>
<h2>InterruptibleCmd.h, .cc</h2>

<P>Added virtual function abortCleanup() which subclasses may implement
if different response is needed when the command was aborted vs. normally
finished.</P>

<!-- ########################################################################>
<hr width="100%">

<h2>MenuWindow.h</h2>

<P>Moved initialize() function from protected to public since superclass
MainWindow::initialize is public.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>UIComponent.h</h2>

<P>Added name() function to return component name.</P>

<-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>PrefManager.h, .cc</h2>

<h2>PrefView.h</h2>

<P>New set of classes to manage Preferences files. These Preferences files
are stored in standard X resource file format, and may be included in the
Xt resource file search list if desired. The application registers sets
of resources (<TT>XtResource</TT> structures, just like <TT>XtGetSubResources</TT>
needs) with the global <TT>thePrefManager</TT>, instead of calling <TT>UIComponent::getResources()</TT>.
The initial resources are obtained from the resource database (plus optionally
the initial preferences file, see below), just like with <TT>getResources()</TT>.</P>

<P>Once the resource sets are registered, <TT>thePrefManager-&gt;savePrefFile(char
*)</TT> can be used to save all of the registered resources into the given
file.</P>

<P>Conversely, <TT>thePrefManager-&gt;loadPrefFile(char *)</TT> will load
preferences into the application. However, this is more complicated than
save because the application must be notified of the changes. When each
resource set is registered, a subclass of PrefView should be provided,
which will be called when resources are loaded. The application has several
options for how to handle notification and resource updates; these are
described in detail in the PrefView.h comments. Basically, you can choose
to be provided a copy of the original object, and modify either the original
or the copy, so you can determine what has changed in a manner similar
to a widget's <TT>SetValues(</TT>) routine (by comparing each field in
sequence). The application may pass in <TT>NULL</TT> for the PrefView if
no notification is required.</P>

<P>The application must create the PrefManager somewhere in its initialization
(before any components need to register their resources). This is not done
automatically (meaning general-purpose components should check for the
existence of <TT>thePrefManager</TT> before using it). Just create a new
PrefManager; the constructor itself fills in <TT>thePrefManager</TT> global
pointer. An initial preferences file may be provided to the constructor,
so all registered resources will include the initial preferences from this
file. This allows the preferences to be set upon program startup, without
bothering with the load notification mechanism. However, see the comments
in the PrefManager constructor regarding limitations in the current implementation
of this. </P>

<P>In order for resources to be saved, there must be a &quot;reverse&quot;
type converter, to go from the resource's type to <TT>XtRString</TT>. None
of these are provided by Xt or Motif. However, if you use <TT>XmRepTypeRegister()</TT>
for enumerated types, <TT>XmRepTypeAddReverse()</TT> will install the reverse
converter. Converters from Boolean, Int, and Cardinal to String are provided
in the PrefManager package. If you have any other types, you must write
type-&gt;String converters yourself (and if sufficiently general, include
them in the PrefManager package). The PrefManager converters should be
used as examples.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(emm)</P>

<h2>Application.h,.cc</h2>

<h2>MainWindow.h,.cc</h2>

<P>Add deiconify() functions because manage() asserted _w (not all windows
are necessarily realized when you want to deiconify).</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>ErrorData.h, .cc</h2>

<P>This class contains information about an error message. First of all,
it contains information about the criticality of the message. The criticality
will be used by the ErrorManager class to determine whether to output message
to a log window, or post an error dialog, or maybe even do something else.
Second, it contains three text parts of the error message itself - pretext,
text, and details. The text of the error message can be obtained by calling
function getErrorMsg(). Note that getErrorMsg() is a virtual function and
it is expected that it will be overridden if a subclass is defined. A subclass
would be useful for handling application-specific error codes. The default
behavior of getErrorMsg() is to construct the error message as follows:</P>

<P>&lt;pretext&gt;: &lt;text&gt; (&lt;details&gt;)</P>

<P>e.g. </P>

<P>myapp: Memory allocation error (in new)</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>ErrorManager.h,.cc</h2>

<P>This class handles the processing of error messages. Depending on the
criticality of the message, it will post it to a motif error dialog, log
it in a LogWindow, or do something else. Error messages can come in the
form of an ErrorData object or as separate components of the ErrorData
class (which are criticality and strings). The application is expected
to generate a single global instance of ErrorManager, just like the Application
class. Classes that need to access ErrorManager's process() function must
include ErrorManager.h and then use theErrorManager, which is a global
pointer to the instance of ErrorManager class. theErrorManager is set up
automatically by the ErrorManager constructor.</P>

<P>Applications can create subclasses of ErrorManager to change how error
messages are handled.</P>

<P>Because theErrorManager is not automatically created, general-purpose
components should check it for NULL before using it. If components are
used for only a specific application suite where theErrorManager creation
is enforced, this check may not be necessary.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>LogWindow.h,.cc</h2>

<P>This is a dialog containing a text widget. Other classes should interact
with this component by calling the post(char *string) member function which
appends the string to the existing text and causes the dialog to be mapped
and/or deiconified. The component defines default resources to position
the window in the bottom-left corner of the screen.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>CustomDialog.cc</h2>

<P>Call manage() within post() method to cause the window to be mapped
in case it is iconified.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(emm)</P>

<h2>MainWindow.cc</h2>

<P>Fix deiconify() so it doesn't deiconify windows that have been popped
down. Added getWindowIconState() to determine if window is normal/iconic/
withdrawn.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>ErrorManager.h</h2>

<P>Made the last parameter to process() function optional to ease the use
of the class.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>
<B><I></I></B>
<h2>BasicComponent.cc</h2>

<P>Fix destructor to use delete[] instead of just delete.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(lep)</P>
<B><I></I></B>
<h2>PrintWidgetTreeCmd.cc, .h</h2>

<P>Added an overloaded constructor with an additional int as the third
parameter (making the widget parameter 4). Modified the original constructor
to set a flag for the original behavior. Modified the doit method such
that if the new int is passed as true via the new constructor, the widget
tree will be dumped to InfoDialogManager rather than sysout. If it is passed
a 0 or false, the original behavior results.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rxb)</P>

<h2>SingleFileSelBox.h SingleFileSelBox.cc</h2>

<P>A setValue() function has been added in order to set the file name and
path of the FileSelectionBox. For this purpose, the two resources XmNdirectory
and XmNdirSpec are set.</P>

<h2>SingleFileSelWindow.cc</h2>

<P>A call of the setValue() function has been inserted into the createWorkArea()
function of the SingleFileSelWindow class. The purpose of the call is to
set the current file name and path before first opening of the file selection
box for the case of a given start value of the _loadFileCmd object.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>CmdInterface.cc, CmdList.cc</h2>

<P>Minor changes to fix uninitialized variables and check for NULL before
dereferencing pointers.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>ErrorManager.cc</h2>

<P>Modified to print to stderr if X connection is not active, or on unknown
message action type.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>MainWindow.h, .cc</h2>

<P>Provided a function trapDeleteWindowEvent(Cmd *) that can be called
from subclasses. It causes the class to trap hits on Close on the window
manager menu and execute a command instead. The command is typically a
QuitCmd.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>YesNoDialog.h, .cc</h2>

<P>Motif Question dialog that also contains a No button. Note that this
dialog is not cached, it is created at every request and destroys itself
when the user presses any of the buttons. The user passes static functions
for Yes and, optionally, for No, Cancel, and Help buttons.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>CallbackCompressor.h, .cc</h2>

<P>A class/function that will &quot;compress&quot; callback events by setting
a short timer to see if any more similar ones are coming. If another callback
comes in before the timer expires, it is reset and the original is discarded.
If the</P>

<P>timer expires, the callback is dispatched to the application. Standard
Xt motion compression only works on motion events with no other events
in between; this works in any case.</P>

<P>Since the call_data structure is generally deallocated as soon as the
callback returns, it must be copied. Since the size is unknown for generic
callbacks, it must be passed in to the constructor. In addition, the event
itself may be copied if necessary, assuming the call_data matches XmAnyCallbackStruct.</P>

<P>Usage:</P>

<P><TT>cb = new CallbackCompressor(&amp;MyClass::myCallback, (void *)this,</TT></P>

<P><TT>sizeof(MyCallbackStruct), False);</TT></P>

<P><TT>XtAddCallback(widget, my_callback_name,</TT></P>

<P><TT>&amp;CallbackCompressor::callback, (XtPointer)cb);</TT></P>

<P>The &quot;this&quot; above is for the standard MotifApp callback paradigm;
it can be any client data. Everything with &quot;my&quot; above is replaced
for the actual instance. If the callback is removed, the cb object can
be deleted. Note that deleting the object may cause a pending callback
to be ignored. flushCallback() can be called to force out any pending callback.
Only one callback should be attached to any CallbackCompressor object.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>ErrorManager.h, .cc</h2>

<P>Added a function that executes if the error type is Fatal and when the
user presses OK button on the error dialog. The function is declared virtual
so that user can declare his/her own.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(emm)</P>

<h2>HelpBrowser.h, .cc</h2>

<P>HelpBrowser has 2 more 'run' functions: one takes a cmd, a URL, and
the remote-control flag as args, the other takes only a URL.</P>

<P>The first new 'run' function takes an actual URL and does all the real
work; the separate base/loc version now calls this one after concatenating
its arguments.</P>

<P>The URL-only 'run' version uses the Application's baseWidget to find
the browser type from the resource file.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(msm)</P>

<h2>HelpBrowser.h, .cc</h2>

<P>Support added for Netscape remote control.</P>

<P>A new resource, helpBrowserControlStyle, has been added. In the resource
file, the user may specify whether &quot;netscape&quot;, &quot;mosaic&quot;,
or &quot;default&quot; should be used. In the &quot;default&quot; case,
the command string is searched for &quot;netscape&quot;. If found, Netscape
style is used, otherwise, Mosaic style is used.</P>

<P>If the browser is Netscape, then 'run' tries to remote-control a Netscape
browser which is already running on the current display. If no Netscape
browser is currently running, 'run' will open a new browser, which will
be remote-controlled during subsequent help requests. </P>

<P>The Mosaic-style remote control is unchanged.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>Cmd.cc</h2>

<P>Fixed a bug in unRegisterInterface() that was stepping over the array
bounds when copying the array of command interfaces to a new memory location.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>Cmd.cc</h2>

<P>Set the command value for the interface when it registers with the command.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>TextView.cc</h2>

<P>Corrected minor error in the original code, where _w widget was created
as managed widget, instead of unmanaged.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>ColorChooser.h, .cc</h2>

<P>Added public function setColor(int r, int g, int b).</P>

<!-- ########################################################################>
<hr width="100%">

<P>(vxp)</P>

<h2>HSVView.h</h2>

<P>Made function RGBToHSV() public static.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(msm)</P>

<h2>CustomDialog.h</h2>

<P>Moved all non-static items from private to protected.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>CmdInterface.h</h2>
<h2>DialogManager.cc</h2>
<h2>Main.cc</h2>
<h2>MainWindow.cc</h2>
<h2>WorkingDialogManager.cc</h2>

<P>Changed all assert(p) to assert(p!=NULL) where p is a pointer, in order
to get rid of compile warnings on DEC Alpha/Unix.  Also added "class" keyword
to friend declaration in CmdInterface.h.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(ccf)</P>

<h2>HelpOnContextCmd.cc</h2>

<P>Added XFlush to change the cursor shape immediately after
an item is selected.</P>

<!-- ########################################################################>
<hr width="100%">

<P>(rgd)</P>

<h2>HelpBrowser.cc</h2>
<h2>Makefile.axp-linux</h2>
<h2>Makefile.x86-linux</h2>

<P>Removed space after openURL in netscape remote-control command, in order
to work with Linux.</P>
<p>Added makefiles for PC and Alpha Linux.</P>

<!-- ########################################################################>
<hr width="100%">

<P>
<HR WIDTH="100%"<I><A HREF="mailto:Bob.Deen@jpl.nasa.gov">Bob
Deen</A>, 2-Feb-99: Bob.Deen@jpl.nasa.gov</I></P>

</BODY>
</HTML>

