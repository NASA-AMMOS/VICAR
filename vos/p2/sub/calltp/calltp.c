/********************************************************************
 * calltp.cc: Contains subroutines that starts-up interactive
 * tiepoint collection program and gets tiepoints when that
 * program exits.  The tiepoints are transformed back and forth
 * through a temporary file.
 ********************************************************************
 * vxp	12/14/97 - original delivery
 * vxp  07/08/97 - replaced ascii file with ibis-2 file
 ********************************************************************/

#include "calltp.h"
#include "ibistiepnt.h"
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <zvproto.h>

#if !defined(__VMS)
  #include <unistd.h>
#endif

/********************************************************************
 * display_points: Starts-up interactive tiepoint collection program 
 * and gets tiepoints when that program exits.  It returns 2d array 
 * in form of { {S11 L11 S12 L12} ... {Sn1 Ln1 Sn2 Ln2} }.  Number of 
 * tiepoints n is returned in parameter npoints.
 ********************************************************************/
double **display_points(const char *image_1, const char *image_2, 
			double array[][4], int *npoints, char *pathname, 
			int *tp_status)
{
    char point_file_ibis[256];
    int i;
    int unit, ibis;
    int status;
    char cmd[1024];
    char x_resources[1024];
    char filenames[MAX_noimgs][FNAMLEN];
    int nrows;

    int num_gen_quals;
    char gen_qual_names[MAX_nogenqlf][STRING_32];
    char gen_qual_format[MAX_nogenqlf][IFMT_SIZE];
    char gen_qual_unit[MAX_nogenqlf][STRING_32];

    int num_pnt_quals;
    char pnt_qual_names[MAX_noimgqlf][STRING_32];
    char pnt_qual_format[MAX_noimgqlf][IFMT_SIZE];
    char pnt_qual_unit[MAX_noimgqlf][STRING_32];

    int num_images;

    int *gen_quals_full=NULL;
    float *gen_quals_real=NULL;
    char *gen_quals_text=NULL;
    int *pnt_quals_full=NULL;
    float *pnt_quals_real=NULL;
    char *pnt_quals_text=NULL;

    TPOINT *out_array;
    char rmcmd[256];

    float lines[2];
    float samps[2];


    strcpy(filenames[0], image_1);
    strcpy(filenames[1], image_2);

    if (pathname == NULL)
#if defined(__VMS)
    pathname = (char *)strdup("tp");
#else
    pathname = (char *)strdup("$R2LIB/tp");
#endif

#if defined(__VMS)
    sprintf(point_file_ibis, "tp%d", getpid() % 1000);
#else
    sprintf(point_file_ibis, "/tmp/tp.%d", getpid());
#endif

    nrows = *npoints;

    /* Create tiepoint file to be read by interactive program
     * Each tiepoint takes one line in the form 
     * line1 sample1 line2 sample2 separated by tab.
     */

    status = zvunit(&unit, "dp_1",  1, "u_name", point_file_ibis, NULL);
    if (status != OK) {
	fprintf(stderr, "Error occurred in zvunit, no changes were made\n");
	*npoints = 0;
	return NULL;
    }

    num_gen_quals = 0;
    num_pnt_quals = 0;
    
    status = zitiepnt_openw(unit, &ibis, 2, filenames,
               num_gen_quals, gen_qual_names, gen_qual_format, gen_qual_unit,
               num_pnt_quals, pnt_qual_names, pnt_qual_format, pnt_qual_unit,
               nrows);
    if (status != OK) {
	fprintf(stderr,
		"Error occurred in zitiepnt_openw\n");
	zitiepnt_close(unit);
	*npoints = 0;
	return NULL;
    }


    for (i = 0; i < nrows; i++) {
	samps[0] = (float)array[i][0];
	lines[0] = (float)array[i][1];
	samps[1] = (float)array[i][2];
	lines[1] = (float)array[i][3];
	status = zitiepnt_write(unit, i+1, lines, samps, 0, 0, 0, 0, 0, 0);
	if (status != OK) {
	    fprintf(stderr, 
		   "Error occurred in zitiepnt_write, no changes were made\n");
	    zitiepnt_close(unit);
	    *npoints = 0;
	    return NULL;
	}
    }

    status = zitiepnt_close(unit);
    if (status != OK) {
	fprintf(stderr, "Error occurred in zitiepnt_close\n");
    }
    
    /* Execute interactive tiepoint collection program */

    strcpy(x_resources, "-xrm \"*numImagesDisplayed: 2\"");
    strcat(x_resources, " -xrm \"*fullMatchIsEnforced: True\"");
    strcat(x_resources, " -xrm \"*enableSetSpecialStatus: True\"");
    sprintf(cmd, 
	    "%s -pfile %s %s %s %s", 
	    pathname, point_file_ibis, x_resources, image_1, image_2);
    printf("Executing %s\n", cmd);
    *tp_status = system(cmd);
    if (*tp_status == -1)
	fprintf(stderr, "Tiepoint program failed (errno=%d)\n", errno);

    /* Open tiepoint file to read the tiepoints generated by 
     * interactive program
     */

    *npoints = 0;
    status = zvunit(&unit, "dp_2",  1, "u_name", point_file_ibis, NULL);
    if (status != OK) {
        fprintf(stderr, "Error occurred in zvunit, no changes were made\n");
	*npoints = 0;
        return NULL;
    }

    /* Read the tiepoints into a list of arrays, each array 
     * consists of four elements.
     */

    status = zitiepnt_openr(unit, &ibis, &num_images, filenames,
			    &num_gen_quals, gen_qual_names, 
			    gen_qual_format, gen_qual_unit,
			    &num_pnt_quals, pnt_qual_names, 
			    pnt_qual_format, pnt_qual_unit,
			    npoints);
    if (status != OK) {
	fprintf(stderr, 
		"Error occurred in zitiepnt_openr, no changes were made\n");
	*npoints = 0;
        return NULL;
    }

    /* Allocate two dimensional array */

    out_array = (TPOINT *)malloc(*npoints * sizeof(TPOINT));
    if (out_array == NULL) {
	fprintf(stderr, "Not enough memory to allocate out_array!\n");
	zitiepnt_close(unit);
	*npoints = 0;
	return NULL;
    }

    for (i = 0; i < *npoints; i++) {

	/* Read one line of data */

	status = zitiepnt_read(unit, i+1,
                               lines, samps,
                               gen_quals_real, gen_quals_full, gen_quals_text,
                               pnt_quals_real, pnt_quals_full, pnt_quals_text);

	if (status != OK) {
	    fprintf(stderr,
                "Error occurred in zitiepnt_read, no changes were made\n");
	    zitiepnt_close(unit);
	    *npoints = 0;
	    return NULL;
	}

	out_array[i] = (TPOINT)malloc(4 * sizeof(double));

	if (out_array[i] == NULL) {
            fprintf(stderr, "Not enough memory to allocate out_array[%d]!\n",
                    i);
	    *npoints = 0;
            return NULL;
        }

	out_array[i][0] = (double)samps[0];
	out_array[i][1] = (double)lines[0];
	out_array[i][2] = (double)samps[1];
	out_array[i][3] = (double)lines[1];

    }

    status = zitiepnt_close(unit);
    if (status != OK) {
        fprintf(stderr, "Error occurred in zitiepnt_close\n");
    }

#if defined(__VMS)
    sprintf(rmcmd, "delete %s", point_file_ibis);
#else
    sprintf(rmcmd, "rm %s", point_file_ibis);
#endif

    system(rmcmd);

    return out_array;
}

#ifdef __VMS
/*******************************************************************
 * strdup: VMS (at least Alpha OpenVMS 6.1) does not have strdup,
 * so we create one here.  This is cribbed from Young's release notes.
 *******************************************************************/
char *strdup(const char *str)
{
    char *newStr;

    /* not robust, but neither is strdup */
    newStr = (char *)malloc((strlen(str) + 1)  * sizeof(char));
    strcpy(newStr, str);
    return (newStr);
}
#endif

