	INCLUDE 'VICMAIN_FOR'
	
C==============S T A R T   O F  EDIBIS_MAIN   ( E D I B I S)============
C
C
	SUBROUTINE MAIN44
C
C	IBIS PROGRAM 'EDIBIS'
C
C	Interactive Edit and Display of IBIS interface files (EDIBIS)
C
C	Original Programmer: Frank Evans	January 1987
C
C	Cognizant Programmer: Ray Bambery  
C
C	REVISION:	5		14 August 2011
C
C	REVISION HISTORY
c
c		Rev 6           RJB		08 December 2012
C		--- Fixes edibis_windows.c and dibis_terminal.c
C		    For POSIX compliance with RedHat Linus 6.2 and 
C		    MacOSX 10.7.4
C
c		Rev 5		RJB             14 August 2011
c		--- Fixes for gcc 4.4.4 under Linux
c		    In SUBROUTINE CONVERT_STRING_TO_COMMAND
c       	    had to add new call CALL FIND_ROWCOL
c                   THISROW and THISCOL are found from list directed read
c                   in gcc 4.4.4:
c                   READ (CMDLINE(CMDPOS:),*,ERR=332) THISCOL i
c                   does not detect properly the trailing ")" as a terminator
C                   It gives an error, where the older compilers evidently 
c                   recognized ")" as a proper terminator
c
C		REV 4		NDR		17 November 1994
C		--- Changed code to use direct IBIS2 routines
C		    for forward compatibility. Converted all
C		    FORTRAN I/O to C for portable coding.
C                   Added scripting and command-line features.
C                   and portable "curses" library windowing.
C
C		REV 3		NDR		4 February 1991
C		--- FIXED BUG CAUSING LOCKOUT WHEN "NEXT SCRN"
C		    KEYS HIT ON WYSE TERMINALS (FAILED IN INPUTKEY).
C		    Ref:   FR #66574 by C. Avis
C
C		REV 2		NDR		7 October 1987
C		--- ADDED SEARCH AND QUIT COMMANDS
C
CC
	IMPLICIT NONE
	INTEGER*4	COMMAND, ARGLEN
	CHARACTER*64 ARGSTRING
	INCLUDE 'edibis.fin'

C--------------------------------------------------------------------------
C          EDIBIS EXECUTABLE CODE STARTS HERE
C--------------------------------------------------------------------------

	call xvmessage ("EDIBIS version 2019-06-13"," ")
	CALL FILESETUP		! Open files, do transfers, etc.

	CALL INITIALIZE		! Initialize variables and screen

	CALL FILLBUFFER 

	IF (.NOT. BATCH_MODE) THEN
		CALL DISPLAYHEADER
		CALL DISPLAYSCREEN 
		CALL HIGHLIGHT
	ENDIF

	COMMAND = NONE
	DO WHILE ((COMMAND .NE. ENDEDIT).AND.(COMMAND.NE.QUIT))
	    CALL GETCOMMAND (COMMAND, ARGSTRING, ARGLEN)
	    CALL DOCOMMAND (COMMAND, ARGSTRING, ARGLEN)
	ENDDO

	RETURN
	END



C *****************************************************************
C          * * * * * * *  SUBROUTINES * * * * * * *
C *****************************************************************


c*************************************************************************
	SUBROUTINE IBISSCRATCH (OUTUNIT)
C
C	Opens a new temp unit in OUTUNIT
C	with name specified in "SCRATCH" parm

	IMPLICIT INTEGER(A-Z)
	CHARACTER*150 FNAME
C
	CALL XVP('SCRATCH',FNAME,CNT)
	CALL XVUNIT (OUTUNIT,'  ',INST,STATUS,'U_NAME',FNAME,' ')
	RETURN
	END


c*************************************************************************
	SUBROUTINE DOCOMMAND (COMMAND, ARGSTRING, ARGLEN)
C	    Jumps to appropriate routine depending on command number.
	IMPLICIT NONE
	INTEGER*4	COMMAND, ARGLEN
	CHARACTER*(*)  ARGSTRING
	INTEGER*4	CMDNUM
	INCLUDE 'edibis.fin'

	CMDNUM = 0
	IF (ARGLEN .GT. 0) THEN
	    READ (ARGSTRING(1:ARGLEN),*,ERR=199) CMDNUM
	ENDIF
199	CONTINUE

	GOTO (101,102,103,104,105,106,107,108,109,110,111,112,113,
     +	      114,115,116,117,118,119,120,121,122,123,124,125,101)
     +        COMMAND

101	CALL DO_TEXTSTRING (ARGSTRING, ARGLEN,COMMAND)
	RETURN
102	CALL DO_ENDEDIT
	RETURN
103	CALL DO_UPARROW
	RETURN
104	CALL DO_DOWNARROW
	RETURN
105	CALL DO_LEFTARROW
	RETURN
106	CALL DO_RIGHTARROW
	RETURN
107	CALL DO_PAGEUP
	RETURN
108	CALL DO_PAGEDOWN
	RETURN
109	CALL DO_PAGELEFT
	RETURN
110	CALL DO_PAGERIGHT
	RETURN
111	CALL DO_FILETOP
	RETURN
112	CALL DO_FILEBOTTOM
	RETURN
113	CALL DO_GOTOROW (CMDNUM)
	RETURN
114	CALL DO_GOTOCOL (CMDNUM)
	RETURN
115	CALL DO_DELETEROW (CMDNUM)
	RETURN
116	CALL DO_INSERTROW (CMDNUM)
	RETURN
117	CALL DO_ZEROCELL
	RETURN
118	CALL DO_RECALLCELL
	RETURN
119	CALL DO_CHNGFORMAT (ARGSTRING, ARGLEN)
	RETURN
120	CALL DO_REFRESH
	RETURN
121	CALL DO_HELP
	RETURN
122	CALL DO_QUIT
	COMMAND=ENDEDIT
	RETURN
123	CALL DO_SEARCH
	RETURN
124	CALL DO_INITSEARCH
	RETURN
125     RETURN !Bad command-do nothing

	END



C *****************************************************************
C          COMMAND EXECUTION SUBROUTINES 
C *****************************************************************

	SUBROUTINE DO_TEXTSTRING (ARGSTRING, ARGLEN,COMMAND)
	IMPLICIT NONE
	INTEGER*4	ARGLEN,COMMAND
	CHARACTER*(*)  ARGSTRING
	INTEGER*4	PTR, L, INTVALUE,INCOL
	REAL*4	VALUE
	EQUIVALENCE (VALUE,INTVALUE)
	INCLUDE 'edibis.fin'

	IF (ARGLEN.EQ.0) RETURN

	
	IF (COMMAND.NE.SETTEXTVAL) THEN 
        ! check for string-command
 	  IF (ARGSTRING(1:4) .EQ. 'HELP' .OR.  ! If person types help
     +	      ARGSTRING(1:4) .EQ. 'help') THEN ! at a numeric column
	         CALL DO_HELP		       ! then he needs it!
		 RETURN
	  ELSEIF (ARGSTRING(1:4) .EQ. 'QUIT' .OR.
     +	      ARGSTRING(1:4) .EQ. 'quit') THEN
	         CALL DO_QUIT
		 COMMAND=QUIT
		 RETURN
	  ELSEIF (ARGSTRING(1:4) .EQ. 'EXIT' .OR.
     +	      ARGSTRING(1:4) .EQ. 'exit') THEN
	         CALL DO_ENDEDIT
		 COMMAND=ENDEDIT
		 RETURN
	  ENDIF
	ENDIF

	IF (READONLY) THEN
		CALL EMIT_BEEP
		CALL DISPLAY_STATUS('File is Read-only!')
		RETURN
	ENDIF

C         Interpret the string as appropriate input to row/column
	 PTR = CURROW - FIRSTBUFROW + 1
	 INCOL = CURCOL - FIRSTBUFCOL + 1
	 IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
		READ (ARGSTRING,*, ERR=199) IBISBUF(PTR,INCOL)
	 ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
		READ (ARGSTRING,*, ERR=199) IBISBUF_FULL(PTR,INCOL)
	 ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
		READ (ARGSTRING,*, ERR=199) IBISBUF_DOUB(PTR,INCOL)
	 ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
		READ (ARGSTRING,*, ERR=199) IBISBUF_COMP(PTR,INCOL)
	 ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
		L = MIN (ARGLEN, 4)
		IBISBUF_A4(PTR,INCOL) = ARGSTRING(1:L)
	 ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
		L = MIN (ARGLEN, 16)
		IBISBUF_A16(PTR,INCOL) = ARGSTRING(1:L)
	 ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
		L = MIN (ARGLEN, 32)
		IBISBUF_A32(PTR,INCOL) = ARGSTRING(1:L)
	 ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
		L = MIN (ARGLEN, 64)
		IBISBUF_A64(PTR,INCOL) = ARGSTRING(1:L)
	 ENDIF
C				! Change the cell
	 COLCHANGED(CURCOL) = .TRUE.
	 IF (BATCH_MODE) RETURN
	 CALL HIGHLIGHT

199	CONTINUE

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_ENDEDIT
	IMPLICIT NONE
	INTEGER*4	STATUS
	INCLUDE 'edibis.fin'

	IF (.NOT. BATCH_MODE) THEN
		CALL ENDSCREEN
		IF (.NOT.READONLY) 
     +             CALL XVMESSAGE('*** SAVING FILE... ***',' ')
	ENDIF
	
	CALL OUTPUTBUFFER

	IF (READONLY.OR.OUTUNIT.EQ.-1) THEN
		CALL IBIS_FILE_CLOSE(IBIS,' ',STATUS) 
		IF (STATUS.NE.1) THEN
			CALL IBIS_SIGNAL( IBIS,STATUS,1)
		ENDIF
	ELSE
		! Copy data back from working file and delete it
		CALL IBIS_FILE_CLOSE(IBIS,'UKEEP',STATUS)
		CALL IBIS_FILE_UNIT_OPEN(IBIS,STATUS)
		CALL IBISCOPY(IBIS,OUTUNIT,.FALSE.)
		CALL XVCLOSE (UNIT, STATUS,'CLOS_ACT','DELETE',' ')
	ENDIF

	RETURN
	END

c*************************************************************************
	SUBROUTINE DO_QUIT
	IMPLICIT NONE
	INTEGER*4	STATUS
	INCLUDE 'edibis.fin'

	CALL ENDSCREEN
	CALL XVMESSAGE('*** QUITTING EDIBIS ***',' ')
	IF (READONLY.OR.OUTUNIT.EQ.-1) RETURN
	CALL XVCLOSE (UNIT, STATUS,'CLOS_ACT','DELETE',' ')

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_UPARROW
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	CURROW = CURROW - 1
	IF (CURROW .LT. 1) THEN
	    CURROW = 1
	    CALL EMIT_BEEP
	ELSE IF (CURROW .LT. DISPROW) THEN
	    DISPROW = DISPROW - 1
	    CALL CHECKBUFPOS (DISPROW)
	ENDIF

	CALL UPDATEROWDISPLAY
	CALL DISPLAYHEADER
	CALL DISPLAYSCREEN
	CALL HIGHLIGHT

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_DOWNARROW
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	CURROW = CURROW + 1
	IF (CURROW .GT. CLEN) THEN
	    CURROW = CLEN
	    CALL EMIT_BEEP
	ELSE IF (CURROW .GT. DISPROW+NUMDISPROWS-1) THEN
	    DISPROW = DISPROW + 1
	    CALL CHECKBUFPOS (DISPROW)
	ENDIF

	CALL UPDATEROWDISPLAY
	CALL DISPLAYHEADER
	CALL DISPLAYSCREEN
	CALL HIGHLIGHT

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_LEFTARROW
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	CURCOL = CURCOL - 1
	IF (CURCOL .LT. 1) THEN
	    CURCOL = 1
	    CALL EMIT_BEEP
	ELSE IF (CURCOL .LT. DISPCOL) THEN
	    CALL WRITEBUFCOL (DISPCOL+NUMDISPCOLS-1)
	    CALL SETDISPCOL (DISPCOL-1)
	    CALL SETUPCOLDISPLAY 
	    CALL READBUFCOL (DISPCOL)
	    CALL DISPLAYFORMATS
	    CALL DISPLAYSCREEN
	ENDIF

	CALL UPDATECOLDISPLAY
	CALL HIGHLIGHT

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_RIGHTARROW
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	CURCOL = CURCOL + 1
	IF (CURCOL .GT. NCOL) THEN
	    CURCOL = NCOL
	    CALL EMIT_BEEP
	ELSE IF (CURCOL .GT. DISPCOL+NUMDISPCOLS-1) THEN
	    CALL WRITEBUFCOL (DISPCOL)
	    CALL SETDISPCOL (DISPCOL+1)
	    CALL SETUPCOLDISPLAY 
	    CALL READBUFCOL (DISPCOL+NUMDISPCOLS-1)
	    CALL ADJUST_RIGHT
	    CALL DISPLAYFORMATS
	    CALL DISPLAYSCREEN
	ENDIF

	CALL UPDATECOLDISPLAY
	CALL HIGHLIGHT

	RETURN
	END


c*************************************************************************
	SUBROUTINE ADJUST_RIGHT
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	! Sometimes we have to go over more than one
	! column to accomodate the new one:
	DO WHILE (COLXPOS(CURCOL)+COLXLEN(CURCOL).GT.SCREENXSIZE)
	    CALL WRITEBUFCOL (DISPCOL)
	    CALL SETDISPCOL (DISPCOL+1)
	    CALL SETUPCOLDISPLAY 
	    CALL READBUFCOL (DISPCOL+NUMDISPCOLS-1)
	ENDDO

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_PAGEUP
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	IF (DISPROW .GT. 1) THEN
	    DISPROW = DISPROW - NUMDISPROWS
	    DISPROW = MAX (DISPROW, 1)
	    CURROW = DISPROW
	    CALL CHECKBUFPOS (DISPROW)
	    CALL DISPLAYSCREEN
	    CALL UPDATEROWDISPLAY
	    CALL HIGHLIGHT
	ELSE
	    IF (CURROW .EQ. 1) THEN
		CALL EMIT_BEEP
	    ELSE
		CURROW = 1
		CALL UPDATEROWDISPLAY
		CALL HIGHLIGHT
	    ENDIF
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_PAGEDOWN
	IMPLICIT NONE
	INTEGER*4	MAXDISPROW
	INCLUDE 'edibis.fin'

	MAXDISPROW = CLEN - NUMDISPROWS + 1
	IF (DISPROW .LT. MAXDISPROW) THEN
	    DISPROW = DISPROW + NUMDISPROWS
	    DISPROW = MIN (DISPROW, MAXDISPROW)
	    CURROW = DISPROW
	    CALL CHECKBUFPOS (DISPROW)
	    CALL DISPLAYSCREEN
	    CALL UPDATEROWDISPLAY
	    CALL HIGHLIGHT
	ELSE
	    IF (CURROW .EQ. CLEN) THEN
		CALL EMIT_BEEP
	    ELSE
		CURROW = CLEN
		CALL UPDATEROWDISPLAY
		CALL HIGHLIGHT
	    ENDIF
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_PAGELEFT
	IMPLICIT NONE
	INTEGER*4 NEWCOL
	INCLUDE 'edibis.fin'

	IF (DISPCOL .GT. 1) THEN
	    CALL OUTPUTBUFFER
	    NEWCOL = DISPCOL - NUMDISPCOLS
	    NEWCOL = MAX (NEWCOL, 1)
	    CALL SETDISPCOL (NEWCOL)
	    CURCOL = DISPCOL
	    CALL FILLBUFFER
	    CALL SETUPCOLDISPLAY 
	    CALL DISPLAYFORMATS
	    CALL DISPLAYSCREEN
	    CALL UPDATECOLDISPLAY
	    CALL HIGHLIGHT
	ELSE
	    IF (CURCOL .EQ. 1) THEN
		CALL EMIT_BEEP
	    ELSE
		CURCOL = 1
		CALL UPDATECOLDISPLAY
		CALL HIGHLIGHT
	    ENDIF
	ENDIF

	RETURN
	END



c*************************************************************************
	SUBROUTINE DO_PAGERIGHT
	IMPLICIT NONE
	INTEGER*4	MAXDISPCOL
	INTEGER*4 NEWCOL
	INCLUDE 'edibis.fin'

	MAXDISPCOL = NCOL - NUMDISPCOLS + 1
	IF (DISPCOL .LT. MAXDISPCOL) THEN
	    CALL OUTPUTBUFFER
	    NEWCOL = DISPCOL + NUMDISPCOLS
	    NEWCOL = MIN (NEWCOL, NCOL)
	    CALL SETDISPCOL (NEWCOL)
	    CURCOL = DISPCOL
	    CALL FILLBUFFER
	    CALL SETUPCOLDISPLAY 
	    CALL DISPLAYFORMATS
	    CALL DISPLAYSCREEN
	    CALL UPDATECOLDISPLAY
	    CALL HIGHLIGHT
	ELSE
	    IF (CURCOL .EQ. NCOL) THEN
		CALL EMIT_BEEP
	    ELSE
		CURCOL = NCOL
		CALL UPDATECOLDISPLAY
		CALL HIGHLIGHT
	    ENDIF
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_FILETOP
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	IF (DISPROW .GT. 1 .OR. BATCH_MODE) THEN
	    DISPROW = 1
	    CURROW = 1
	    CALL CHECKBUFPOS (DISPROW)
	    IF (BATCH_MODE) RETURN
	    CALL DISPLAYSCREEN
	    CALL UPDATEROWDISPLAY
	    CALL HIGHLIGHT
	ELSE
	    IF (CURROW .EQ. 1) THEN
		CALL EMIT_BEEP
	    ELSE
		CURROW = 1
		CALL UPDATEROWDISPLAY
		CALL HIGHLIGHT
	    ENDIF
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_FILEBOTTOM
	IMPLICIT NONE
	INTEGER*4	MAXDISPROW
	INCLUDE 'edibis.fin'

	MAXDISPROW = CLEN - NUMDISPROWS + 1
	IF (DISPROW .LT. MAXDISPROW .OR. BATCH_MODE) THEN
	    DISPROW = MAXDISPROW
	    CURROW = CLEN
	    CALL CHECKBUFPOS (DISPROW)
	    IF (BATCH_MODE) RETURN
	    CALL DISPLAYSCREEN
	    CALL UPDATEROWDISPLAY
	    CALL HIGHLIGHT
	ELSE
	    IF (CURROW .EQ. CLEN) THEN
		CALL EMIT_BEEP
	    ELSE
		CURROW = CLEN
		CALL UPDATEROWDISPLAY
		CALL HIGHLIGHT
	    ENDIF
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_GOTOROW (CMDNUM)
	IMPLICIT NONE
	INTEGER*4	CMDNUM
	INCLUDE 'edibis.fin'

	IF (CMDNUM .GT. 0) THEN
	    CURROW =  MIN( MAX(CMDNUM,1), CLEN)
	    IF (CURROW .GT. DISPROW + NUMDISPROWS -1
     +           .OR. CURROW.LT.DISPROW) THEN
	       DISPROW = MIN( MAX(CMDNUM,1), CLEN-NUMDISPROWS+1)
	       CALL CHECKBUFPOS (DISPROW)
	       IF (.NOT. BATCH_MODE) CALL DISPLAYSCREEN
	    ENDIF
	    IF (BATCH_MODE) RETURN
	    CALL UPDATEROWDISPLAY
	    CALL HIGHLIGHT
	ENDIF

	RETURN
	END

c*************************************************************************
	SUBROUTINE DO_GOTOCOL (CMDNUM)
	IMPLICIT NONE
	INTEGER*4	CMDNUM
	INTEGER*4 NEWCOL
	INCLUDE 'edibis.fin'

	IF (CMDNUM .GT. 0) THEN
	    CURCOL =  MIN( MAX(CMDNUM,1), NCOL)
	    NEWCOL = MIN( MAX(CMDNUM,1), NCOL-NUMDISPCOLS+1)
	    IF (CURCOL .GT. DISPCOL+NUMDISPCOLS-1 .OR.
     +            (CURCOL .LT. DISPCOL) ) THEN
	    	CALL OUTPUTBUFFER
	    	CALL SETDISPCOL (NEWCOL)
		IF (.NOT. BATCH_MODE) CALL SETUPCOLDISPLAY 
		CALL READBUFCOL (CURCOL)
		IF (.NOT. BATCH_MODE) THEN
			CALL ADJUST_RIGHT
			CALL DISPLAYHEADER
			CALL DISPLAYSCREEN
		ENDIF
	    ENDIF
	    IF (BATCH_MODE) RETURN
	    CALL UPDATECOLDISPLAY
	    CALL HIGHLIGHT
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_DELETEROW (CMDNUM)
C	    Deletes rows
	IMPLICIT NONE
	INTEGER*4	CMDNUM,STATUS
	INTEGER*4	NUMDELETE
	INCLUDE 'edibis.fin'

	IF (READONLY) THEN
		CALL EMIT_BEEP
		CALL DISPLAY_STATUS('File is Read-only!')
		RETURN
	ENDIF

	CALL OUTPUTBUFFER
	
	NUMDELETE = 1
	IF (CMDNUM .GT. 0)  NUMDELETE = MIN (MAX(CMDNUM,1), CLEN-CURROW+1)
	
	CALL IBIS_ROW_DELETE(IBIS,CURROW,NUMDELETE,STATUS)
	
	CLEN = CLEN - NUMDELETE
	NUMDISPROWS = MIN (MAXROWS, CLEN)
	CURROW = MIN (CURROW, CLEN)
	DISPROW = MIN (DISPROW, CLEN-NUMDISPROWS+1)
	DISPROW = MAX (DISPROW, 1)
	FIRSTBUFROW = 128*((DISPROW-64)/128) + 1
	FIRSTBUFROW = MIN (FIRSTBUFROW, 128*((CLEN-129)/128)+1)
	FIRSTBUFROW = MAX (FIRSTBUFROW, 1)
	!CALL CLEAR_DATA
	CALL FILLBUFFER
	IF (BATCH_MODE) RETURN
	CALL DISPLAYHEADER
	CALL DISPLAYSCREEN
	CALL HIGHLIGHT
	
	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_INSERTROW (CMDNUM)
C	    Inserts rows
	IMPLICIT NONE
	INTEGER*4	CMDNUM,STATUS
	INTEGER*4	NUMINSERT
	INCLUDE 'edibis.fin'

	IF (READONLY) THEN
		CALL EMIT_BEEP
		CALL DISPLAY_STATUS('File is Read-only!')
		RETURN
	ENDIF

	CALL OUTPUTBUFFER
	NUMINSERT = 1
	IF (CMDNUM .GT. 0)  NUMINSERT = MAX (CMDNUM, 1)

	CALL IBIS_ROW_NEW(IBIS,CURROW,NUMINSERT,STATUS)

	CLEN = CLEN + NUMINSERT
	NUMDISPROWS = MIN (MAXROWS, CLEN)
	FIRSTBUFROW = 128*((DISPROW-64)/128) + 1
	FIRSTBUFROW = MIN (FIRSTBUFROW, 128*((CLEN-129)/128)+1)
	FIRSTBUFROW = MAX (FIRSTBUFROW, 1)
	CALL FILLBUFFER
	IF (BATCH_MODE) RETURN
	CALL DISPLAYHEADER
	CALL DISPLAYSCREEN
	CALL HIGHLIGHT

	RETURN
	END



c*************************************************************************
	SUBROUTINE DO_ZEROCELL
	IMPLICIT NONE
	INTEGER*4	PTR,INCOL
	INCLUDE 'edibis.fin'

	IF (READONLY) THEN
		CALL EMIT_BEEP
		CALL DISPLAY_STATUS('File is Read-only!')
		RETURN
	ENDIF
	
	PTR = CURROW - FIRSTBUFROW + 1
	INCOL = CURCOL - FIRSTBUFCOL + 1
	IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
	    SAVECELLVALUE = IBISBUF(PTR,INCOL) 
	    IBISBUF(PTR,INCOL) = 0.0
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
	    SAVE_FULL = IBISBUF_FULL(PTR,INCOL) 
	    IBISBUF_FULL(PTR,INCOL) = 0
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
	    SAVE_DOUB = IBISBUF_DOUB(PTR,INCOL) 
	    IBISBUF_DOUB(PTR,INCOL) = 0.0
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
	    SAVE_COMP = IBISBUF_COMP(PTR,INCOL) 
	    IBISBUF_COMP(PTR,INCOL) = (0.0,0.0)
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
	    SAVE_A4 = IBISBUF_A4(PTR,INCOL) 
	    IBISBUF_A4(PTR,INCOL) = '    '
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
	    SAVE_A16 = IBISBUF_A16(PTR,INCOL) 
	    IBISBUF_A16(PTR,INCOL) = '                '
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
	    SAVE_A32 = IBISBUF_A32(PTR,INCOL) 
	    IBISBUF_A32(PTR,INCOL) = '                                '
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
	    SAVE_A64 = IBISBUF_A64(PTR,INCOL) 
	    IBISBUF_A64(PTR,INCOL) =
     +'                                                                '
	ENDIF
	COLCHANGED(CURCOL) = .TRUE.
	IF (BATCH_MODE) RETURN
	CALL HIGHLIGHT

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_RECALLCELL
	IMPLICIT NONE
	INTEGER*4	PTR,INCOL
	INCLUDE 'edibis.fin'

	IF (READONLY) THEN
		CALL EMIT_BEEP
		CALL DISPLAY_STATUS('File is Read-only!')
		RETURN
	ENDIF

	PTR = CURROW - FIRSTBUFROW + 1
	INCOL = CURCOL - FIRSTBUFCOL + 1
	IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
	    IBISBUF(PTR,INCOL) = SAVECELLVALUE
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
	    IBISBUF_FULL(PTR,INCOL) = SAVE_FULL
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
	    IBISBUF_DOUB(PTR,INCOL) = SAVE_DOUB
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
	    IBISBUF_COMP(PTR,INCOL) = SAVE_COMP
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
	    IBISBUF_A4(PTR,INCOL) = SAVE_A4
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
	    IBISBUF_A16(PTR,INCOL) = SAVE_A16
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
	    IBISBUF_A32(PTR,INCOL) = SAVE_A32
	ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
	    IBISBUF_A64(PTR,INCOL) = SAVE_A64
	ENDIF
	COLCHANGED(CURCOL) = .TRUE.
	IF (BATCH_MODE) RETURN
	CALL HIGHLIGHT

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_CHNGFORMAT (ARGSTRING, ARGLEN)
	IMPLICIT NONE
	INTEGER*4	ARGLEN, ASC, FORMCODE, I, SLEN,STATUS
	CHARACTER*(*)  ARGSTRING
	CHARACTER*64 STRING
	CHARACTER*32 TMPFORMAT
	CHARACTER*1  CHR
	INCLUDE 'edibis.fin'


	! This will only work for IBIS-1, which has no
	! internal formatting.
	
	IF (FILEVERSION(6:6).NE.'2' .AND. ARGLEN .GT. 0) THEN
	    FORMCODE = 0
	    TMPFORMAT = ARGSTRING
	    DO I = 1,32		! Find out the data type real, int, or char
		ASC = ICHAR(TMPFORMAT(I:I))
		IF (ASC .GE. 96)  ASC = ASC - 32
		CHR = CHAR(ASC)
		IF (CHR .EQ. 'F' .OR. CHR .EQ. 'E')  FORMCODE = FMT_REAL
		IF (CHR .EQ. 'I')  FORMCODE = FMT_FULL
		IF (CHR .EQ. 'A')  FORMCODE = FMT_A4
	    ENDDO
	    IF (FORMCODE .EQ. FMT_REAL) THEN	! See if legal format and find size
		CALL IBIS_COLUMN_SET( IBIS,'FORMAT','REAL',CURCOL,STATUS)
		IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,0)
		CALL IBIS_COLUMN_SET( IBIS,'U_FORMAT','REAL',CURCOL,STATUS)
		IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,0)
		WRITE (STRING, TMPFORMAT ,ERR=199) 7.0
	    ELSE IF (FORMCODE .EQ. FMT_FULL) THEN
		CALL IBIS_COLUMN_SET( IBIS,'FORMAT','FULL',CURCOL,STATUS)
		IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,0)
		CALL IBIS_COLUMN_SET( IBIS,'U_FORMAT','FULL',CURCOL,STATUS)
		IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,0)
		WRITE (STRING, TMPFORMAT ,ERR=199) 7
	    ELSE IF (FORMCODE .EQ. FMT_A4) THEN
		CALL IBIS_COLUMN_SET( IBIS,'FORMAT','A3',CURCOL,STATUS)
		IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,0)
		CALL IBIS_COLUMN_SET( IBIS,'U_FORMAT','A4',CURCOL,STATUS)
		IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,0)
		WRITE (STRING, TMPFORMAT ,ERR=199) 'XXXX'
	    ELSE
		GOTO 199
	    ENDIF
	    COLXLEN(CURCOL) = SLEN(STRING)	! Change the format
	    COLFORMAT(CURCOL) = TMPFORMAT 
	    COLFORMCODE(CURCOL) = FORMCODE
            CALL READBUFCOL (CURCOL) 		!Refresh buffer
	    IF (BATCH_MODE) RETURN
	    CALL SETUPCOLDISPLAY
	    CALL DISPLAYFORMATS			! Redisplay everything
	    CALL DISPLAYSCREEN
	    CALL HIGHLIGHT
	ENDIF
199	CONTINUE

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_REFRESH
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	CALL NEWSCREEN
	CALL DISPLAYHEADER
	CALL DISPLAYSCREEN
	CALL HIGHLIGHT

	RETURN
	END

c*************************************************************************
	SUBROUTINE DO_HELP
	IMPLICIT NONE
	INTEGER*4	KEY

	CALL SHOW_HELP
	CALL KEYINPUT (KEY)
	IF (KEY.EQ.13) THEN
		CALL SHOW_NOKEYPAD_HELP
		CALL KEYINPUT (KEY)
	ENDIF
	CALL DO_REFRESH

	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_INITSEARCH
	IMPLICIT NONE
	INTEGER*4 CDUM,STRLEN,STAT
	CHARACTER*80 RANGESTRING
	INCLUDE 'edibis.fin'

	INITSET = .TRUE.
	CALL DISPLAY_PROMPT('ENTER RANGE] ')

	CALL OUTPUTBUFFER   !YOU WANT TO SEARCH ON CURRENT WORK FILE.
	CALL GET_COMMAND_FROM_KEYBOARD(CDUM,RANGESTRING,STRLEN)
	CALL SET_SEARCH_STRING(RANGESTRING,STRLEN,STAT)
	IF (STAT.EQ.0) GOTO 199
	
	CALL DO_SEARCH
	RETURN

199	CONTINUE
     	CALL EMIT_BEEP
	CALL DISPLAY_STATUS('SYNTAX: VAL or MIN:MAX')
	RETURN
	END

c*************************************************************************
	SUBROUTINE SET_SEARCH_STRING(RANGESTRING,STRLEN,STAT)
	IMPLICIT NONE
	INTEGER*4 STRLEN,I,STAT
	INTEGER*4 LEN1, LEN2
	CHARACTER*80 RANGESTRING
	INCLUDE 'edibis.fin'

	STAT=1
	INITSET = .TRUE.

	I=0
	DO WHILE ((RANGESTRING(I:I).NE.':').AND.(I.LE.STRLEN))
		I = I + 1
	ENDDO
	LEN1 = I-1
	LEN2 = STRLEN - I

	IF ((I.EQ.1).AND.(STRLEN.GT.0)) THEN  ! :MAX OPTION
	
	    IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
		MINVAL = -1.6E38
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
		MINVAL_FULL = -2147483647
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
	    	! how can we do this portably??
		MINVAL_DOUB = -1.6D38
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
		MINVAL_COMP = (-1.6E38,0)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
		MINVAL_A4 = '    '
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
		MINVAL_A16 = '                '
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
		MINVAL_A32 = '                                '
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
		MINVAL_A64 = 
     +'                                                                '
	    ENDIF	

	ELSE !GET MINVAL
	    IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
		READ (RANGESTRING(1:LEN1),*, ERR=199) MINVAL
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
		READ (RANGESTRING(1:LEN1),*, ERR=199) MINVAL_FULL
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
		READ (RANGESTRING(1:LEN1),*, ERR=199) MINVAL_DOUB
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
		READ (RANGESTRING(1:LEN1),*, ERR=199) MINVAL_COMP
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
		MINVAL_A4 = RANGESTRING(1:LEN1)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
		MINVAL_A16 = RANGESTRING(1:LEN1)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
		MINVAL_A32 = RANGESTRING(1:LEN1)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
		MINVAL_A64 = RANGESTRING(1:LEN1)
	    ENDIF
	ENDIF

	IF ((I.EQ.STRLEN).AND.(STRLEN.GT.0)) THEN  ! MIN: OPTION
	    IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
		MAXVAL = 1.6E38
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
		MAXVAL_FULL = 2147483647
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
		MAXVAL_DOUB = 1.6D38
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
		MAXVAL_COMP = (1.6E38,0)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
		MAXVAL_A4 = '~~~~'
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
		MAXVAL_A16 = '~~~~~~~~~~~~~~~~'
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
		MAXVAL_A32 = '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
		MAXVAL_A64 =
     +'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
	    ENDIF	

	ELSE   ! GET MAXVAL
            IF (LEN2.LT.1) THEN
                MAXVAL_A64 = MINVAL_A64
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
		READ (RANGESTRING(I+1:),*, ERR=199) MAXVAL
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
		READ (RANGESTRING(I+1:),*, ERR=199) MAXVAL_FULL
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
		READ (RANGESTRING(I+1:),*, ERR=199) MAXVAL_DOUB
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
		READ (RANGESTRING(I+1:),*, ERR=199) MAXVAL_COMP
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
		MAXVAL_A4 = RANGESTRING(I+1:)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
		MAXVAL_A16 = RANGESTRING(I+1:)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
		MAXVAL_A32 = RANGESTRING(I+1:)
	    ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
		MAXVAL_A64 = RANGESTRING(I+1:)
	    ENDIF

	ENDIF

	RETURN

199	STAT=0
	RETURN
	END


c*************************************************************************
	SUBROUTINE DO_SEARCH
	IMPLICIT NONE
	LOGICAL*4 NOTFOUND
	INTEGER*4 ROWSEARCHVAL,HALFDISP
	INCLUDE 'edibis.fin'

	CALL OUTPUTBUFFER   !YOU WANT TO SEARCH ON CURRENT WORK FILE.
	IF (INITSET) THEN
	   CURROW = ROWSEARCHVAL(NOTFOUND)
	   IF (BATCH_MODE) THEN
	   	IF (NOTFOUND) THEN
			CALL XVMESSAGE('??E -STRING NOT FOUND',' ')
			CALL ABEND
		ELSE
			CALL DO_GOTOROW(CURROW)
		ENDIF
		RETURN
	   ENDIF
	   IF (NOTFOUND) THEN
	     	CALL EMIT_BEEP
		CALL DISPLAY_STATUS('NOT FOUND')
	   ELSE  ! DISPLAY IT
		IF ((CURROW.GT.DISPROW+NUMDISPROWS-1).OR.
     +		(CURROW.LT.DISPROW)) THEN
		  HALFDISP = NUMDISPROWS/2
		  DISPROW = MAX(1, CURROW-HALFDISP)
		  DISPROW = MIN(DISPROW, CLEN-NUMDISPROWS+1)
		  CALL CHECKBUFPOS (DISPROW)
		  CALL DISPLAYSCREEN
		ENDIF
	        CALL UPDATEROWDISPLAY
	   	CALL HIGHLIGHT
	   ENDIF
	ELSE
	   CALL DO_INITSEARCH
	ENDIF

	RETURN
	END

c*************************************************************************
	FUNCTION ROWSEARCHVAL(EOFL)
	IMPLICIT NONE
	INTEGER*4 BUFSIZE, ROWSEARCHVAL, INCREMENT, ROW
	INTEGER*4 POS,STATUS
	INTEGER*4 TOPROW,MAXBLKS
	INTEGER*4 ROWSNOW,BUFINC
	PARAMETER (MAXBLKS = 1)
	PARAMETER (BUFSIZE = 128*MAXBLKS)  !WINDOW FOR SEARCH
	LOGICAL*4 EOFL,OUTOFBOUNDS,SAMEBUF
	CHARACTER*64 COLBUF_A64(BUFSIZE)
	CHARACTER*32 COLBUF_A32(BUFSIZE)
	CHARACTER*16 COLBUF_A16(BUFSIZE)
	CHARACTER*4 COLBUF_A4(BUFSIZE)
	COMPLEX*8 COLBUF_COMP(BUFSIZE)
	REAL*8 COLBUF_DOUB(BUFSIZE)
	INTEGER*4 COLBUF_FULL(BUFSIZE)
	REAL*4 COLBUF(BUFSIZE)
	EQUIVALENCE(COLBUF,COLBUF_FULL,COLBUF_COMP,COLBUF_DOUB)
	EQUIVALENCE(COLBUF,COLBUF_A4,COLBUF_A16,
     +              COLBUF_A32,COLBUF_A64)
	INCLUDE 'edibis.fin'

C---- Set up the buffer position
	IF (FORWARDMODE) THEN
	   INCREMENT = 1
	   ROW = CURROW + INCREMENT
	   TOPROW = ROW
	   BUFINC = BUFSIZE
	ELSE 
	   INCREMENT = -1
	   ROW = CURROW + INCREMENT
	   TOPROW = ROW + 1 - BUFSIZE
	   BUFINC = -BUFSIZE
	ENDIF

	OUTOFBOUNDS = .TRUE.
	EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
	
C---- Begin the search loop

	DO WHILE (OUTOFBOUNDS.AND.(.NOT.EOFL))
	
	   SAMEBUF = .TRUE.
	   ROWSNOW = BUFSIZE
	   IF (TOPROW .LT. 1) TOPROW=1
	   IF (TOPROW .GT. CLEN) TOPROW=CLEN
	   POS = ROW+1-TOPROW
	   IF (TOPROW + BUFSIZE-1.GT. CLEN) 
     +              ROWSNOW=CLEN+1-TOPROW

	   IF (COLFORMCODE(CURCOL) .LT. FMT_A4) THEN
	      CALL IBIS_COLUMN_READ(IBIS,COLBUF,
     +                      CURCOL,TOPROW,ROWSNOW,STATUS)
     	      IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,1)
	   ENDIF
	   
	   IF (COLFORMCODE(CURCOL) .EQ. FMT_REAL) THEN
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF(POS).GT.MAXVAL)
		    OUTOFBOUNDS = OUTOFBOUNDS .OR.(COLBUF(POS).LT.MINVAL)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
	      
	   ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_FULL) THEN
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF_FULL(POS).GT.MAXVAL_FULL)
		    OUTOFBOUNDS = OUTOFBOUNDS .OR.
     +			(COLBUF_FULL(POS).LT.MINVAL_FULL)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
	      
	   ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_DOUB) THEN
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF_DOUB(POS).GT.MAXVAL_DOUB)
		    OUTOFBOUNDS = OUTOFBOUNDS .OR.
     +			(COLBUF_DOUB(POS).LT.MINVAL_DOUB)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
	      
	   ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_COMP) THEN
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF_COMP(POS).NE.MINVAL_COMP)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
	      
	   ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A4) THEN
	      CALL IBIS_COLUMN_READ(IBIS,COLBUF_A4,
     +                      CURCOL,TOPROW,ROWSNOW,STATUS)
     	      IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,1)
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF_A4(POS).GT.MAXVAL_A4)
		    OUTOFBOUNDS = OUTOFBOUNDS .OR.
     +			(COLBUF_A4(POS).LT.MINVAL_A4)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
		    
	   ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A16) THEN
	      CALL IBIS_COLUMN_READ(IBIS,COLBUF_A16,
     +                      CURCOL,TOPROW,ROWSNOW,STATUS)
     	      IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,1)
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF_A16(POS).GT.MAXVAL_A16)
		    OUTOFBOUNDS = OUTOFBOUNDS .OR.
     +			(COLBUF_A16(POS).LT.MINVAL_A16)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
		    
	   ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A32) THEN
	      CALL IBIS_COLUMN_READ(IBIS,COLBUF_A32,
     +                      CURCOL,TOPROW,ROWSNOW,STATUS)
     	      IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,1)
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF_A32(POS).GT.MAXVAL_A32)
		    OUTOFBOUNDS = OUTOFBOUNDS .OR.
     +			(COLBUF_A32(POS).LT.MINVAL_A32)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
		    
	   ELSE IF (COLFORMCODE(CURCOL) .EQ. FMT_A64) THEN
	      CALL IBIS_COLUMN_READ(IBIS,COLBUF_A64,
     +                      CURCOL,TOPROW,ROWSNOW,STATUS)
     	      IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBIS,STATUS,1)
	      DO WHILE (OUTOFBOUNDS.AND.SAMEBUF.AND.(.NOT.EOFL))
		    OUTOFBOUNDS = (COLBUF_A64(POS).GT.MAXVAL_A64)
		    OUTOFBOUNDS = OUTOFBOUNDS .OR.
     +			(COLBUF_A64(POS).LT.MINVAL_A64)
		    ROW = ROW + INCREMENT
		    POS = POS + INCREMENT
	   	    EOFL = ((ROW.GT.CLEN).OR.(ROW.LT.1))
		    SAMEBUF = (POS.LE.ROWSNOW).AND.(POS.GE.1)
	      ENDDO
	    ENDIF
	    TOPROW = TOPROW + BUFINC
	ENDDO

	IF (OUTOFBOUNDS) THEN       !YOU HIT THE END OF FILE
		ROWSEARCHVAL = CURROW
	ELSE			    !YOU FOUND SOMETHING !
		ROWSEARCHVAL = ROW - INCREMENT
		EOFL = .FALSE.
	ENDIF
	    
	RETURN
	END



C ***********************************************************
C          INITIALIZATION SUBROUTINES 
C *****************************************************************
	SUBROUTINE GET_INFO_FROM_PARMS
C	 Gets File parameters from PARMS
	IMPLICIT NONE
	INCLUDE 'edibis.fin'
	INTEGER*4	 COUNT

	CALL XVP ('NCOL',    NCOL,        COUNT)
	CALL XVP ('LCOL',    CLEN,        COUNT)
	CALL XVP ('ORG',     FILEORG,     COUNT)
	CALL XVP ('DEFFMT',  DEFLTFMT,    COUNT)
	CALL XVP ('VERSION', FILEVERSION, COUNT)
	CALL XVP ('CFORMAT', COLFILFMT,   COUNT)
	CALL XVP ('HOST',  FHOST,   COUNT)

	RETURN
	END

c*************************************************************************
	SUBROUTINE GET_INFO_FROM_FILE( IBISIN,USE_COL)
C	 Gets File parameters from IBIS file
	IMPLICIT NONE
	INTEGER*4	 STATUS,COUNT,IBISIN,INNCOL
	INTEGER*4	 DCOL, COL
	INTEGER*4  NCOLDEF, COLSDEF,INCLEN
	INTEGER*4  IBIS_FILE_GET
	LOGICAL*4  USE_COL
	INCLUDE 'edibis.fin'

	!Get File attributes
	COUNT=IBIS_FILE_GET(IBISIN, 'NC',NCOL,1,1)
	COUNT=IBIS_FILE_GET(IBISIN, 'NR',CLEN,1,1)
	COUNT=IBIS_FILE_GET(IBISIN, 'ORG',FILEORG,1,1)
	COUNT=IBIS_FILE_GET(IBISIN, 'HOST',FHOST,1,1)
	COUNT=IBIS_FILE_GET(IBISIN, 'FMT_DEFAULT',DEFLTFMT,1,1)
	COUNT=IBIS_FILE_GET(IBISIN, 'VERSION',FILEVERSION,1,1)

	IF (USE_COL) THEN  ! Check Column params
		INNCOL = NCOL
		INCLEN = CLEN
		CALL XVPARM ('NCOL', NCOL, COUNT, NCOLDEF,0)
		CALL XVPARM ('COLS', COLS, DCOL, COLSDEF,0)
		IF (NCOLDEF .EQ. 1 .AND. COLSDEF .EQ. 1)  NCOL = INNCOL
		IF (NCOLDEF .EQ. 1 .AND. COLSDEF .EQ. 0)  NCOL = DCOL
		CALL XVP ('LCOL', CLEN, COUNT)
		CLEN = MAX (CLEN, INCLEN)
	ENDIF

	DO COL=1,NCOL
		IF (.NOT.USE_COL.OR.COLSDEF.EQ.1) COLS(COL) = COL
		CALL IBIS_COLUMN_GET(IBISIN, 'FORMAT',COLFILFMT(COL),
     +					    COLS(COL), STATUS)
	ENDDO

	RETURN
	END
c*************************************************************************
	SUBROUTINE SETUP_COLUMN_TRANS(IBIS)
C	 Sets up the column translation stuff
	IMPLICIT NONE
	INTEGER*4 COUNT,NC,COL,IBIS,IBIS_FILE_GET
	INTEGER*4 STATUS
	LOGICAL*4 IBIS2
	CHARACTER*10 VERS,FMT
	CHARACTER*1 CHR
	INTEGER*4 ASIZE

	COUNT = IBIS_FILE_GET( IBIS, 'VERSION', VERS, 1,1)
	COUNT = IBIS_FILE_GET( IBIS, 'NC', NC, 1,1)
	
	IBIS2 = (VERS(6:6).EQ.'2')
	
	IF (IBIS2) THEN
		DO COL=1,NC

			 ! set up the translation; default if other.
	
			CALL IBIS_COLUMN_GET( IBIS, 'FORMAT', FMT,
     +					COL,STATUS)
     			CHR = FMT(1:1)
			IF (CHR .EQ. 'A') THEN
			   READ(FMT(2:),*) ASIZE
			   IF (ASIZE.LE.4) THEN
			   	CALL IBIS_COLUMN_SET( IBIS,
     +					'U_FORMAT','A4',COL,STATUS)
			   ELSE IF (ASIZE.LE.16) THEN
			   	CALL IBIS_COLUMN_SET( IBIS,
     +					'U_FORMAT','A16',COL,STATUS)
			   ELSE IF (ASIZE.LE.32) THEN
			   	CALL IBIS_COLUMN_SET( IBIS,
     +					'U_FORMAT','A32',COL,STATUS)
			   ELSE
			   	CALL IBIS_COLUMN_SET( IBIS,
     +					'U_FORMAT','A64',COL,STATUS)
			   ENDIF
			ELSE IF (CHR.EQ.'B'.OR.
     +			   CHR.EQ.'H'.OR.CHR.EQ.'F') THEN
			   CALL IBIS_COLUMN_SET( IBIS,
     +					'U_FORMAT','FULL',COL,STATUS)
    			ENDIF

		ENDDO
	ENDIF
	
	RETURN
	END
	
c*************************************************************************
	SUBROUTINE CREATE_IBIS_FILE(NEWUNIT,NEWIBIS)
C	 Creates new IBIS file from info
	IMPLICIT NONE
	INCLUDE 'edibis.fin'
	INTEGER*4	 NEWUNIT,NEWIBIS,STATUS

	CALL IBIS_FILE_UNIT(NEWUNIT,NEWIBIS,'WRITE',
     +                   NCOL, CLEN,COLFILFMT,FILEORG, STATUS)
	IF (STATUS .NE. 1) CALL IBIS_SIGNAL_U(NEWUNIT,STATUS,1)
	CALL IBIS_FILE_SET( NEWIBIS, 'VERSION', FILEVERSION, STATUS )
	IF (STATUS .NE. 1) CALL IBIS_SIGNAL(NEWIBIS,STATUS,1)
	CALL IBIS_FILE_SET( NEWIBIS, 'FMT_DEFAULT', DEFLTFMT,STATUS )
	IF (STATUS .NE. 1) CALL IBIS_SIGNAL(NEWIBIS,STATUS,1)
	CALL IBIS_FILE_SET( NEWIBIS, 'AUTO_INIT', 'OFF',STATUS )
	IF (STATUS .NE. 1) CALL IBIS_SIGNAL(NEWIBIS,STATUS,1)
	CALL IBIS_FILE_UNIT_OPEN(NEWIBIS,STATUS)
	IF (STATUS .NE. 1) CALL IBIS_SIGNAL(NEWIBIS,STATUS,1)

	RETURN
	END


c*************************************************************************
	SUBROUTINE OPEN_IBIS_FILE(UNIT,IBIS,GRDIM,MODE)
C	 Opens existing IBIS file for update
	IMPLICIT NONE
	CHARACTER*(*) MODE
	INTEGER*4	 UNIT,IBIS,STATUS,GRDIM

	CALL IBIS_FILE_OPEN(UNIT,IBIS,MODE, GRDIM,
     +					0,' ',' ', STATUS)
	IF (STATUS .NE. 1) CALL IBIS_SIGNAL_U(UNIT,STATUS,1)

	RETURN
	END

c*************************************************************************
	SUBROUTINE COPY_IBIS_DATA( IBISIN,IBISOUT,USE_COL)
C	 Copies IBISIN data to UNITOUT, then closes UNITOUT
C	 We will use a smart copy, taking organization into account.
	IMPLICIT NONE
	INCLUDE 'edibis.fin'
	INTEGER*4 COL,INNC,INNR,THISROW,IBISIN,COUNT
	INTEGER*4 CBUFSIZE,BYTEBUFSIZE,ROW,SIZE,ROWSNOW,ROWINC,NINC
	INTEGER*4	INCOLS(MAXFILECOLS),OUTCOLS(MAXFILECOLS)
	INTEGER*4 IBIS_FILE_GET,STATUS,IBISOUT,INRECORD,OUTRECORD
	LOGICAL*4 USE_COL
	PARAMETER (CBUFSIZE=1024,BYTEBUFSIZE=CBUFSIZE*8)
	CHARACTER*10 FORG
	REAL*8 DBUFFER(CBUFSIZE)

	COUNT = IBIS_FILE_GET(IBISOUT, 'NC', INNC,1,1)
	COUNT = IBIS_FILE_GET(IBISOUT, 'NR', INNR,1,1)
	COUNT = IBIS_FILE_GET(IBISOUT, 'ORG', FORG,1,1)
	IF (USE_COL) THEN
		DO COL=1,NCOL
			INCOLS(COL)=COLS(COL)
			OUTCOLS(COL)=COL
		ENDDO
	ELSE
		DO COL=1,INNC
			INCOLS(COL)=COL
			OUTCOLS(COL)=COL
		ENDDO
	ENDIF
	
	IF (FORG(1:1).EQ.'R'.OR.FORG(1:1).EQ.'r') THEN
C            Row-Oriented copy; Use Unformatted Records, 
C            as we know both files have the same host.
		CALL IBIS_RECORD_OPEN(IBISIN,INRECORD,' ',
     +              INCOLS,INNC,'NONE',STATUS)
		CALL IBIS_RECORD_OPEN(IBISOUT,OUTRECORD,' ',
     +              OUTCOLS,INNC,'NONE',STATUS)
     		DO ROW=1,INNR
		   CALL IBIS_RECORD_READ(INRECORD,DBUFFER,ROW,STATUS)
		   IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBISIN,STATUS,1)
		   CALL IBIS_RECORD_WRITE(OUTRECORD,DBUFFER,ROW,STATUS)
		   IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBISOUT,STATUS,1)
		ENDDO
	ELSE
C            Column-Oriented copy. We use unformatted columns
C            as we know both files have the same host.
		DO COL=1,INNC
		   CALL IBIS_COLUMN_SET(IBISIN,'U_FORMAT',
     +                                 'NONE',INCOLS(COL),STATUS)
		   CALL IBIS_COLUMN_SET(IBISOUT,'U_FORMAT',
     +                                 'NONE',OUTCOLS(COL),STATUS)
		   CALL IBIS_COLUMN_GET(IBISIN,'U_SIZE',
     +				       SIZE,INCOLS(COL),STATUS)
		   ROWINC = BYTEBUFSIZE/SIZE
		   IF (ROWINC.GT.INNR) ROWINC=INNR
		   NINC = (INNR+ROWINC-1)/ROWINC
		   THISROW=1
		   ROWSNOW=ROWINC
		   DO ROW=1,NINC
		   	IF (ROW.EQ.NINC) ROWSNOW = INNR+1-THISROW
			
		   	CALL IBIS_COLUMN_READ(IBISIN,DBUFFER,
     +                          INCOLS(COL),THISROW,ROWSNOW,STATUS)
		   	IF (STATUS.NE.1) 
     +				CALL IBIS_SIGNAL(IBISIN,STATUS,1)
     
		   	CALL IBIS_COLUMN_WRITE(IBISOUT,DBUFFER,
     +                             OUTCOLS(COL),THISROW,ROWSNOW,STATUS)     
		   	IF (STATUS.NE.1) 
     +				CALL IBIS_SIGNAL(IBISOUT,STATUS,1)
     
     			THISROW = THISROW + ROWINC
		   ENDDO
		ENDDO
	ENDIF

	! Copy the groups over as well
	CALL IBIS_GROUP_TRANSFER(IBISIN,IBISOUT,'ANY',
     +    INCOLS,OUTCOLS,INNC,STATUS)

	RETURN
	END

c*************************************************************************
	SUBROUTINE IBISCOPY( IBISIN,UNITOUT,USE_COL)
C	 Copies IBISIN to UNITOUT, then closes UNITOUT
	IMPLICIT NONE
	LOGICAL*4 USE_COL
	INTEGER*4 STATUS,IBISIN,IBISOUT,UNITOUT
	INCLUDE 'edibis.fin'

	CALL GET_INFO_FROM_FILE(IBISIN, USE_COL)
	CALL CREATE_IBIS_FILE( UNITOUT, IBISOUT )
	CALL COPY_IBIS_DATA( IBISIN, IBISOUT,USE_COL )
	CALL IBIS_FILE_CLOSE( IBISOUT, ' ', STATUS)
	IF (STATUS.NE.1) CALL IBIS_SIGNAL(IBISOUT,STATUS,1)

	RETURN
	END


c*************************************************************************
	SUBROUTINE FILESETUP
C	    Opens the interface file (if specified) and open the 
C	 output interface file (if specified) to edit.
	IMPLICIT NONE
	INCLUDE 'edibis.fin'
	INTEGER*4	STATUS, COUNT, INPDEF, OUTDEF, UNIT1
	INTEGER*4 IBIS1
	CHARACTER*200  INPNAME, OUTNAME
	INTEGER*4 GRDIM
	LOGICAL*4 XVPTST

	READONLY = XVPTST('READONLY')

C			See if there is an input file
	CALL XVPARM ('INP', INPNAME, COUNT, INPDEF,0)
	CALL XVP ('GR1DIM',    GRDIM,    COUNT)
	IF (INPDEF .EQ. 0) THEN
	    CALL XVUNIT(UNIT1,'INP',1,STATUS,' ')
	    CALL OPEN_IBIS_FILE( UNIT1, IBIS1,GRDIM,'READ' )
	ENDIF

C			See if there is an output file
	CALL XVPARM ('OUT', OUTNAME, COUNT, OUTDEF,0)
	IF (OUTDEF .EQ. 0) THEN
	    CALL XVUNIT(UNIT,'OUT',1,STATUS,' ')
	    IF (INPDEF .EQ. 1) THEN
C			If output and no input then just create a file
	    	CALL GET_INFO_FROM_PARMS
		CALL CREATE_IBIS_FILE( UNIT, IBIS )
		CALL IBIS_FILE_CLEAR( IBIS, STATUS )
		IF (STATUS.NE.1) CALL IBIS_SIGNAL( IBIS,STATUS,1)
	    ELSE
C			If output and input then copy desired columns
		CALL IBISCOPY(IBIS1, UNIT, .TRUE.)
		CALL IBIS_FILE_CLOSE( IBIS1, ' ', STATUS)
	    	CALL OPEN_IBIS_FILE( UNIT, IBIS, NCOL,'UPDATE' )
	    ENDIF
	    OUTUNIT = -1  !ie, dont use a temporary file
	    FILENAME = OUTNAME
	ELSE
	    IF (INPDEF .EQ. 1) THEN
	        CALL XVMESSAGE(
     +            ' Must specify input or output file',' ')
		CALL ABEND
	    ELSEIF (READONLY) THEN
		FILENAME = INPNAME
		UNIT = UNIT1
		IBIS = IBIS1
		OUTUNIT=-1
		CALL GET_INFO_FROM_FILE( IBIS,.FALSE.)
	    ELSE   !Create working buffer
		FILENAME = INPNAME
		OUTUNIT = UNIT1
		CALL IBISSCRATCH(UNIT)
		CALL IBISCOPY(IBIS1,UNIT,.FALSE.)
		CALL IBIS_FILE_CLOSE( IBIS1, ' ', STATUS)
	    	CALL OPEN_IBIS_FILE( UNIT, IBIS, NCOL,'UPDATE' )
	    ENDIF
	ENDIF

	
	IF (NCOL .GT. MAXFILECOLS) THEN
	   CALL XVMESSAGE (' Maximum number of columns exceeded.',' ')
	   CALL ABEND
	ENDIF
	RETURN
	END



c*************************************************************************
	SUBROUTINE GET_FMT_FROM_PARMS
C	    Initializes screen formats from parms.
	IMPLICIT NONE
	INTEGER*4	I, COUNT
	INTEGER*4	ASC, FORMCODE, SLEN, XLEN
	CHARACTER*64 STRING
	CHARACTER*1  CHR
	CHARACTER*32  INITFORMAT
	INCLUDE 'edibis.fin'

	CALL XVP ('FORMAT', INITFORMAT, COUNT)

	FORMCODE = 0
	DO I = 1,16		! Find out the data type real, int, or char
	    ASC = ICHAR(INITFORMAT(I:I))
	    IF (ASC .GE. 96)  ASC = ASC - 32
	    CHR = CHAR(ASC)
	    IF (CHR .EQ. 'F' .OR. CHR .EQ. 'E')  FORMCODE = FMT_REAL
	    IF (CHR .EQ. 'I')  FORMCODE = FMT_FULL
	    IF (CHR .EQ. 'A')  FORMCODE = FMT_A4
	ENDDO
	IF (FORMCODE .EQ. FMT_REAL) THEN	! See if legal format and find size
	    WRITE (STRING, INITFORMAT ,ERR=199) 7.0
	ELSE IF (FORMCODE .EQ. FMT_FULL) THEN
	    WRITE (STRING, INITFORMAT ,ERR=199) 7
	ELSE IF (FORMCODE .EQ. FMT_A4) THEN
	    WRITE (STRING, INITFORMAT ,ERR=199) 'XXXX'
	ELSE
	    GOTO 199
	ENDIF
	XLEN = SLEN(STRING)
	GOTO 200

199	CONTINUE		! Here if error in initial format
	INITFORMAT = '(F11.3)'
	XLEN = 11
	FORMCODE = FMT_REAL

200	CONTINUE
	DO I = 1, MAXFILECOLS
	    COLXLEN(I) = XLEN
	    COLFORMAT(I) = INITFORMAT
	    COLFORMCODE(I) = FORMCODE
	ENDDO

	RETURN
	END


c*************************************************************************
	SUBROUTINE GET_FMT_FROM_FILE
C	    Gets formats from IBIS-2 file
	IMPLICIT NONE
	INTEGER*4	I, ASIZE
	INTEGER*4	ASC, FORMCODE, XLEN
	CHARACTER*1  CHR
	CHARACTER*32  INITFORMAT
	INCLUDE 'edibis.fin'

	FORMCODE = 0
	DO I = 1, NCOL
	    ASC = ICHAR(COLFILFMT(I)(1:1))
	    IF (ASC .GE. 96)  ASC = ASC - 32
	    CHR = CHAR(ASC)
	    
	    IF (CHR .EQ. 'A') THEN
	    	READ(COLFILFMT(I)(2:),*)ASIZE
		IF (ASIZE.LE.4) THEN
		   INITFORMAT = '(2X,A4)'
		   FORMCODE=FMT_A4
		   XLEN=6
		ELSEIF (ASIZE.LE.16) THEN
		   INITFORMAT = '(X,A16)'
		   FORMCODE=FMT_A16
		   XLEN=17
		ELSE IF (ASIZE.LE.32) THEN
		   INITFORMAT = '(X,A32)'
		   FORMCODE=FMT_A32
		   XLEN=33
		ELSE
		   INITFORMAT = '(X,A64)'
		   FORMCODE=FMT_A64
		   XLEN=65
		ENDIF
	    ELSEIF (CHR .EQ. 'B') THEN
		INITFORMAT = '(I8.3)'
	    	FORMCODE = FMT_FULL
		XLEN=8
	    ELSEIF ( CHR .EQ. 'H') THEN
		INITFORMAT = '(I8.5)'
	    	FORMCODE = FMT_FULL
		XLEN=8
	    ELSEIF ( CHR .EQ. 'F')  THEN
		INITFORMAT = '(I12.10)'
	    	FORMCODE = FMT_FULL
		XLEN=12
	    ELSEIF ( CHR .EQ. 'D')  THEN
	    	FORMCODE = FMT_DOUB
		INITFORMAT = '(F11.3)'
		XLEN=11
	    ELSEIF ( CHR .EQ. 'C')  THEN
	    	FORMCODE = FMT_COMP
		INITFORMAT = '(X,''('',F8.3,'','',F8.3,'')'')'
		XLEN=20
	    ELSE
	    	FORMCODE = FMT_REAL
		INITFORMAT = '(F11.3)'
		XLEN=11
	    ENDIF
	    COLXLEN(I) = XLEN
	    COLFORMAT(I) = INITFORMAT
	    COLFORMCODE(I) = FORMCODE
	ENDDO

	RETURN
	END

c*************************************************************************
	SUBROUTINE INITIALIZE
C	    Initializes variables and sets up the screen.
	IMPLICIT NONE
	INTEGER*4 COUNT
	CHARACTER*10 XCMD
	INCLUDE 'edibis.fin'

	CALL XVPCNT ('COMMANDS', NUM_CMD)
	CALL XVPONE ('COMMANDS', XCMD,1,0)
	BATCH_MODE = (XCMD(1:1) .NE. ' ')
	IF (BATCH_MODE .AND. READONLY) THEN
		CALL XVMESSAGE('Cant batch-edit in READONLY mode!',' ')
		CALL ABEND
	ENDIF

	CALL SETUP_COLUMN_TRANS(IBIS)
	IF (FILEVERSION(6:6).EQ.'2') THEN
		CALL GET_FMT_FROM_FILE
	ELSE
		CALL GET_FMT_FROM_PARMS
	ENDIF

	CALL XVP ('SCRNSIZE', SCREENXSIZE, COUNT)
	
	IF (BATCH_MODE) THEN
		CUR_CMD = 1
		FIRSTYPOS = 1
		LASTYPOS = 1
		NUMDISPROWS = 1
		NUMDISPCOLS = 1
	
		FIRSTBUFROW = 1
		FIRSTBUFCOL = 1
	
		FORWARDMODE = .TRUE.
		HIGHLEN = 0
		
		DISPROW = 1
		DISPCOL = 1
		CURROW = 1
		CURCOL = 1
		RETURN
	ENDIF
	
	FIRSTYPOS = 5
	LASTYPOS = 22
	NUMDISPROWS = MAXROWS
	NUMDISPROWS = MIN (NUMDISPROWS, CLEN)
	NUMDISPCOLS = 8
	NUMDISPCOLS = MIN (NUMDISPCOLS, NCOL)

	FIRSTBUFROW = 1
	FIRSTBUFCOL = 1

	FORWARDMODE = .TRUE.
	HIGHLEN = 0
	
	DISPROW = 1
	DISPCOL = 1
	CURROW = 1
	CURCOL = 1

	CALL INITSCREEN
	CALL SETUPCOLDISPLAY
	CALL NEWSCREEN

	RETURN
	END

c*************************************************************************
	SUBROUTINE SETUPCOLDISPLAY
C	    Sets up the screen X positions for each display column
C	 based on the display lengths of the columns.  Also calculates
C	 the number of columns to display on the screen.
	IMPLICIT NONE
	INTEGER*4	COL, NUM
	LOGICAL*4 INBOUNDS
	INCLUDE 'edibis.fin'

	COLXPOS(DISPCOL) = 1
	COL = DISPCOL
	NUM = 1
	INBOUNDS=.TRUE.
	DO WHILE (INBOUNDS .AND. COL .LT. NCOL)
	    COLXPOS(COL+1) = COLXPOS(COL) + COLXLEN(COL)
	    COL = COL + 1
	    INBOUNDS = COLXPOS(COL)+COLXLEN(COL) .LE. SCREENXSIZE
	    IF (INBOUNDS) NUM = NUM + 1
	ENDDO
	IF (NUM .LT. NUMDISPCOLS) THEN
	    DO COL = DISPCOL+NUM, DISPCOL+NUMDISPCOLS-1
		CALL WRITEBUFCOL (COL)
	    ENDDO
	ELSE IF (NUM .GT. NUMDISPCOLS) THEN
	    DO COL = DISPCOL+NUMDISPCOLS, DISPCOL+NUM-1
		CALL READBUFCOL (COL)
	    ENDDO
	ENDIF
	NUMDISPCOLS = NUM

	RETURN
	END




C *****************************************************************
C          SCREEN DISPLAY SUBROUTINES 
C *****************************************************************


	SUBROUTINE DISPLAYSCREEN
C	    Displays all of the rows of data on the screen
	IMPLICIT NONE
	INTEGER*4	ROW, YPOS
	INCLUDE 'edibis.fin'

	YPOS = FIRSTYPOS
	DO ROW = DISPROW, DISPROW+MAXROWS-1
	    CALL DISPLAYROW (ROW, YPOS)
	    YPOS = YPOS + 1
	ENDDO
	HIGHLEN = 0
	
	CALL SHOW_DATA

	! Clear to end of Display Deleted
	
	RETURN
	END

c*************************************************************************
	SUBROUTINE FORMATELEMENT(OUTSTRING,ROW,COL,LEN)
	IMPLICIT NONE
	CHARACTER*(*) OUTSTRING
	INTEGER*4 COL,ROW,INCOL, I, ASC,LEN,LIMIT
	INCLUDE 'edibis.fin'

	INCOL = COL + 1 - FIRSTBUFCOL
	
	IF (COLFORMCODE(COL) .EQ. FMT_REAL) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF(ROW,INCOL)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_FULL) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF_FULL(ROW,INCOL)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_DOUB) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF_DOUB(ROW,INCOL)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_COMP) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF_COMP(ROW,INCOL)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A4) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF_A4(ROW,INCOL)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A16) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF_A16(ROW,INCOL)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A32) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF_A32(ROW,INCOL)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A64) THEN
	   WRITE (OUTSTRING, COLFORMAT(COL),
     +                      ERR=199) IBISBUF_A64(ROW,INCOL)
	ENDIF
199	CONTINUE

	IF (COLFORMCODE(COL) .GE. FMT_A4) THEN
		LIMIT=33  ! Turn spaces to "."
	ELSE
		LIMIT=32  ! Leave spaces blank
	ENDIF
		
	DO I = 1, LEN
	   ASC = ICHAR(OUTSTRING(I:I))
	   IF (ASC .LT. LIMIT .OR. ASC .GE. 127)  
     +			OUTSTRING(I:I) = '.'
	ENDDO
	
	RETURN
	END
	
	
c*************************************************************************
	SUBROUTINE DISPLAYROW (ROW, YPOS)
C	    Displays a particular row of data at a specified Y position
C	 on the screen
	IMPLICIT NONE
	INTEGER*4	ROW, YPOS, COL, PTR, X, X2, LEN
	CHARACTER*200  STRING
	INCLUDE 'edibis.fin'

	X2 = 0
	CALL BLANKSTRING (STRING)
	PTR = ROW - FIRSTBUFROW + 1
	
	IF (ROW - DISPROW .LT. NUMDISPROWS) THEN
	  DO COL = DISPCOL, DISPCOL+NUMDISPCOLS-1
	    X = COLXPOS(COL)
	    LEN = COLXLEN(COL)
	    X2 = X + LEN - 1
	    CALL FORMATELEMENT(STRING(X:X2),PTR,COL,LEN)
	  ENDDO
	ENDIF

	CALL GOTOPOSITION(YPOS,1)
	CALL ERASELINE
	CALL GOTOPOSITION(YPOS,1)
	CALL SCREEN_WRITE(STRING(1:X2))

	RETURN
	END


c*************************************************************************
	SUBROUTINE DISPLAYHEADER
C	    Displays the file info line, the current row and column line,
C	 and the format line.
	IMPLICIT NONE
	INTEGER*4	SLEN
	INCLUDE 'edibis.fin'

	CALL GOTOPOSITION(1,1)
	CALL ERASELINE
	WRITE (OUTPUTSTRING,1) 'File: ',
     +                   FILENAME(1:SLEN(FILENAME)), 
     +			'     Columns: ',NCOL, '    Rows: ',CLEN, 
     +			'     Version: ',FILEVERSION
1	FORMAT (A,A,A,I5,A,I6,A,A)
	CALL SCREEN_WRITE(OUTPUTSTRING)

	CALL GOTOPOSITION(2,1)
	CALL ERASELINE
	WRITE (OUTPUTSTRING,2) 'Row: ',CURROW,'   Column: ', CURCOL
2	FORMAT(A5,I6,A11,I5)
	CALL SCREEN_WRITE(OUTPUTSTRING)

	CALL SHOW_HEADER

	CALL DISPLAYFORMATS

	RETURN
	END

c*************************************************************************
	SUBROUTINE MAKENUMSTRING(STRING,NUM)
C	    Converts Positive NUM to left-justified STRING
	IMPLICIT NONE
	INTEGER*4 I,NUM
	CHARACTER*(*) STRING
	CHARACTER*5 NUMSTR
	
	WRITE (NUMSTR,'(I5)') NUM
	I=1
	DO WHILE (NUMSTR(I:I).EQ.' '.AND.I.LT.5)
		I=I+1
	ENDDO
	READ (NUMSTR(I:),*) STRING

	RETURN
	END

c*************************************************************************
	SUBROUTINE DISPLAYFORMATS
C	    Displays the line showing the formats for all of the columns.
C	 Also displays the line showing the column numbers.
	IMPLICIT NONE
	INTEGER*4	COL, X, L, X2, XC, SLEN
	LOGICAL*4 IBIS2
	CHARACTER*150  CSTRING, FSTRING
	INCLUDE 'edibis.fin'

	X2 = 0
	IBIS2 = FILEVERSION(6:6).EQ.'2'
	CALL BLANKSTRING (CSTRING)
	CALL BLANKSTRING (FSTRING)
	DO COL = DISPCOL, DISPCOL+NUMDISPCOLS-1
	    X = COLXPOS(COL)
	    L = COLXLEN(COL)
	    XC = X + L - 1    ! Used to be X + L/2
	    X2 = X + L - 1
	    WRITE (CSTRING(XC-4:XC), '(I5)') COL
	    IF (IBIS2) THEN
	       X = X2 - SLEN(COLFILFMT(COL)) + 1
	       L = X2 - X + 1
	       FSTRING(X:X2) = COLFILFMT(COL)(1:L)
	      ! WRITE (FSTRING(X:X2), *, ERR=199) COLFILFMT(COL)(1:L)
	    ELSE
	       X = X2 - SLEN(COLFORMAT(COL)) + 1
	       L = X2 - X + 1
	       FSTRING(X:X2) = COLFORMAT(COL)(1:L)
	       ! WRITE (FSTRING(X:X2), *, ERR=199) COLFORMAT(COL)(1:L)
	    ENDIF
	    CONTINUE
	ENDDO
	
	CALL GOTOPOSITION(3,1)
	CALL ERASELINE
	CALL GOTOPOSITION(3,1)
	CALL SCREEN_WRITE(CSTRING(1:X2))

	CALL GOTOPOSITION(4,1)	
	CALL ERASELINE
	CALL GOTOPOSITION(4,1)	
	CALL SCREEN_WRITE(FSTRING(1:X2))
	
	CALL SHOW_FORMATS
	
	RETURN
	END



c*************************************************************************
	SUBROUTINE DEHIGHLIGHT
C	    Takes the last highlighted cell (if there is one)
C	 out of reverse video.  If HIGHLEN = 0 then no cell is currently
C	 highlighted.
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	IF (HIGHLEN .GT. 0) THEN
	    CALL GOTOPOSITION(HIGHY,HIGHX)
	    CALL SCREEN_WRITE(HIGHSTRING(1:HIGHLEN))
	    HIGHLEN = 0
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE HIGHLIGHT
C	    Takes the last highlighted cell out of reverse video
C	 and puts the new highlighted cell in reverse video.
	IMPLICIT NONE
	INTEGER*4	PTR
	INCLUDE 'edibis.fin'

	CALL DEHIGHLIGHT

        PTR = CURROW - FIRSTBUFROW + 1
        HIGHX = COLXPOS(CURCOL)
        HIGHY = FIRSTYPOS + CURROW - DISPROW
        HIGHLEN = COLXLEN(CURCOL)

	CALL FORMATELEMENT(HIGHSTRING(1:HIGHLEN),PTR,CURCOL,HIGHLEN)
	CALL HIGH_WRITE(HIGHY,HIGHX,HIGHSTRING(1:HIGHLEN))

	RETURN
	END

c*************************************************************************
	SUBROUTINE BLANKSTRING (STRING)
	IMPLICIT NONE
	CHARACTER*(*) STRING
	INTEGER*4	I

	DO I = 1, LEN(STRING)
	    STRING(I:I) = ' '
	ENDDO

	RETURN
	END
	
c*************************************************************************
	INTEGER*4 FUNCTION SLEN(STRING)
	IMPLICIT NONE
	INTEGER*4	I
	CHARACTER*(*) STRING

	I = LEN(STRING)
	DO WHILE (ICHAR(STRING(I:I)) .EQ. 32 .AND. I .GT. 1)
	    I = I - 1
	ENDDO
	SLEN = I
	RETURN
	END


c*************************************************************************
	SUBROUTINE UPDATEROWDISPLAY
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	WRITE (OUTPUTSTRING,'(I6)') CURROW
	CALL ROWNUM_WRITE( OUTPUTSTRING(1:6) )
	CALL SHOW_ROWNUM

	RETURN
	END

c*************************************************************************
	SUBROUTINE UPDATECOLDISPLAY
	IMPLICIT NONE
	INCLUDE 'edibis.fin'

	WRITE (OUTPUTSTRING,'(I5)') CURCOL
	CALL COLNUM_WRITE( OUTPUTSTRING(1:5) )
	CALL SHOW_COLNUM

	RETURN
	END



C *****************************************************************
C          FILE BUFFER SUBROUTINES 
C *****************************************************************

	SUBROUTINE FILLBUFFER
	IMPLICIT NONE
	INTEGER*4	COL
	INCLUDE 'edibis.fin'

	DO COL = DISPCOL, DISPCOL+NUMDISPCOLS-1
	    CALL READBUFCOL (COL)
	ENDDO

	RETURN
	END

c*************************************************************************
	SUBROUTINE OUTPUTBUFFER
	IMPLICIT NONE
	INTEGER*4	COL
	INCLUDE 'edibis.fin'

	IF (READONLY) RETURN
	DO COL = DISPCOL, DISPCOL+NUMDISPCOLS-1
	    CALL WRITEBUFCOL (COL)
	ENDDO

	RETURN
	END


c*************************************************************************
	SUBROUTINE CHECKBUFPOS (ROW)
C	    Checks to see if ROW is now in buffer.  If not then the
C	 buffer is written out, and the appropriate blocks read in.
	IMPLICIT NONE
	INTEGER*4	ROW

	INCLUDE 'edibis.fin'

	IF (ROW .LT. FIRSTBUFROW .OR. 
     +		ROW+NUMDISPROWS .GT. FIRSTBUFROW+255) THEN

     	    CALL OUTPUTBUFFER
	    FIRSTBUFROW = 128*((ROW-64)/128) + 1
	    FIRSTBUFROW = MIN (FIRSTBUFROW, 128*((CLEN-129)/128)+1)
	    FIRSTBUFROW = MAX (FIRSTBUFROW, 1)
	    CALL FILLBUFFER

	ENDIF

	RETURN
	END
c*************************************************************************
	SUBROUTINE SETDISPCOL (COL)
C	    Checks to see if COL is now in scroll buffer.  If not then
C	 the buffer is written out, and the appropriate blocks read in.
	IMPLICIT NONE
	LOGICAL*4 OUTOFBOUNDS
	INTEGER*4	 COL, INC

	INCLUDE 'edibis.fin'

	OUTOFBOUNDS = (COL .LT. FIRSTBUFCOL .OR. 
     +		  COL+NUMDISPCOLS .GT. FIRSTBUFCOL+MAXBUFCOLS)
     
        IF (OUTOFBOUNDS) CALL OUTPUTBUFFER
	DISPCOL = COL
	IF (OUTOFBOUNDS) THEN
	    INC = MAXBUFCOLS/2
	    FIRSTBUFCOL = INC*((COL-1)/INC) + 1
	    FIRSTBUFCOL = MIN (FIRSTBUFCOL, INC*((NCOL-INC)/INC)+1)
	    FIRSTBUFCOL = MAX (FIRSTBUFCOL, 1)
	    CALL FILLBUFFER
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE WRITEBUFCOL (COL)
C	    Writes one column of the buffer (two blocks) out to the file
C	    if the column has been changed.  A valid FIRSTBUFROW and
C	    FIRSTBUFCOL is required.
	IMPLICIT NONE
	INTEGER*4	STATUS,NROWS,COL,OUTCOL
	INCLUDE 'edibis.fin'

	IF (READONLY) RETURN

	NROWS = MAXBUFROWS
	IF (FIRSTBUFROW + NROWS -1 .GT. CLEN) 
     +       NROWS = CLEN + 1 - FIRSTBUFROW
   
	IF (COLCHANGED(COL)) THEN
	    OUTCOL = COL + 1 - FIRSTBUFCOL

	    IF (COLFORMCODE(COL) .EQ. FMT_REAL) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ELSE IF (COLFORMCODE(COL) .EQ. FMT_FULL) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF_FULL(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ELSE IF (COLFORMCODE(COL) .EQ. FMT_DOUB) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF_DOUB(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ELSE IF (COLFORMCODE(COL) .EQ. FMT_COMP) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF_COMP(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ELSE IF (COLFORMCODE(COL) .EQ. FMT_A4) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF_A4(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ELSE IF (COLFORMCODE(COL) .EQ. FMT_A16) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF_A16(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ELSE IF (COLFORMCODE(COL) .EQ. FMT_A32) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF_A32(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ELSE IF (COLFORMCODE(COL) .EQ. FMT_A64) THEN
	    	CALL IBIS_COLUMN_WRITE(IBIS,
     +             IBISBUF_A64(1,OUTCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	    ENDIF
	    IF (STATUS .NE. 1) THEN
		CALL NEWSCREEN
		CALL ENDSCREEN
		CALL IBIS_SIGNAL(IBIS,STATUS,1)
	    ENDIF
	ENDIF

	RETURN
	END

c*************************************************************************
	SUBROUTINE READBUFCOL (COL)
C	    Read two blocks from the file to fill one column of the buffer.
C	 A valid FIRSTBUFROW is required.
	IMPLICIT NONE
	INTEGER*4	COL,INCOL, STATUS,NROWS
	INCLUDE 'edibis.fin'


	! Need to allow for ASCII columns
	NROWS = MAXBUFROWS
	IF (FIRSTBUFROW + NROWS -1 .GT. CLEN) 
     +       NROWS = CLEN + 1 - FIRSTBUFROW
	INCOL = COL + 1 - FIRSTBUFCOL


	IF (COLFORMCODE(COL) .EQ. FMT_REAL) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_FULL) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF_FULL(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_DOUB) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF_DOUB(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_COMP) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF_COMP(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A4) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF_A4(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A16) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF_A16(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A32) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF_A32(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ELSE IF (COLFORMCODE(COL) .EQ. FMT_A64) THEN
	    	CALL IBIS_COLUMN_READ(IBIS,
     +             IBISBUF_A64(1,INCOL),COL,FIRSTBUFROW,NROWS,STATUS)
	ENDIF

	IF (STATUS .NE. 1) THEN
		CALL NEWSCREEN
		CALL ENDSCREEN
		CALL IBIS_SIGNAL(IBIS,STATUS,1)
	ENDIF
	COLCHANGED(COL) = .FALSE.

	RETURN
	END



C *****************************************************************
C          KEYBOARD INPUT AND PARSING SUBROUTINES 
C *****************************************************************

	SUBROUTINE GETCOMMAND (COMMAND, ARGSTRING, ARGLEN)
C	    This subroutine returns the next command, either
C           from the keypad, command-line or parms if batch-mode.
	IMPLICIT NONE
	INTEGER*4	COMMAND, ARGLEN
	CHARACTER*(*)	ARGSTRING
	INCLUDE 'edibis.fin'

	! Get the command and handle error messages
c	print *,"MODE = BATCHMODE = ",BATCH_MODE
	IF (BATCH_MODE) THEN
		CALL GET_COMMAND_FROM_PARM(COMMAND,ARGSTRING,ARGLEN)
	ELSE
		CALL DISPLAY_PROMPT('] ')
		CALL GET_COMMAND_FROM_KEYBOARD(COMMAND,ARGSTRING,ARGLEN)
	ENDIF
	RETURN
	END
c*************************************************************************
	SUBROUTINE GET_COMMAND_FROM_PARM (COMMAND, ARGSTRING, ARGLEN)
C	    This subroutine gets the commands from the COMMANDS parm
	IMPLICIT NONE
	INTEGER*4	COMMAND, ARGLEN
	CHARACTER*(*)	ARGSTRING
	CHARACTER*200 CMDLINE
	INCLUDE 'edibis.fin'

345     CONTINUE
c	print *,"COMMAND, CUR_CMD and NUM_CMD = ",COMMAND,CUR_CMD,NUM_CMD
	IF (CUR_CMD .GT. NUM_CMD) THEN
		COMMAND = ENDEDIT		!automatically terminate when end of commands
		RETURN
	ENDIF

	CALL XVPONE ('COMMANDS', CMDLINE,CUR_CMD,0)
	CUR_CMD = CUR_CMD + 1
c	print *, "CMDLINE = ",CMDLINE
	CALL CONVERT_STRING_TO_COMMAND (CMDLINE,COMMAND, 
     +                    ARGSTRING, ARGLEN)
c	print *,"COMMAND, ARGSTRING, ARGLEN = ",COMMAND, ARGSTRING, ARGLEN 
	IF (COMMAND.EQ.BADCOMMAND) THEN
		CALL XVMESSAGE(ARGSTRING,' ')
		GOTO 345
	ENDIF

	RETURN
	END
c*************************************************************************
	SUBROUTINE CONVERT_STRING_TO_COMMAND (CMDLINE, COMMAND, 
     +                     ARGSTRING, ARGLEN)
C	    This subroutine converts a command
	IMPLICIT NONE
	INTEGER*4	COMMAND, ARGLEN, ARGPOS, CMDPOS
	INTEGER*4	SLEN,STAT,LN, THISROW,THISCOL
	CHARACTER*(*)	ARGSTRING,CMDLINE
	CHARACTER*200 XCMDSTR
	CHARACTER*3 XCOM
	INCLUDE 'edibis.fin'
c
c	8-14-2011 - RJB - had to add new call CALL FIND_ROWCOL
c	THISROW and THISCOL are found from list directed read
c	in gcc 4.4.4:
c      READ (CMDLINE(CMDPOS:),*,ERR=332) THISCOL i
c	does not detect properly the trailing ")" as a terminator
C	It gives an error, where the older compiler evidently 
c	recognized ) as a proper terminator
c
C   -- skip spaces
	CMDPOS=1
	LN = SLEN(CMDLINE)
c	print *,"LN = ",LN
        DO WHILE (CMDLINE(CMDPOS:CMDPOS).EQ.' '.AND.CMDPOS.LE.LN)
		CMDPOS = CMDPOS+1
	ENDDO
	IF (CMDPOS.GT.LN) CMDPOS=1
C   -- check to see if there is a (row,column) position prefix
	IF (CMDLINE(CMDPOS:CMDPOS).EQ.'(') THEN
c	  print *, "found ("

c get row and column
	   CALL FIND_ROWCOL(CMDLINE,CMDPOS,LN,THISROW,THISCOL)

	   IF (CMDPOS.GT.LN) GOTO 345  !Error	GOTO 345
	   IF (THISCOL.GT.0) CALL DO_GOTOCOL (THISCOL)
	   IF (THISROW.GT.0) CALL DO_GOTOROW (THISROW)
	   IF (CMDPOS.EQ.LN) RETURN
	   CMDPOS = CMDPOS+1
	   DO WHILE (CMDLINE(CMDPOS:CMDPOS).EQ.' '.AND.CMDPOS.LE.LN)
	      CMDPOS = CMDPOS+1
	   ENDDO
	ENDIF			!
	XCMDSTR = CMDLINE(CMDPOS:)

C   -- Find the beginning of the argument following command
	ARGPOS=1
	LN = SLEN(XCMDSTR)
	DO WHILE (XCMDSTR(ARGPOS:ARGPOS).NE.' ' .AND. ARGPOS.LE.LN)
	    ARGPOS = ARGPOS+1
	ENDDO
	DO WHILE (XCMDSTR(ARGPOS:ARGPOS).EQ.' '.AND. ARGPOS.LE.LN)
	    ARGPOS = ARGPOS+1
	ENDDO

	ARGLEN = LN+1-ARGPOS
	IF (ARGPOS .LE. LN) ARGSTRING = XCMDSTR(ARGPOS:)

C   -- Parse the command
	XCOM = XCMDSTR(1:3)
	CALL CCASE(XCOM,1,3) !Convert to uppercase
	IF (XCOM.EQ.'ROW') THEN
		COMMAND=GOTOROW
	ELSEIF (XCOM.EQ.'COL') THEN
		COMMAND=GOTOCOL
	ELSEIF (XCOM.EQ.'FOR') THEN
		COMMAND=CHNGFORMAT
	ELSEIF (XCOM.EQ.'DEL') THEN
		COMMAND=DELETEROW
	ELSEIF (XCOM.EQ.'INS') THEN
		COMMAND=INSERTROW
	ELSEIF (XCOM.EQ.'CUT') THEN
		COMMAND=ZEROCELL
	ELSEIF (XCOM.EQ.'FWD') THEN
		FORWARDMODE = .TRUE.
		ARGSTRING=' '
		COMMAND=TEXTSTRING
	ELSEIF (XCOM.EQ.'BAC') THEN
		FORWARDMODE = .FALSE.
		ARGSTRING=' '
		COMMAND=TEXTSTRING
	ELSEIF (XCOM.EQ.'JUM') THEN !already jumped
		ARGSTRING=' '
		COMMAND=TEXTSTRING
	ELSEIF (XCOM.EQ.'PAS') THEN
		COMMAND=RECALLCELL
	ELSEIF (XCOM.EQ.'SET') THEN
		COMMAND=SETTEXTVAL
	ELSEIF (XCOM.EQ.'EXI') THEN
		COMMAND=ENDEDIT
	ELSEIF (XCOM.EQ.'TOP') THEN
		COMMAND=FILETOP
	ELSEIF (XCOM.EQ.'BOT') THEN
		COMMAND=FILEBOTTOM
	ELSEIF (XCOM.EQ.'LEF') THEN
		COMMAND = PAGELEFT
	ELSEIF (XCOM.EQ.'RIG') THEN
		COMMAND = PAGERIGHT
	ELSEIF (XCOM.EQ.'SEA') THEN
		IF (ARGLEN .GT. 0) 
     +             CALL SET_SEARCH_STRING(ARGSTRING,ARGLEN,STAT)
		IF (.NOT.INITSET) THEN
		  ARGSTRING = 'NO SEARCH STRING SPECIFIED'
	          COMMAND=BADCOMMAND
	          RETURN
		ENDIF
		COMMAND=SEARCH
	ELSE
		GOTO 345
	ENDIF

	RETURN

 345    ARGSTRING = 'Unknown Command:'//CMDLINE

	COMMAND=BADCOMMAND
	if (BATCH_MODE) then
	     call xvmessage (ARGSTRING,' ')
	     call xvmessage ('??E - BATCH_MODE abend',' ')
	    call abend 
	endif
	RETURN
	END
c*************************************************************************
	SUBROUTINE FIND_ROWCOL(CMDLINE,CMDPOS,LN,THISROW,THISCOL)
c
c	This subroutine parses out the row and column from commands
c	such as "(1,2) SET 9.123". In the original code (1,2) was
c	extracted from the command line through 
c
c
        IMPLICIT NONE
        INTEGER*4  i,cmdlen,LN,CMDPOS,THISROW,THISCOL
        CHARACTER*(*)   CMDLINE
        CHARACTER*200 cmdshort

	   cmdshort(1:200) = ' '
           i = 0
           do WHILE (CMDLINE(CMDPOS:CMDPOS).NE.')' .AND. CMDPOS.LE.LN)
                i= i + 1
                cmdshort(i:i) = CMDLINE(CMDPOS:CMDPOS)
                CMDPOS = CMDPOS+1
           enddo
           cmdlen = i
           cmdshort(i+1:i+1) = ','
           i = 1
c          print *,"CMDshort(i+1:) = ",CMDshort(i+1:)
           READ (CMDshort(i+1:),*, ERR=330) THISROW                 !ERR=345
c           print *,"THISROW = ",THISROW
           DO WHILE (CMDshort(i:i).NE.',' .AND. i.LE.cmdlen)
                i = i + 1
           ENDDO
c           print *,"CMDshort(i+1:) = ",CMDshort(i+1:)
           READ (CMDshort(i+1:),*,ERR=332) THISCOL        ! ERR=332               !ERR=345 - 3rd error
c            print *,"THISCOL = ",THISCOL

	RETURN
 330    continue
	call xvmessage ("??E - Error reading row in (row,col)"," ")
	call abend
 332    continue
	call xvmessage ("??E - Error reading column in (row,col)"," ")
        call abend 
        return



	END
c*************************************************************************
	SUBROUTINE GET_COMMAND_FROM_KEYBOARD (COMMAND, 
     +                                   ARGSTRING, ARGLEN)
C	    This subroutine translates keys hit into editting commands without
C	 prompt. Normal keys are built up into a text string (ARGSTRING) to
C	 return.  Keypad keys are translated. If the "/ command" form is used
C        command names are translated.
	IMPLICIT NONE
	INTEGER*4	COMMAND, ARGLEN
	CHARACTER*(*)	ARGSTRING
	CHARACTER*200 CMDLINE
	INTEGER*4	POS, KEY, LN
	LOGICAL*4	PF1MODE
	INCLUDE 'edibis.fin'

	LN = LEN(ARGSTRING)
	POS = 0
	CALL BLANKSTRING (ARGSTRING)

	PF1MODE = .FALSE.
	COMMAND = NONE
	DO WHILE (COMMAND .EQ. NONE)
	    CALL KEYINPUT (KEY)

C			Build up the text string
	    IF (KEY .GE. 32) THEN
		IF (KEY .EQ. 127 .AND. POS .GT. 0) THEN !Backspace
		    CALL DELETE_CHAR
		    ARGSTRING(POS:POS) = ' '
		    POS = POS - 1
		ELSE IF (KEY.NE.127 .AND. POS .LT. LN) THEN
		    CALL SHOW_CHAR( KEY )
		    POS = POS + 1
		    ARGSTRING(POS:POS) = CHAR(KEY)
		ENDIF
	    ELSE IF (KEY .EQ. 13) THEN		! Carriage return ends string
		COMMAND = TEXTSTRING
	    ELSE IF (KEY .EQ. 26) THEN		! Control Z ends edit
		COMMAND = ENDEDIT
	    ELSE IF (KEY .EQ. 18) THEN		! Control R refeshes screen
		COMMAND = REFRESH
	    ELSE IF (KEY .EQ. 6) THEN		! Control F for changing formats

		COMMAND = CHNGFORMAT
	    ELSE IF (KEY .EQ. 4) THEN		! Control D to quit
		COMMAND = QUIT

C			Process keys that are independent of PF1 mode
	    ELSE IF (KEY .EQ. -1) THEN
		COMMAND = UPARROW
	    ELSE IF (KEY .EQ. -2) THEN
		COMMAND = DOWNARROW
	    ELSE IF (KEY .EQ. -3) THEN
		COMMAND = RIGHTARROW
	    ELSE IF (KEY .EQ. -4) THEN
		COMMAND = LEFTARROW
	    ELSE IF (KEY .EQ. -6) THEN
		COMMAND = HELP
	    ELSE IF (KEY .EQ. -5) THEN ! toggle PF1MODE
		PF1MODE = .NOT.PF1MODE

C			Process PF1 mode commands
	    ELSE IF (PF1MODE) THEN
		IF (KEY .EQ. -14) THEN
		    COMMAND = FILEBOTTOM
		ELSE IF (KEY .EQ. -15) THEN
		    COMMAND = FILETOP
	        ELSE IF (KEY .EQ. -9) THEN
		    COMMAND = GOTOCOL
		ELSE IF (KEY .EQ. -8) THEN
		    COMMAND = INSERTROW
		ELSE IF (KEY .EQ. -7) THEN
		    COMMAND = INITSEARCH
		ELSE IF (KEY .EQ. -21) THEN
		    COMMAND = RECALLCELL
		ENDIF

C			Process non PF1 mode commands
	    ELSE IF (.NOT. PF1MODE) THEN
		IF (KEY .EQ. -14) THEN
		    FORWARDMODE = .TRUE.
		ELSE IF (KEY .EQ. -15) THEN
		    FORWARDMODE = .FALSE.
		ELSE IF (KEY .EQ. -8) THEN
		    COMMAND = DELETEROW
	        ELSE IF (KEY .EQ. -9) THEN
		    COMMAND = GOTOROW
		ELSE IF (KEY .EQ. -7) THEN
		    COMMAND = SEARCH
		ELSE IF (KEY .EQ. -21) THEN
		    COMMAND = ZEROCELL

		ELSE IF (FORWARDMODE) THEN	! Process forward mode commands
		    IF (KEY .EQ. -18) THEN
			COMMAND = PAGEDOWN
		    ELSE IF (KEY .EQ. -12) THEN
			COMMAND = PAGERIGHT
		    ELSE IF (KEY .EQ. -17) THEN
			COMMAND = FILEBOTTOM
		    ENDIF
					! Process backward mode commands

		ELSE IF (.NOT. FORWARDMODE) THEN 
		    IF (KEY .EQ. -18) THEN
			COMMAND = PAGEUP
		    ELSE IF (KEY .EQ. -12) THEN
			COMMAND = PAGELEFT
		    ELSE IF (KEY .EQ. -17) THEN
			COMMAND = FILETOP
		    ENDIF
		ENDIF
	   ENDIF
	ENDDO

	CALL ERASELINE

	ARGLEN = POS

	! Trap the special '/ command' option
	IF (COMMAND.EQ.TEXTSTRING .AND. ARGSTRING(1:1).EQ.'/') THEN
	 	CMDLINE = ARGSTRING(2:)
		CALL CONVERT_STRING_TO_COMMAND (CMDLINE, COMMAND, 
     +                             ARGSTRING, ARGLEN)		
		IF (COMMAND.EQ.BADCOMMAND) THEN
	     	   CALL EMIT_BEEP
		   CALL DISPLAY_STATUS(ARGSTRING)
		ENDIF
	ENDIF

	RETURN
	END


c*************************************************************************
	SUBROUTINE KEYINPUT (KEY)
C	    Returns a integer value for a keyboard input.
C	 The ascii value is returned for ascii values 1 thru 127 
C	 (i.e. normal and control characters).
C	 VT100 keypad mode keys return the following codes:
C	 Up arrow = -1   Down arrow = -2   Right arrow = -3   Left arrow = -4
C	 PF1 = -5    PF2 = -6   PF3 = -7   PF4 = -8    Enter = -9
C	 Keypad 0 thru Keypad 9  = -10 thru -19
C	 Keypad , = -20.   Keypad - = -21.   Keypad . = -21.
C	 Zero is returned for all other keys
C	 CSI (<esc> [) sequences are eaten correctly and return 0
	IMPLICIT NONE
	INTEGER*4	 CH
	INTEGER*4 GET_CHAR
	INTEGER*4 KEY

	KEY = 0
	CH = GET_CHAR(.TRUE.)

	IF (CH .EQ. 27) THEN  !ESCAPE FOUND
	    CH = GET_CHAR(.TRUE.)
	    IF (CH .EQ. 91) THEN   ! '[' FOUND
		CH = GET_CHAR(.TRUE.)
		! between A and D
		IF (CH .GE. 65 .AND. CH .LE. 68) THEN
		    KEY = -(CH - 64)
		ELSE        ! STOP IF CH = '^' OR '~' (on WYSE TERMINALS)
		    DO WHILE ((CH .NE. 94).AND.(CH.NE.126))
			CH = GET_CHAR(.TRUE.)
		    ENDDO
		ENDIF
	    ELSE IF (CH .EQ. 79) THEN  ! 'O' FOUND
		CH = GET_CHAR(.TRUE.)
		IF (CH .GE. 65 .AND. CH .LE. 68) THEN
		    KEY = -(CH - 64)
		ELSE IF (CH .GE. 80 .AND. CH .LE. 83) THEN
		    KEY = -(CH - 75)
		ELSE IF (CH .EQ. 77) THEN
		    KEY = -9
		ELSE IF (CH .GE. 112 .AND. CH .LE. 121) THEN
		    KEY = -(CH - 102)
		ELSE IF (CH .GE. 108 .AND. CH .LE. 110) THEN
		    KEY = -(CH - 88)
		ENDIF
	    ENDIF
	ELSE IF (CH .GE. 1 .AND. CH .LE. 127) THEN
	    KEY = CH
	ENDIF

	RETURN
	END

