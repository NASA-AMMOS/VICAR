procedure
refgbl $echo
refgbl $autousage
body
  local i integer
  local vals integer count=1:10
  local val integer
  local formats (string,20) count=1:10
  local format string
  local formats2 (string,20) count=1:10
  local format2 string
  local oformats (string,20) count=1:10
  local oformat string

let _onfail="continue"
let $autousage="none"
let $echo="yes"

! THIS IS A TEST SCRIPT FOR THE PROGRAM F2

GEN F1 NL=5 NS=20 'FULL
GEN F2 NL=5,NS=20 'FULL LINC=3 SINC=3
LIST F1 'FULL
LIST F2 'FULL
! INTEGER*4 TEST CASE
F2 INP=(F1,F2) OUT=X FUNCTION="IN1+SQRT(IN2)"
LIST X
GEN R NL=5 NS=20 'REAL4
GEN S NL=5,NS=20 'REAL4 LINC=1.5 SINC=1.5
LIST R
LIST S
! REAL*4 TEST CASE
F2 INP=(R,S) OUT=X FUNCTION="IN1+SQRT(IN2)"
LIST X
GEN B NL=10 NS=10
GEN G NL=10 NS=10 IVAL=125
GEN H NL=10 NS=20 'HALF
GEN L1 LINC=1. SINC=0. NL=10 NS=10
GEN L2 LINC=0. SINC=1. NL=10 NS=10
LIST B
LIST H
LIST L1
LIST L2
! BASIC TEST CASES
F2 INP=B OUT=X FUNCTION="IN1+1"
LIST X
F2 INP=B OUT=X FUNCTION="INT(IN1/10)"
LIST X 'ZERO
F2 INP=B OUT=X2 FUNCTION="IN1/10" 'TRUNC
DIFPIC (X,X2)
! BASIC TEST CASE WITH BYTE VALUES > 127
F2 INP=G OUT=X FUNCTION="IN1+1"
LIST X
! BASIC TEST CASE WITH WINDOW
F2 INP=B OUT=X FUNCTION="IN1+1" SIZE=(2,3,6,4)
LIST X
! NEXT TWO EXECUTIONS TEST THE TRUNC KEYWORD.  SEE VALUE 5 IN LOWER RIGHT
! CORNER CHANGE TO 6.
F2 B X FUNC="SQRT(IN1**1.1234+7)"
LIST X
F2 B X FUNC="SQRT(IN1**1.1234+7)"   'TRUNC
LIST X

! HALFWORD CASE
F2 INP=H OUT=X  FUNCTION="IN1+1" 
LIST X
! HALFWORD CASE WITH WINDOW
F2 INP=H OUT=X  FUNCTION="IN1+1"  SIZE=(2,5,6,8)
LIST X

! LOGICAL CASES
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1.AND.IN2"
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1.OR.IN2"
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1.XOR.IN2"
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1.LT.IN2"
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1.EQ.IN2"
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION=".NOT.(IN1.GE.IN2)"
LIST X

! C-Language Constructs -- Also checks 'DUMP keyword
F2 INP=L1 OUT=X  FUNCTION="!IN1" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1 && IN2" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1 &&&& IN2" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1 ^ IN2" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1 | IN2" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1<<IN2" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1 <= IN2" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1 % IN2" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="IN1 > IN2" 'DUMP
LIST X

! SPECIAL FUNCTIONS
COPY L2 L3
F2 INP=(L1,L2) OUT=X  FUNCTION="MOD(IN2,IN1)" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="MIN(IN1,IN2)" 'DUMP
LIST X
F2 INP=(L1,L2,L3) OUT=X  FUNCTION="MIN(IN1,IN2,IN3)" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  FUNCTION="MAX(IN1,IN2)" 'DUMP
LIST X
F2 INP=(L1,L2) OUT=X  +
 FUNCTION="100.*SIN(IN1/10.)+100.*COS(IN2/10)" 'DUMP
LIST X

! NO INPUT TEST CASE (IMAGE GENERATION)
F2 OUT=X  FUNCTION="LINE+SAMP"  SIZE=(1,1,10,10)
LIST X
!
! THIS IS A LARGE (90000 PIXEL) CASE WITH VARIOUS INPUTS.  THE TABLE LOOKUP
! METHOD IS USED.  THE TERMINAL MESSAGES
!       "FUNCTION EVALUATED 65536 TIMES"
!       "FUNCTION EVALUATED N TIMES"  (255<N<65536)
!       "FUNCTION EVALUATED 180000 TIMES"
! SHOULD APPEAR.  IN1 WAS MADE DIFFERENT THAN IN2 TO CHECK FOR POSSIBLE
! MIXUP OF INPUTS.
LET I=1
LET FORMATS=("BYTE","HALF","REAL4","END")
LOOP
    LET FORMAT=FORMATS(I)
    IF (FORMAT="END") BREAK

    GEN  A NL=300 NS=300 '&FORMAT
    GEN  B NL=300 NS=600 '&FORMAT
    F2 INP=(A,B) OUT=X FUNCTION="IN1+SQRT(IN2)"
    LIST X,NL=10,NS=10

    LET i=i+1
END-LOOP

! MIXED FORMATS FOR BOTH INPUT AND OUTPUT
LET I=1
LET FORMATS =("BYTE","HALF","BYTE","HALF", "FULL", "FULL","BYTE", "END")
LET FORMATS2=("HALF","BYTE","HALF","BYTE", "REAL4","HALF","REAL4","END")
LET OFORMATS=("BYTE","BYTE","FULL","REAL","BYTE", "BYTE","FULL", "END")
LOOP
    LET FORMAT=FORMATS(I)
    IF (FORMAT="END") BREAK

    LET FORMAT2=FORMATS2(I)
    LET OFORMAT=OFORMATS(I)
    GEN  A NL=10 NS=10 '&FORMAT
    GEN  B NL=10 NS=10 '&FORMAT2
    F2 INP=(A,B) OUT=X FUNCTION="IN1+IN2" '&OFORMAT
    LIST X

    LET i=i+1
END-LOOP


GEN A 10 10 'BYTE
GEN B 10 10 'HALF LINC=2 SINC=2
GEN C 10 10 'FULL LINC=3 SINC=3
GEN D 10 10 'REAL4 LINC=4 SINC=4
! MULTIPLE INPUT CASE
! THE ONE'S PLACE WILL INCREMENT BY 1'S, THE 100'S PLACE BY 2'S
! THE 10000'S PLACE BY 3'S, AND THE 1000000'S PLACE BY 4'S
F2 (A,B,C,D) X FUNC="IN1+100*IN2+10000*IN3+1000000*IN4" 'FULL
LIST X
! TEST OF FUNCTION STRING EXTENSION AND BAD FUNCTION STRINGS
GEN F1 10 10 IVAL=0 SINC=0 LINC=0 
GEN F2 10 10 IVAL=1 SINC=0 LINC=0 
F2 INP=(F1,F2) OUT=X FUNCTION=+
"(IN1+IN2)+(IN1+IN2)+(IN1+IN2)+(IN1+IN2)+(IN1+IN2)+(IN1+IN2)+(IN1+IN2)++
 (IN1+IN2)+(IN1+IN2)+(IN1+IN2)+(IN1+IN2)+(IN1+IN2)"
LIST X
! -- These next two tests are omitted, because the new versions of
!    knuth, xknuth can make sense of them (they DO make sense,after all).
!write "The following execution of F2 should result in a BAD FUNCTION"
!write "message and an F2 abend."
!F2 INP=(F1,F2) OUT=X FUNCTION="IN1.EQ.-IN2"
!F2 INP=(F1,F2) OUT=X FUNCTION="IN1.EQ.(-IN2)"
!LIST X
!


! THIS IS A TEST OF THE MAX NUMBER OF INPUTS
LET I=1
LET FORMATS =("BYTE", "HALF", "FULL", "REAL", "END")
LOOP
    LET FORMAT=FORMATS(I)
    IF (FORMAT="END") BREAK

    GEN B1 NL=10 NS=10 '&FORMAT
    COPY B1 B2
    COPY B1 B3
    COPY B1 B4
    COPY B1 B5
    COPY B1 B6
    COPY B1 B7
    COPY B1 B8
    COPY B1 B9
    COPY B1 B10
    COPY B1 B11
    COPY B1 B12
    COPY B1 B13
    COPY B1 B14
    COPY B1 B15
    COPY B1 B16
    COPY B1 B17
    COPY B1 B18
    F2 (B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15,B16,B17,B18) B '&FORMAT +
      FUNC="MIN(IN1,IN2,IN3,IN4,IN5,IN6,IN7,IN8,IN9,IN10,IN11,IN12,IN13,IN14,IN15,IN16,IN17,IN18)"
    WRITE "SHOULD GET 0 DIFFERENCES."
    DIFPIC (B,B1)
    F2 (B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15,B16,B17,B18) B '&FORMAT +
      FUNC="MAX(IN1,IN2,IN3,IN4,IN5,IN6,IN7,IN8,IN9,IN10,IN11,IN12,IN13,IN14,IN15,IN16,IN17,IN18)"
    WRITE "SHOULD GET 0 DIFFERENCES."
    DIFPIC (B,B1)

    LET i=i+1
END-LOOP

! THIS IS A TEST OF THE MAX LINE SIZE FOR F2
LET I=1
LET FORMATS =( "BYTE", "HALF", "FULL", "REAL", "END")
LET FORMATS2 =("BYTE", "HALF", "HALF", "HALF", "END")
LET VALS=(      64000,  32000,  16000,  16000,  0)
LOOP
    LET FORMAT=FORMATS(I)
    IF (FORMAT="END") BREAK

    LET FORMAT2=FORMATS2(I)
    LET VAL=VALS(I)
    GEN B0 NL=10 NS=&VAL '&FORMAT2
    GEN B1 NL=10 NS=&VAL '&FORMAT
    COPY B1 B2
    F2 (B1,B2) B '&FORMAT2  FUNC="MIN(IN1,IN2)"
    WRITE "SHOULD GET 0 DIFFERENCES."
    DIFPIC (B,B0)
    F2 (B1,B2) B '&FORMAT2 FUNC="MAX(IN1,IN2)"
    WRITE "SHOULD GET 0 DIFFERENCES."
    DIFPIC (B,B0)

    LET i=i+1
END-LOOP

!
! test various mathematical and trigonometric identities
!
gen a 10 10 'real4 ival=-9.0
list a
!
f2 a b func="sqrt(in1)"
list b
f2 b c func="in1*in1"
write "Should get c = abs(a)."
list c
!
f2 a b func="sin(in1)*sin(in1) + cos(in1)*cos(in1)"
write "Should get b = 1.0."
list b
!
f2 a b func="10**(in1)"
list b
f2 b c func="log10(in1)"
write "Should get c = max( -6, a)."
list c
!
f2 a b func="atan2(in1,1.0)"
write "Should get 0.0 and pi/4 = .78..."
list b (2,9,1,2)
f2 b c func="tan(in1)"
write "Should get c = a."
list c
!
f2 a b func="atan(in1)"
write "Should get 0.0 and pi/4 = .78..."
list b (2,9,1,2)
f2 b c func="tan(in1)"
write "Should get c = a."
list c
!
f2 a b func="tan(atan2(in1,in1))"
write "Should get b = 0 on diagonal from (10,1) to (1,10) and b=1 elsewhere."
list b

!!!!!!!!!!!
! TEST OF EXCLUDE, LIMITS AND REPLACE PARAMETERS
GEN A 10 10 IVAL=10 SINC=0 LINC=1
GEN B 10 10 'HALF IVAL=-32768 SINC=0 LINC=5000
GEN C 10 10 'FULL IVAL=432768 SINC=0 LINC=1
GEN D 10 10 'REAL IVAL=5432768 SINC=0 LINC=1
F2 INP=A OUT=X EXCLUDE=(13,14,18) FUNCTION="IN1+100"
LIST X
F2 INP=A OUT=X EXCLUDE=(13,14,18) FUNCTION="IN1+100" REPLACE=99
LIST X
F2 INP=A OUT=X EXCLUDE=(13,14,18) FUNCTION="IN1+100" REPLACE=280
LIST X
F2 INP=A OUT=X EXCLUDE=(13,14,18) FUNCTION="IN1+100" REPLACE=-280
LIST X
F2 INP=A OUT=X LIMITS=(5,18) FUNCTION="IN1+100" 
LIST X
F2 INP=A OUT=X LIMITS=(5,18) FUNCTION="IN1+100" REPLACE=99
LIST X
F2 INP=A OUT=X LIMITS=(5,18) FUNCTION="IN1+100" REPLACE=280
LIST X
F2 INP=A OUT=X LIMITS=(5,18) FUNCTION="IN1+100" REPLACE=-280
LIST X
F2 INP=B OUT=X EXCLUDE=-22768 FUNCTION="IN1+1000"
LIST X
F2 INP=B OUT=X EXCLUDE=-22768 REPLACE=99
LIST X
F2 INP=B OUT=X EXCLUDE=-27768 REPLACE=40000
LIST X
F2 INP=B OUT=X EXCLUDE=-27768 REPLACE=-40000
LIST X
F2 INP=B OUT=X LIMITS=(-50000, 0) 
LIST X
F2 INP=B OUT=X LIMITS=(-50000, 0) REPLACE=99
LIST X
F2 INP=B OUT=X LIMITS=(-30000, 0) REPLACE=40000
LIST X
F2 INP=B OUT=X LIMITS=(-30000, 0) REPLACE=-40000
LIST X
F2 INP=C OUT=X FUNCTION="IN1+1000" EXCLUDE=(432768,432775) 
LIST X
F2 INP=C OUT=X EXCLUDE=(432768,432775) REPLACE=99
LIST X
F2 INP=C OUT=X LIMITS=(432770,432775) 
LIST X
F2 INP=C OUT=X LIMITS=(432770,432775) REPLACE=99
LIST X
F2 INP=D OUT=X EXCLUDE=(5432770,5432775) FUNCTION="IN1+100000"
LIST X
F2 INP=D OUT=X EXCLUDE=(5432770,5432775) REPLACE=99
LIST X
F2 INP=D OUT=X LIMITS=(5432770,5432775) 
LIST X
F2 INP=D OUT=X LIMITS=(5432770,5432775) REPLACE=99
LIST X
F2 INP=(C,D) OUT=X EXCLUDE=(5432768,432768,432769) FUNCTION="IN1+IN2" +
 REPLACE=4040
LIST X
GEN A 10 10 IVAL=0 SINC=0 LINC=1
GEN B 10 10 IVAL=0 SINC=1 LINC=0
GEN C 10 10 IVAL=10 SINC=0 LINC=0
LIST A
LIST B
LIST C
F2 INP=(A,B,C) OUT=X EXCLUDE=(3,4,8) FUNCTION="IN1+IN2+IN3"
LIST X
F2 INP=(A,B,C) OUT=X EXCLUDE=(3,4,8) FUNCTION="IN1+IN2+IN3" REPLACE=99
LIST X
F2 INP=(A,B,C) OUT=X EXCLUDE=(3,4,8) FUNCTION="IN1+IN2+IN3" REPLACE=280
LIST X
F2 INP=(A,B,C) OUT=X EXCLUDE=(3,4,8) FUNCTION="IN1+IN2+IN3" REPLACE=-280
LIST X
F2 INP=(A,B,C) OUT=X LIMITS=(3,10) FUNCTION="IN1+IN2+IN3"
LIST X
F2 INP=(A,B,C) OUT=X LIMITS=(3,10) FUNCTION="IN1+IN2+IN3" REPLACE=99
LIST X
F2 INP=(A,B,C) OUT=X LIMITS=(3,10) FUNCTION="IN1+IN2+IN3" REPLACE=280
LIST X
F2 INP=(A,B,C) OUT=X LIMITS=(3,10) FUNCTION="IN1+IN2+IN3" REPLACE=-280
LIST X

! Test floating point error (FR#75716)
f2 out=a nl=5 ns=5 fun="-1.7e38*(line<3)+2" 'real
f2 out=b nl=5 ns=5 fun="-1.7e38*(line<3)+1" 'real
list a
list b
f2 (a,b) c fun="in1-in2" exclude=-1.7e38 replace=-1.7e38
list c

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
write "Test F2 on multiband images"
gen a 5 10 12 ORG="BSQ" 'BYTE   LINC=2 SINC=3 BINC=4 IVAL=5
f2 OUT=b nl=5 ns=10 nb=12 ORG="BSQ" 'BYTE   +
   FUNC="2*(LINE-1) + 3*(SAMP-1) + 4*(BINC-1) + 5"
write "Should get 0 differences."
difpic (a b)
!
gen a 5 10 12 ORG="BIL" 'HALF   LINC=2 SINC=3 BINC=4 IVAL=5
f2 OUT=b nl=5 ns=10 nb=12 ORG="BIL" 'HALF   +
   FUNC="2*(LINE-1) + 3*(SAMP-1) + 4*(BINC-1) + 5"
write "Should get 0 differences."
difpic (a b) 
!
gen a 5 10 12 ORG="BIP" 'REAL   LINC=2 SINC=3 BINC=4 IVAL=5
f2 OUT=b nl=5 ns=10 nb=12 ORG="BIP" 'REAL   +
   FUNC="2*(LINE-1) + 3*(SAMP-1) + 4*(BINC-1) + 5"
write "Should get 0 differences."
difpic (a b) 
!
gen a 5 10 12 ORG="BSQ" 'BYTE   
copy a b size=(2 3 4 5) bands=(5 4)
f2   a c size=(2 3 4 5) bands=(5 4) func="IN1"
write "Should get 0 differences."
difpic (b c)
!
gen a 5 10 12 ORG="BIL" 'half
copy a b size=(2 3 4 5) bands=(5 4)
f2   a c size=(2 3 4 5) bands=(5 4) func="IN1"
write "Should get 0 differences."
difpic (b c)
!
! save a for next test, below
copy a a1
!
gen a 5 10 12 ORG="BIP" 'REAL4   
copy a b size=(2 3 4 5) bands=(5 4)
f2   a c size=(2 3 4 5) bands=(5 4) func="IN1"
write "Should get 0 differences."
difpic (b c)
!
! test check on ORG:
f2 (a a1) b func="in1+in2"
write "should get abend"
!
GEN A 10 10 2 'BYTE BINC=0
GEN B 10 10 2 'HALF LINC=2 SINC=2 BINC=0
GEN C 10 10 2 'FULL LINC=3 SINC=3 BINC=0
GEN D 10 10 2 'REAL4 LINC=4 SINC=4 BINC=0
LIST A
LIST B
LIST C
LIST D
F2 (A,B,C,D) X FUNC="IN1+100*IN2+10000*IN3+1000000*IN4" 'FULL SB=1 NB=1
LIST X
F2 (A,B,C,D) X FUNC="IN1+100*IN2+10000*IN3+1000000*IN4" 'FULL +
	SIZE=(5,5,5,5) SB=1 NB=1
LIST X
GEN JFM 10 10 10 IVAL=0 SINC=0 LINC=0
GEN JSM 10 10 10 IVAL=10 SINC=0 LINC=0
F2 INP=(JSM,JFM) OUT=X FUNCTION="IN1+IN2"
LIST X
F2 INP=(JSM,JFM) OUT=X FUNCTION="IN1+IN2" SIZE=(5,5,5,5)
LIST X
F2 INP=(JSM,JFM) OUT=X FUNCTION="IN1+IN2" SB=1 NB=3
LIST X
F2 INP=(JSM,JFM) OUT=X FUNCTION="IN1+IN2" SB=1 NB=3 SIZE=(5,5,5,5)
LIST X
F2 OUT=X FUNCTION="LINE+SAMP+BAND" SIZE=(1,1,10,10) NB=10
LIST X
F2 OUT=X  FUNCTION="MOD(SAMP,LINE)"   'HALF  SIZE=(1,1,10,20)
LIST X

! Test Correct SL, SS handling FR#81717
! This should start out with first value 33, not 11.
GEN X nl=10 ns=10
F2 X Y (3,3,5,5) FUN="LINE*10+SAMP"
LIST Y

! tests for AR-112949:

! test for case with EXCLUDE and float output type:
gen a 100 100 sinc=2
f2 a a1 'real func="0.9*in1"
f2 a a2 'real func="0.9*in1" excl=0.0
f2 (a1 a2) d fun="in1-in2"
hist d 'nohis

! test for problem with numbers < 1.0e-6 (actually in KNUTH):
gen tiny.img 6 6 'real ival=1.0e-8 sinc=1.0e-9 linc=1.0e-9
list tiny.img
f2 tiny.img logtiny.img func="alog10(in1)"
list logtiny.img

! tests for DAR of July 2011:
f2 (/project/test_work/testdata/sitod1/test_data/gll/s0412460345.sos +
 /project/test_work/testdata/sitod1/test_data/gll/0345.sos) +
 d fun="in1-in2"
hist d 'nohis

! repeat with EXCLUDE param ...
f2 (/project/test_work/testdata/sitod1/test_data/gll/s0412460345.sos +
 /project/test_work/testdata/sitod1/test_data/gll/0345.sos) +
 d fun="in1-in2" excl=0.0
hist d 'nohis

gen x1 nl=10 ns=10 'half

! test 247 char function"

F2 INP=(x1) OUT=x2 FUNCTION="IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1"

list x2

! test 991 char function+fu2+fu3+fu4"

F2 INP=(x1) OUT=x2 FUNCTION="IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1" +
  FU2="+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1" +
  FU3="+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1" +
  FU4="+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1+IN1"

list x2

End-proc
