      INCLUDE 'VICMAIN_FOR'
C
C**********************************************************************
C
      SUBROUTINE MAIN44

C-----PROGRAM SARGON

C  27-MAR-2018  ...WLB...  Fixed big/little endian bug (introduced in 1984?).
C  12-APR-96  ...OAM...  Modified sargon.imake to run on Unix.  Fix bugs 
C                        on variables HBL HBH MAXDN, and MINDN. FR 8902.
C  10-DEC-93  ...DDK...  Made application portable to UNIX.
C  13-JUL-92  ...FFM...  Modidifed routine OPRATE to handle DN outside of
C                        proper range 
C  14-APR-89  ...TCG...  Trap more bad inputs (no int params) which cause
C			 problems with all the rest of the commands.
C			 Add XVEACTION call and remove all XVCHECKs.
C  14-FEB-89  ...TCG...  Trap bad input (constants = 0.0) which cause 
C                        problems with divide but shouldn't be allowed for
C                        ADD, SUB, or MUL either.  Fixed bug in SORTX.
C                        Fixed bug in STRETCH when no params are input.
C  29-SEP-87  ...SP....  ADDED CHECK FOR VALID COMMAND AFTER HALFWORD DATA
C                        RANGE IS ENTERED.  ADDED READONLY PARAMETER IN
C                        OPEN STATEMENT IN SUBROUTINE IDIPARM TO KEEP
C                        UP TO DATE WITH VERSION OF IDIPARM IN IDX.  NOTE THAT
C                        THIS IS THE CLASSIC PROBLEM OF HOW IT IS DIFFICULT
C                        TO KEEP MORE THAN ONE COPY OF A PIECE OF CODE AND
C                        KEEP ALL VERSIONS UPDATED.
C  31-JAN-86  ...HBD...  FIXED BUGS, ADDED STATS/PCUR/RCUR/CIRC KEYWORDS
C  12-JUL-85  ...JHR...  CONVERTED TO VICAR2
C  11-MAY-84  ...CCA...  CONVERTED TO VAX
C   1-MAR-82  ...CCA...  NEW PROGRAM

C-----THIS PROGRAM IS AN INTERACTIVE AREA ALTERING PROGRAM
C-----IT WILL APPLY A SPECIFIED FUNCTION TO THE POLYGONAL
C-----AREA DEFINED BY CURSOR SELECTED VERTICIES.
C-------------------------------------------------------------------
C-----FUNC = 0       INTERPOLATE
C-----       1       MULTIPLY
C-----       2       ADD
C-----       3       SUBTRACT
C-----       4       DIVIDE
C-----       5       SET TO DN
C-----       6       ZERO OUT
C-----       7       CALC. MEAN AND STANDARD DEVIATION, MIN & MAX DN
C-----       8       COPY INPUT
C--------------------------------------------------------------------
C      IMPLICIT INTEGER (A-Z)
      IMPLICIT NONE

      INCLUDE 'fortport'
      COMMON/C/IUNIT,OUNIT,ICOD,HBL,HBH,FUNC,RADI
      COMMON /D/ NL,NS,NLDS,NSDS
      COMMON /E/ PTBUF,SEGM,SORT
      COMMON /F/ LBUF,DBUG,NVERT,MINDN,MAXDN,PERC
      COMMON /G/ SL, SS
      COMMON /H/ DUNIT

      INTEGER OUNIT
      LOGICAL*1 LBUF(20000)
      CHARACTER*200 MSG
      INTEGER RAW(256),OFF(256),STR(256)
      REAL V(2,26)
      INTEGER SL,SS
      INTEGER*2 PTBUF(3,4000),SEGM(3,2000),SORT(2,4000)

      REAL    RARG(2),SLOPE,OFST,CONST
      INTEGER IARG(2),STAT,CMODE,SECTION
      INTEGER X(20001),Y(2001),L,S,XDSGRAPH,XDGCOLOR
      INTEGER XDIMFILL,XDCLOCATION,XDIPOLYLINE,XDLWRITE,XDGLINIT
      CHARACTER*8 FORMT
      BYTE BDN,BIDN,BMDN 

      INTEGER*4 ATDL,ATDS,DBUG,DN,DUNIT,FUNC,HBH,HBL,HI,I,ICNT
      INTEGER*4 ICOD,ICONST,IDEF,IDL,IDN,IDS,IEDEF,IERR,II,IPL
      INTEGER*4 IPS,IR,IRAD,IRDEF,IUNIT,LIN1,LINNL,LL,LO,LS
      INTEGER*4 MAXDN,MAXL,MAXS,MAXSL,MAXSS,MDN,MINDN,NL,NLDS
      INTEGER*4 NLI,NPTS,NS,NSDS,NSEG,NSI,NSL,NSS,NVERT,PERC
      INTEGER*4 PLANE,RADI,REDISP,SAM1,SAMNS,SLDS,SSDS,VERFLG
      INTEGER*4 XDCSET

C      EQUIVALENCE (IPARM,RPARM)

      CALL XVMESSAGE('*** SARGON version 2018-03-27 ***',' ')
C
C        SET DEFAULTS AND INITIALIZE
C
      MINDN = -9999
      MAXDN = 32768
      FUNC = 0
      DBUG = 0
      PERC = 100
      RADI = 1000000
      REDISP = 0
      HBL = 0
      HBH = 255
      CMODE = 0
      SL = 1
      SS = 1
      SLDS = 1
      SSDS = 1
      ATDL = 0
      ATDS = 0
      DO I=1,256
         RAW(I) = I - 1
         STR(I) = RAW(I)
         OFF(I) = 0
      END DO
C
	CALL XVEACTION( 'SA', ' ' )
C
C          OPEN INPUT DATA SET
      CALL XVUNIT(IUNIT,'INP',1,STAT,' ')
      CALL XVOPEN(IUNIT,STAT,' ')
C
C        GET SIZE INFORMATION AND DATA FORMAT AND CHECK
      CALL XVGET(IUNIT,STAT,'NL',NLI,'NS',NSI,'FORMAT',FORMT,' ')
      IF(FORMT.NE.'BYTE'.AND.FORMT.NE.'HALF') THEN
         CALL XVMESSAGE('SARGON ACCEPTS BYTE AND HALFWORD DATA ONLY',
     .			' ')
         CALL ABEND
      END IF
      IF(NSI.GT.10000) THEN
         CALL XVMESSAGE(' INPUT SAMPLE SIZE EXCEEDS BUFFER SIZE',' ')
         CALL ABEND
      END IF
C
C        OPEN OUTPUT DATA SET
      CALL XVUNIT(OUNIT,'OUT',1,STAT,' ')
      CALL XVOPEN(OUNIT,STAT,'OP','WRITE','U_NL',NLI,'U_NS',NSI,' ')
C
      NL=NLI
      NS=NSI
      ICOD=1
      IF(FORMT.EQ.'HALF') ICOD=2
      LIN1 = 1
      LINNL = NL
      SAM1 = 1
      SAMNS = NS
      CALL XVMESSAGE(' COPYING INPUT TO OUTPUT',' ')
C
C	QPRINT(..,24)
C
      DO I=1,NL
         CALL XVREAD(IUNIT,LBUF,STAT,'LINE',I,' ')
         CALL XVWRIT(OUNIT,LBUF,STAT,'LINE',I,' ')
      END DO
C
C        RE-OPEN OUTPUT FOR UPDATE
C
      CALL XVCLOSE(OUNIT,STAT,' ')
      CALL XVOPEN(OUNIT,STAT,'OP','UPDATE',' ')
C
C        OPEN AND INITIALIZE DISPLAY DEVICE
C
      CALL OPEN_DEVICE( DUNIT )
      CALL CONFIGURE_DEVICE( MAXL, MAXS, DUNIT )
      CALL BW_MODE(DUNIT)
      CALL AUTOTRACKING_MODE(.TRUE.,DUNIT)
      NSDS = 512
      NLDS = 512
      MAXSL = NL - NLDS + 1
      IF(NL .LT. NLDS) MAXSL = 1
      MAXSS = NS - NSDS + 1
      IF(NS .LT. NSDS) MAXSS = 1

C
C        INITIAL DISPLAY
C
5     IF(FORMT.EQ.'HALF') THEN
         CALL XVMESSAGE(' HALFWORD DATA, GIVE INTEGER DN RANGE',' ')
         CALL XVINTRACT('IPARAM','(USE KEYWORD RANGE)')
         CALL XVIPARM('RANGE',IARG,ICNT, IRDEF,2)
         CALL XVIPARM('EXIT',IARG,ICNT, IEDEF,0)
         IF    ( IRDEF.EQ.0 )  THEN 
            HBL = IARG(1)
            HBH = IARG(2)
            IF ((HBL.EQ.538976288) .OR. (HBH.EQ.538976288)) THEN
  	      CALL XVMESSAGE(' CHECK RANGE INPUTS',' ')
	      CALL XVMESSAGE(' TWO INTEGERS REQUIRED',' ')
	      GO TO 5
            END IF

         ELSE IF ( IEDEF.EQ.0 )  THEN
            GO TO 900

         ELSE
            CALL XVMESSAGE(' INVALID COMMAND:',' ')
	    CALL XVMESSAGE('	 TYPE "EXIT" TO EXIT SARGON',' ')
            CALL XVMESSAGE('     OR ENTER RANGE FOR',' ')
            GO TO 5
         END IF
      END IF
      PLANE = XDSGRAPH(DUNIT)

      CALL DSPLY(SL,SS)

C        PARAMETER PROCESSOR
24    CALL XVINTRACT('IPARAM','SARGON READY')

      VERFLG = 0
C
C        'RANGE'
C
10    CALL XVIPARM('RANGE',IARG,ICNT,IDEF,2)
      IF ( IDEF.EQ.0) THEN
        HBL = IARG(1)
        HBH = IARG(2)
        IF ((HBL.EQ.538976288) .OR. (HBH.EQ.538976288)) then
          CALL XVMESSAGE(' CHECK RANGE INPUTS',' ')
	  CALL XVMESSAGE(' TWO INTEGERS REQUIRED',' ')
        END IF
        REDISP = 1
      ENDIF
C
C        'FIT' 
C
      CALL XVIPARM('FIT',IARG,ICNT,IDEF,2)
      IF (IDEF.EQ.0) THEN
        HBL = IARG(1)
        HBH = IARG(2)
        IF ((HBL.EQ.538976288) .OR. (HBH.EQ.538976288)) then
          CALL XVMESSAGE(' CHECK RANGE INPUTS',' ')
	  CALL XVMESSAGE(' TWO INTEGERS REQUIRED',' ')
        END IF
        REDISP = 1
      ENDIF
C
C        'MIN'
C
      CALL XVIPARM('MIN',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        MINDN = IARG(1)
        IF (MINDN .eq. 538976288) THEN
	  CALL XVMESSAGE(' INTEGER MINIMUM DN VALUE REQUIRED ',' ')
	  MINDN = -9999
        END IF
      END IF
C
C        'MAX'
C
      CALL XVIPARM('MAX',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        MAXDN = IARG(1)
        IF (MAXDN .eq. 538976288) then
	  CALL XVMESSAGE(' INTEGER MAXIMUM DN VALUE REQUIRED ',' ')
	  MAXDN = 32768
        END IF 
      END IF
C
C        'HELP'
C
      CALL XVIPARM('HELP',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) CALL HELP
C
C        'PERC'
C
      CALL XVIPARM('PERC',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        PERC = IARG(1)
        IF ((PERC .LT. 0).or.(PERC .GT. 100)) THEN 
     	  CALL XVMESSAGE (' PERCENTAGE >0 and <= 100 REQUIRED',' ')
	  CALL XVMESSAGE (' PERCENTAGE SET TO 100',' ')
	  PERC = 100
        END IF
      END IF 
C
C        'RADIUS'
C
      CALL XVIPARM('RADIUS',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IR = IARG(1)
        IF (IR .EQ. 538976288) then
	  CALL XVMESSAGE(' INTEGER RADIUS VALUE REQUIRED',' ')
	  CALL XVMESSAGE(' RADIUS SET TO DEFAULT 1000000',' ')
          RADI = 1000000
        ELSE 
          RADI = IR * IR
        END IF
      END IF
C
C        'END'
C
      CALL XVIPARM('END',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) GO TO 900
C
C        'EXIT'
C
      CALL XVIPARM('EXIT',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) GO TO 900
C
C        'HOME'
C
      CALL XVIPARM('HOME',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        IF(SL .NE. 1 .OR. SS .NE. 1) THEN
          SL = 1
          SS = 1
          CALL DSPLY(SL,SS)
        END IF
      END IF
C
C        'MOVE WINDOW UP'
C
      CALL XVIPARM('U',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IF(SL .NE. 1) THEN 
          REDISP = 1
          NSL = SL - IARG(1)
          SL = MAX0(1,NSL)
        ENDIF
      END IF
C
C        'MOVE WINDOW UP'
C
      CALL XVIPARM('UP',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IF(SL .NE. 1) THEN 
          REDISP = 1
          NSL = SL - IARG(1)
          SL = MAX0(1,NSL)
        ENDIF
      END IF
C
C        'MOVE WINDOW DOWN'
C
      CALL XVIPARM('D',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IF(SL .NE. MAXSL) THEN
          REDISP = 1
          NSL = SL + IARG(1)
          SL = MIN0(MAXSL,NSL)
        END IF 
      END IF
C
C        'MOVE WINDOW DOWN'
C
      CALL XVIPARM('DOWN',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IF(SL .NE. MAXSL) THEN
          REDISP = 1
          NSL = SL + IARG(1)
          SL = MIN0(MAXSL,NSL)
        END IF 
      END IF
C
C        'MOVE WINDOW RIGHT'
C
      CALL XVIPARM('R',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IF(SS .NE. MAXSS) THEN
          REDISP = 1
          NSS = SS + IARG(1) 
          SS = MIN0(MAXSS,NSS)
        END IF
      END IF
C
C        'MOVE WINDOW RIGHT'
C
      CALL XVIPARM('RIGHT',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IF(SS .NE. MAXSS) THEN
          REDISP = 1
          NSS = SS + IARG(1) 
          SS = MIN0(MAXSS,NSS)
        END IF
      END IF
C
C        'MOVE WINDOW LEFT'
C
      CALL XVIPARM('L',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        IF(SS .NE. 1) THEN
          REDISP = 1
          NSS = SS - IARG(1)
          SS = MAX0(1,NSS)
        END IF
      END IF
C
C        'MOVE WINDOW LEFT'
C
      CALL XVIPARM('LEFT',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        IF(SS .NE. 1) THEN
          REDISP = 1
          NSS = SS - IARG(1)
          SS = MAX0(1,NSS)
        END IF
      END IF
C
C        'STRETCH'
C
      CALL XVIPARM('STRETCH',IARG,ICNT,IDEF,2)
      IF (IDEF.EQ.0) THEN 
        LO = IARG(1) 
        HI = IARG(2)
        IF((LO.EQ.538976288) .OR. (HI.EQ.538976288)) THEN
           CALL XVMESSAGE(' CHECK STRETCH INPUTS.',' ')
           CALL XVMESSAGE(' TWO INTEGERS REQUIRED.',' ')
        ELSE     
          SLOPE = 255. / (HI - LO)
          OFST = -LO * SLOPE
          DO I=1,256
             DN = I - 1
             II = IFIX(SLOPE*DN + OFST + 0.5)
             IF(II .LT. 0) II = 0
             IF(II .GT. 255) II = 255
             STR(I) = II
          END DO
          IERR = XDLWRITE(DUNIT,1,1,STR)
          IERR = XDLWRITE(DUNIT,2,1,STR)
          IERR = XDLWRITE(DUNIT,3,1,STR)
        END IF
      END IF
C
C        'LINEAR'
C

      CALL XVIPARM('LINEAR',IARG,ICNT,IDEF,2)
      IF (IDEF.EQ.0) THEN 
        LO = IARG(1) 
        HI = IARG(2)
        IF((LO.EQ.538976288) .OR. (HI.EQ.538976288)) THEN
           CALL XVMESSAGE(' CHECK STRETCH INPUTS.',' ')
           CALL XVMESSAGE(' TWO INTEGERS REQUIRED.',' ')
        ELSE     
          SLOPE = 255. / (HI - LO)
          OFST = -LO * SLOPE
          DO I=1,256
             DN = I - 1
             II = IFIX(SLOPE*DN + OFST + 0.5)
             IF(II .LT. 0) II = 0
             IF(II .GT. 255) II = 255
             STR(I) = II
          END DO
          IERR = XDLWRITE(DUNIT,1,1,STR)
          IERR = XDLWRITE(DUNIT,2,1,STR)
          IERR = XDLWRITE(DUNIT,3,1,STR)
        END IF
      END IF
C
C        'ON'
C
      CALL XVIPARM('ON',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        IERR = XDLWRITE(DUNIT,1,1,STR)
        IERR = XDLWRITE(DUNIT,2,1,STR)
        IERR = XDLWRITE(DUNIT,3,1,STR)
      END IF
C
C        'OFF'
C
      CALL XVIPARM('OFF',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN 
        IERR = XDLWRITE(DUNIT,1,1,OFF)
        IERR = XDLWRITE(DUNIT,2,1,OFF)
        IERR = XDLWRITE(DUNIT,3,1,OFF)
      END IF
C
C        'RAW'
C
      CALL XVIPARM('RAW',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        IERR = XDLWRITE(DUNIT,1,1,RAW)
        IERR = XDLWRITE(DUNIT,2,1,RAW)
        IERR = XDLWRITE(DUNIT,3,1,RAW)
      ENDIF
C
C        'MULTIPLY'
C
      CALL XVIPARM('MULT',RARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        FUNC = 1
        CONST = RARG(1)
        VERFLG = 1
      END IF
C
C        'ADD'
C
      CALL XVIPARM('ADD',RARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        FUNC = 2
        CONST = RARG(1)
        VERFLG = 1
      END IF
C
C        'SUBTRACT'
C
      CALL XVIPARM('SUBTRACT',RARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        FUNC = 3
        CONST = RARG(1)
        VERFLG = 1
      END IF 
C
C        'SUBTRACT'
C
      CALL XVIPARM('SUB',RARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        FUNC = 3
        CONST = RARG(1)
        VERFLG = 1
      END IF 
C
C        'DIVIDE'
C
      CALL XVIPARM('DIVIDE',RARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        FUNC = 4
        CONST = RARG(1)
        VERFLG = 1
      END IF
C
C        'DIVIDE'
C
      CALL XVIPARM('DIV',RARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        FUNC = 4
        CONST = RARG(1)
        VERFLG = 1
      END IF
C
C        'INTERPOLATE'
C
      CALL XVIPARM('INTERP',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
       FUNC = 0
       VERFLG=1
      END IF 
C
C        'SET TO DN'
C
      CALL XVIPARM('SETTO',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        FUNC = 5
        VERFLG = 1
        ICONST = IARG(1) 
        IF (ICONST .EQ. 538976288) THEN  
	  CALL XVMESSAGE(' SET TO ZERO ASSUMED',' ')
          ICONST = 0
        END IF
      END IF
C
C        'SET TO DN'
C
      CALL XVIPARM('SET',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN 
        FUNC = 5
        VERFLG = 1
        ICONST = IARG(1) 
        IF (ICONST .EQ. 538976288) THEN  
	  CALL XVMESSAGE(' SET TO ZERO ASSUMED',' ')
          ICONST = 0
        END IF
      END IF
C
C        'ZERO'
C
      CALL XVIPARM('ZERO',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN 
        FUNC = 6
        ICONST = 0
        VERFLG = 1
      END IF
C
C        'DBUG'
C
      CALL XVIPARM('DBUG',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) DBUG=1
C
C        'COPY INPUT'
C
      CALL XVIPARM('COPY',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        FUNC = 8
        VERFLG = 1
      END IF
C
C        'RESTORE'
C
      CALL XVIPARM('RESTORE',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        FUNC = 8
        VERFLG = 1
      END IF
C
C        'READ CURSOR'
C
      CALL XVIPARM('RCUR',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN 
        IERR = XDCLOCATION(DUNIT,1,IDS,IDL)
        IPL = IDL + SL - 1
        IPS = IDS + SS - 1

        WRITE(MSG,990) IDL,IDS
        CALL XVMESSAGE(MSG,' ')

        WRITE(MSG,1000) IPL,IPS
        CALL XVMESSAGE(MSG,' ')
      END IF
C
C        'POSITION CURSOR'
C
      CALL XVIPARM('PCUR',IARG,ICNT,IDEF,2)
      IF (IDEF.EQ.0)  THEN 
        L = IARG(1) - SL + 1
        S = IARG(2) - SS + 1
        IF ((L.EQ.538976288) .AND. (S.EQ.538976288)) THEN
  	  CALL XVMESSAGE(' LOCATION MUST BE SPECIFIED',' ')
        ELSE 
           IF (L.LT.1.OR.L.GT.MAXL.OR.S.LT.1.OR.S.GT.MAXS) THEN
             CALL XVMESSAGE(' LOCATION SPECIFIED IS CURRENTLY NOT',' ')
	     CALL XVMESSAGE(' DISPLAYED; REPOSITION IMAGE AND TRY AGAIN',
     .  			' ')
           ELSE
            IERR = XDCSET(DUNIT,1,S,L)
           END IF
        END IF
      END IF
C
C        'CIRCLE MODE'
C
      CALL XVIPARM('CIRC',IARG,ICNT,IDEF,1)
      IF (IDEF.EQ.0) THEN
        IRAD = IARG(1)
        IF( IRAD .EQ. 538976288 ) THEN
 	  CALL XVMESSAGE(' INTEGER RADIUS VALUE REQUIRED',' ')
        ELSE
          CALL XDDINFO(DUNIT, 35, 1, SECTION)
          IERR = XDGLINIT(DUNIT,SECTION)
          MDN = XDGCOLOR(DUNIT,'WHITE')
          IDN = XDGCOLOR(DUNIT,'BLACK')
          BMDN = INT2BYTE(MDN)
          BIDN = INT2BYTE(IDN)
          IERR = XDIMFILL(DUNIT,PLANE,BMDN,BIDN)
          CALL CIRCLE(IRAD,NSEG,NPTS,FUNC,*24)
          CMODE = 1
          GO TO 251
        END IF
      END IF
C
C        'CALCULATE AVG. SD AND MIN & MAX DN'
C
      CALL XVIPARM('STATS',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        FUNC=7
        VERFLG=1
      END IF
C
C--------------------------------------------------------------
C        REDISPLAY IF NECESSARY
200   ATDL = SL - SLDS
      ATDS = SS - SSDS
      IF (REDISP .EQ. 1) THEN
         REDISP = 0
         CALL DSPLY(SL,SS)
         LIN1 = 1 - ATDL
         LINNL = NL - ATDL
         SAM1 = 1 - ATDS
         SAMNS = NS - ATDS
      END IF

C        VERTEX ACQUISITION LOOP
      IF (VERFLG .EQ. 0) GO TO 24
      CALL XVMESSAGE('FOR EACH POINT, POSITION THE CURSOR AND',' ')
      CALL XVMESSAGE('ENTER NEXT AND PRESS RETURN.  ENTER NEXT',' ')
      CALL XVMESSAGE('AND PRESS RETURN A SECOND TIME WITHOUT',' ')
      CALL XVMESSAGE('MOVING THE CURSOR TO INDICATE THE LAST',' ')
      CALL XVMESSAGE('LAST VERTEX. DO NOT END WITH THE ORIGINAL',' ')
      CALL XVMESSAGE('VERTEX; THE PROGRAM WILL COMPLETE THE',' ')
      CALL XVMESSAGE('POLYGON FOR YOU.',' ')
215   NVERT = 0
      LL = -99
      LS = -99
C        ERASE GRAPHICS PLANE
      IERR = XDIMFILL(DUNIT,PLANE,MDN,IDN)
220   CALL XVMESSAGE(' READY FOR TRACKBALL',' ')
      CALL XVMESSAGE(' TO SPECIFY COORDINATES, POSITION TRACKBALL'
     +                                         ,' ')
      CALL XVMESSAGE(' AND ENTER NEXT.',' ')
      CALL XVMESSAGE(' TO EXIT, ENTER ANY OTHER COMMAND',' ')

221   CALL XVINTRACT('IPARAM','ENTER NEXT OR OTHER COMMAND')
      CALL XVIPARM('NEXT',IARG,ICNT,IDEF,0)

      IF (IDEF.NE.0) THEN
        VERFLG=0
        GO TO 10
      END IF

C        GET TRACKBALL LOCATION
      IERR = XDCLOCATION(DUNIT,1,S,L)
      IF(L.GT.LINNL.OR.L.LT.LIN1.OR.S.GT.SAMNS.OR.S.LT.SAM1) THEN
        CALL XVMESSAGE('REPOSITION, CURSOR IS OUTSIDE THE PICTURE',' ')
        GO TO 220		
      END IF
      IF(L .EQ. LL .AND. S .EQ. LS) GO TO 250
      LL = L
      LS = S
      NVERT = NVERT + 1
      IF (NVERT .EQ. 25) THEN
        CALL XVMESSAGE(' TOO MANY PTS GATHERED.  START OVER',' ')
        PLANE = XDSGRAPH(DUNIT)
        CALL XDDINFO(DUNIT, 35, 1, SECTION)
        IERR = XDGLINIT(DUNIT, SECTION)
        IDN = XDGCOLOR(DUNIT, 'BLACK')
        MDN = XDGCOLOR(DUNIT, 'WHITE')
        BMDN = INT2BYTE(MDN)
        BIDN = INT2BYTE(IDN) 
        IERR = XDIMFILL( DUNIT, PLANE, BMDN, BIDN)
        GO TO 215
      END IF
      V(1,NVERT) = S + (ATDS/1.0)
      V(2,NVERT) = L + (ATDL/1.0)
      X(2) = S
      Y(2) = L
 
      IF(NVERT .GT. 1) THEN
         CALL XDDINFO(DUNIT, 35, 1, SECTION)
         IERR = XDGLINIT(DUNIT,SECTION)
         DN = XDGCOLOR(DUNIT,'WHITE')
         BDN = INT2BYTE(DN)
         IERR = XDIPOLYLINE(DUNIT,PLANE,BDN,2,X,Y)
      END IF
      X(1)=X(2)
      Y(1)=Y(2)
      IF (NVERT .EQ. 23) THEN
	CALL XVMESSAGE(' YOU ARE ALLOWED ONE LAST POINT',' ')
      ENDIF	
      GO TO 221		

C        LAST POINT
250   X(2) = V(1,1) - (ATDS/1.0)
      Y(2) = V(2,1) - (ATDL/1.0)
      CALL XDDINFO(DUNIT, 35, 1, SECTION)
      IERR = XDGLINIT(DUNIT,SECTION)
      DN = XDGCOLOR(DUNIT,'WHITE')
      BDN = INT2BYTE(DN)
      IERR = XDIPOLYLINE(DUNIT,PLANE,BDN,2,X,Y)

C      CALL PRNT(4,1,NVERT,'NVERT=.')
      WRITE(MSG,252) NVERT
252   FORMAT('NVERT= ',I8)
      CALL XVMESSAGE(MSG,' ')

C        CHECK IF OK
C251   CALL XVMESSAGE(' OK ?   (Y OR N)',16)
251   CALL XVINTRACT('IPARAM',' OK ? (Y OR N) ')
      CALL XVIPARM('N',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        PLANE = XDSGRAPH(DUNIT)
        CALL XDDINFO(DUNIT, 35, 1, SECTION)
        IERR = XDGLINIT(DUNIT, SECTION)
        IDN = XDGCOLOR(DUNIT, 'BLACK')
        MDN = XDGCOLOR(DUNIT, 'WHITE')
        BMDN = INT2BYTE(MDN)
        BIDN = INT2BYTE(IDN) 
        IERR = XDIMFILL( DUNIT, PLANE, BMDN, BIDN)
        GO TO 215
      ENDIF
      CALL XVIPARM('NO',IARG,ICNT,IDEF,0)
      IF (IDEF.EQ.0) THEN
        PLANE = XDSGRAPH(DUNIT)
        CALL XDDINFO(DUNIT, 35, 1, SECTION)
        IERR = XDGLINIT(DUNIT, SECTION)
        IDN = XDGCOLOR(DUNIT, 'BLACK')
        MDN = XDGCOLOR(DUNIT, 'WHITE')
        BMDN = INT2BYTE(MDN)
        BIDN = INT2BYTE(IDN) 
        IERR = XDIMFILL( DUNIT, PLANE, BMDN, BIDN)
        GO TO 215
      ENDIF
C        START COLLECTING THE POINTS DEFINING THE POLYGON
      IF (CMODE .EQ. 1) GO TO 275
      CALL COLECT(NSEG,NPTS,V,*24)

C        NOW DO THE REQUESTED OPERATION ON THE LINE SEGMENTS OF POLYGON
275   CALL OPRATE(NSEG,ICONST,CONST,ATDL,ATDS,NPTS)
      CMODE = 0
      GO TO 215

C        CLOSE DATA SETS AND DISPLAY DEVICE
900   CALL XVCLOSE(IUNIT,STAT,' ')
      CALL XVCLOSE(OUNIT,STAT,' ')
      CALL CLOSE_DEVICE(DUNIT)

990   FORMAT('SCREEN  LINE= ',I3,'  SAMPLE= ',I3)
1000  FORMAT('PICTURE LINE= ',I3,'  SAMPLE= ',I3)

      RETURN
      END
C
C
C**********************************************************************
C
      SUBROUTINE DSPLY(SL,SS)

C        THIS ROUTINE WILL DISPLAY A PORTION OF A BYTE OR HALFWORD PIC.
      
C      IMPLICIT INTEGER(A-Z)
      IMPLICIT NONE

      INCLUDE 'fortport'

      COMMON/C/IUNIT,OUNIT,ICOD,HBL,HBH,FUNC,RADI
      COMMON /D/ NL,NS,NLDS,NSDS
      COMMON /F/ LBUF,DBUG,NVERT,MINDN,MAXDN,PERC
      COMMON /H/ DUNIT

      INTEGER OUNIT

      LOGICAL*1 OBUF(20000)
      LOGICAL*1 LBUF(20000)
      REAL S1,S2
      INTEGER HISBUF(256),STAT,D1,D2,XDSGRAPH,XDGCOLOR
      INTEGER SECTION
      INTEGER XDIFILL,XDIMFILL,XDILINEWRITE,XDGLINIT
      BYTE BMDN, BIDN

      INTEGER*4 SL,SS,DBUG,DUNIT,EL,FUNC,HBH,HBL,ICOD
      INTEGER*4 IDN,IERR,ILDS,ISW,IUNIT,L,MAXDN,MDN
      INTEGER*4 MINDN,NL,NLDS,NLO,NS,NSDS,NSO,NVERT
      INTEGER*4 PERC,PLANE,RADI

      S1 = HBL
      S2 = HBH
      D1 = 0
      D2 = 0
C        ERASE GRAPHICS
      PLANE = XDSGRAPH(DUNIT)
      CALL XDDINFO(DUNIT, 35, 1, SECTION)
      IERR = XDGLINIT(DUNIT,SECTION)
      MDN = XDGCOLOR(DUNIT,'WHITE')
      IDN = XDGCOLOR(DUNIT,'BLACK')
      BMDN = INT2BYTE(MDN)
      BIDN = INT2BYTE(IDN)
      IERR = XDIMFILL(DUNIT,PLANE,BMDN,BIDN)
C        ERASE VIDEO
      IERR = XDIFILL(DUNIT,1,IDN)
      NLO = MIN0(NLDS,NL)
      EL = SL + NLO - 1
      NSO = MIN0(NSDS,NS)
      ILDS = 1
C
      IF(ICOD .EQ. 2) THEN
         ISW = 1
         CALL DFORM(LBUF,OBUF,NSO,HISBUF,ISW,1,2,D1,D2,S1,S2,0)
      END IF
C
      DO L=SL,EL
         CALL XVREAD(OUNIT,LBUF,STAT,'LINE',L,'SAMP',SS,
     .    	'NSAMPS',NSO,' ')
	 IF(ICOD .EQ. 2) THEN
            ISW = 0
            CALL DFORM(LBUF,OBUF,NSO,HISBUF,ISW,0,0,0,0,0,0,0)
            IERR = XDILINEWRITE(DUNIT,1,1,ILDS,NSO,OBUF)
         ELSE
            IERR = XDILINEWRITE(DUNIT,1,1,ILDS,NSO,LBUF)
         END IF
         ILDS = ILDS + 1
      END DO
C
      RETURN
      END
C
C
C**********************************************************************
C
      SUBROUTINE COLECT(NSEG,NPTS,V,*)

C        THIS ROUTINE WILL COLLECT THE NECESSARY POINTS ABOUT THE
C        PERIPHERY OF THE SPECIFIED POLYGON.

C      IMPLICIT INTEGER (A-Z)
      IMPLICIT NONE

      COMMON/C/IUNIT,OUNIT,ICOD,HBL,HBH,FUNC,RADI
      COMMON /D/ NL,NS,NLDS,NSDS
      COMMON /E/ PTBUF,SEGM,SORT
      COMMON /F/ LBUF,DBUG,NVERT,MINDN,MAXDN,PERC
      COMMON /H/ DUNIT

      INTEGER OUNIT,NPTS,P,N,L
      REAL RANDOUT
      LOGICAL*1 LBUF(20000)
      INTEGER*2 PTBUF(3,4000),SEGM(3,2000),SORT(2,4000)
      
      REAL POINT(2),T,SLOPE,V(2,26)
      INTEGER*2 PT(3,1000)
      CHARACTER*80 PBUF
      CHARACTER*100 MSG
      LOGICAL*1 INSIDE

      INTEGER*4 NSEG,DBUG,DUNIT,EL,ES,FUNC,HBH,HBL,HH,I,ICOD
      INTEGER*4 INC,IUNIT,J,LL,MAXDN,MAXL,MINDN,MINL,MM,MNL
      INTEGER*4 MV,MXL,NL,NLDS,NONL,NS,NSDS,NVERT,NX,PERC,PL
      INTEGER*4 PS,PX,RADI,S,SEED1,SL,SS,STL,WEED
      INTEGER*4 LINEIDX,SAMPIDX

C     Appropriate for little endian word order
      LINEIDX = 2
      SAMPIDX = 1

C     EQUIVALENCE (LBUF,PBUF,PT)
C
C        CHECK FOR DUPLICATED END VERTEX
C

      IF(V(1,NVERT).EQ.V(1,1) .AND. V(2,NVERT).EQ.V(2,1)) THEN
	NVERT = NVERT - 1
      ELSE
	V(1,NVERT+1) = V(1,1)
        V(2,NVERT+1) = V(2,1)
      ENDIF
C
C        CHECK FOR POLYGON COMPLETELY OUTSIDE OF IMAGE
C
      DO 1510 HH=1,NVERT
          IF (V(1,HH).LE.NS .AND. V(2,HH).LE.NL) GO TO 1520
1510  CONTINUE
      CALL XVMESSAGE(' POLYGON IS COMPLETELY OUTSIDE THE IMAGE',' ')
      RETURN 1
1520  CONTINUE
C
C---------------------------------------------------------------
C-----FOR EACH SIDE OF POLYGON,COLLECT POINTS OF INTERSECTION
C-----WITH LINES.
C-----N IS THE NUMBER OF INTERSECTION POINTS
C-----NPTS IS THE NUMBER OF EXTERIOR POINTS
C-----NSEG IS THE NUMBER OF LINE SEGMENTS TO OPERATE ON
      NPTS = 0
      NSEG = 0
      N = 0
      DO 2200 J=1,NVERT
      SL = V(2,J)
      SS = V(1,J)
      EL = V(2,J+1)
      ES = V(1,J+1)
C-------------------------------------------------------------
C-----NOW COLLECT A DUPLICATE POINT FOR VERTICIES WHICH ARE
C-----LOCAL MINIMA OR MAXIMA, SO WE WILL END UP WITH TWO
C-----INTERSECTION POINTS AT THESE VERTICIES
      IF(J .EQ. 1) GO TO 550
      PL = V(2,J-1)
      PS = V(1,J-1)
      GO TO  560
  550 PL = V(2,NVERT)
      PS = V(1,NVERT)
  560 IF(PL .EQ. SL .OR. EL .EQ. SL) GO TO 570
      IF (MIN0(PL,SL,EL) .NE. SL .AND. MAX0(PL,SL,EL) .NE. SL) THEN 
	GO TO 570
      ENDIF
      N = N + 1
      SORT(LINEIDX,N) = SL
      SORT(SAMPIDX,N) = SS
  570 CONTINUE
C----------------------------------------------------------------
      IF(EL .GT. SL) INC = 1
      IF(EL .LT. SL) INC = -1
      IF(EL .NE. SL) GO TO 2100
      N = N + 1
      SORT(LINEIDX,N) = SL
      SORT(SAMPIDX,N) = SS
      GO TO 2200
 2100 SLOPE = FLOAT (ES-SS) / FLOAT (EL-SL)
      L = SL
 2110 T = SLOPE * FLOAT (L-SL)
      S = IFIX(T+SS+0.5)
      N = N + 1
      SORT(LINEIDX,N) = L
      SORT(SAMPIDX,N) = S
      L = L + INC
      IF(L .NE. EL) GO TO 2110
 2200 CONTINUE
C
C-----------------------------------------------------------------------
C        SORT INTERSECTION POINTS BY LINE AND SAMPLE SIMULTANEOUSLY
C
      CALL SORTX(SORT,N)
      IF(SORT(LINEIDX,N-1).NE.SORT(LINEIDX,N)) THEN
        SORT(LINEIDX,N+1)=SORT(LINEIDX,N)
        SORT(SAMPIDX,N+1)=SORT(SAMPIDX,N)
        N=N+1
      ENDIF
      IF (DBUG .EQ. 1) THEN
C     CALL PRNT(2,2*N,SORT,' AFT LINE.')
       DO J=1,N
        WRITE(MSG,2201) SORT(LINEIDX,J),SORT(SAMPIDX,J)
 2201   FORMAT(' AFT LINE ', 2I8)
        CALL XVMESSAGE(MSG,' ')
       ENDDO
      END IF
C-----------------------------------------------------------------------
C        TRANSFORM INTERSECTION PTS INTO LINE SEGMENTS MAKING UP POLYGON
C
      MINL = SORT(LINEIDX,1)
      MAXL = SORT(LINEIDX,N)
      STL = 1
      IF (DBUG .EQ. 1) THEN 
C     CALL PRNT(4,1,N,' NO INTRSCTN PTS.')
      WRITE(MSG,2202) N
 2202 FORMAT('NO INTRSCTN PTS', I8)
      CALL XVMESSAGE(MSG,' ')
      END IF
      DO 2300 L=MINL,MAXL
      NONL = 0
C
C        FIND NUMBER OF POINTS ON LINE L
C

      DO 2250 P=STL,N
      IF(SORT(LINEIDX,P) .NE. L)  GO TO 2260
 2250 NONL = NONL + 1 

C
C        CHECK FOR EVEN NUMBER OF POINTS ON THIS LINE
C
      
 2260 IF(MOD(NONL,2) .EQ. 0) GO TO 2265
CC      Call XLGET(UNIT,'HISTORY','ENTROPY',BUF(50),ISTAT,'HIST',
C     *		TASKS(JG),'FORMAT','REAL',' ')
C        FIXUP NECESSARY FOR THIS LINE.  IT HAS ODD # OF INTERSECTION
C        POINTS.  WE WILL THROW OUT HE POINTS WHICH IS BOTH A VERTEX
C        AND AN EVEN # OF POINTS FROM BEGINNING INTERSECTION.
C
      CALL ITLA(32,PBUF,80)
      WRITE (PBUF,190) NONL,L
  190 FORMAT(I2,' INTERSECTION POINTS FOR LINE ',I4)
      CALL XVMESSAGE(PBUF,' ')
      DO 200 LL=2,NONL,2
      PX = STL + LL - 1
      DO 200 MM=1,NVERT

      IF(SORT(LINEIDX,PX).EQ.V(2,MM) .AND. SORT(SAMPIDX,PX).EQ.V(1,MM)) GO TO 250

  200 CONTINUE
      CALL XVMESSAGE(' NO EVEN POINTS WERE VERTICIES',' ')
      CALL XVMESSAGE(' PATHOLOGICAL FIGURE....TRY AGAIN',' ')
      RETURN 1
  250 MV = 2 * (N-PX)
      CALL MVE(2,MV,SORT(LINEIDX,PX+1),SORT(LINEIDX,PX),1,1)
      N = N - 1
      NONL = NONL - 1
      CALL XVMESSAGE(' FIXUP SUCCESSFUL',' ')
C     CALL PRNT(4,1,NONL,' PTS ON LINE.')
      WRITE(MSG,2264) NONL
 2264 FORMAT(' PTS ON LINE ', I8)
      CALL XVMESSAGE(MSG,' ')
 2265 CONTINUE
C
C---------------------------------------------------------------
C-----FILL LINE SEGMENT AND EXTERIOR POINTS BUFFERS
      P = 1
 2268 NSEG = NSEG + 1
      SEGM(1,NSEG) = L
      NX = STL+P-1
      SEGM(2,NSEG) = SORT(SAMPIDX,NX)
      NX = NX + 1
      IF(P .EQ. NONL-1) GO TO 2269
      IF(SORT(SAMPIDX,NX) .NE. SORT(SAMPIDX,NX+1)) GO TO 2269
      NX = NX + 2
      P = P + 2
 2269 SEGM(3,NSEG) = SORT(SAMPIDX,NX)
      IF(SEGM(2,NSEG) .LE. 1) GO TO 2270
      NPTS = NPTS + 1
      PTBUF(1,NPTS) = SEGM(2,NSEG) - 1
      PTBUF(2,NPTS) = L
 2270 CONTINUE
      IF(SEGM(3,NSEG) .GE. NS) GO TO 2290
      NPTS = NPTS + 1
      PTBUF(1,NPTS) = SEGM(3,NSEG) + 1
      PTBUF(2,NPTS) = L
 2290 P = P + 2
      IF(P .LE. NONL) GO TO 2268
 2300 STL = STL + NONL
C
      IF(DBUG .EQ. 0) GO TO 2301
C     CALL PRNT(4,1,NSEG,' NO LINE SEGMENTS.')
      WRITE(MSG,2291) NSEG
 2291 FORMAT(' NO LINE SEGMENTS ', I8)
      CALL XVMESSAGE(MSG,' ')
C     CALL PRNT(2,3*NSEG,SEGM,' SEGM BUF.')
      DO J=1,NSEG
        WRITE(MSG,2292) SEGM(1,J), SEGM(2,J), SEGM(3,J)
 2292   FORMAT(' SEGM BUF ', 3I8)
        CALL XVMESSAGE(MSG,' ')
      ENDDO
 2301 IF(FUNC .NE. 0) RETURN
C--------------------------------------------------------------
C-----COLLECT EXTERIOR POINTS ABOVE AND BELOW EACH SIDE BY
C-----MOVING IN SAMPLE DIRECTION (HENCE THE FUNNY SLOPE)
      DO 1400 J=1,NVERT
      SL = V(2,J)
      SS = V(1,J)
      EL = V(2,J+1)
      ES = V(1,J+1)
      S = SS
      IF(ES .GT. SS) INC = 1
      IF(ES .LT. SS) INC = -1
      IF(ES .EQ. SS) GO TO 1340
      SLOPE = FLOAT(EL-SL) / FLOAT(ES-SS)
 1310 T = SLOPE * FLOAT(S-SS) + SL
      IF(T .EQ. 1. .OR. T .EQ. 1.*NL) GO TO 1320
      L = IFIX(T - 0.001)
      POINT(1) = S
      POINT(2) = T - 1.
      IF(INSIDE(POINT,V,NVERT)) L = IFIX(T + 1. )
      CALL PTADD(L,S,NPTS,PTBUF)
 1320 S = S + INC
      IF(S .NE. ES) GO TO 1310
      GO TO 1400
 1340 MNL = MIN0(SL,EL)
      MXL = MAX0(SL,EL)
      IF(MNL .EQ. 1) GO TO 1350
      NPTS = NPTS + 1
      PTBUF(1,NPTS) = S
      PTBUF(2,NPTS) = MNL - 1
 1350 IF(MXL .EQ. NL) GO TO 1400
      NPTS = NPTS + 1
      PTBUF(1,NPTS) = S
      PTBUF(2,NPTS) = MXL + 1
 1400 CONTINUE
      IF(DBUG .EQ. 1) THEN
C     CALL PRNT(4,1,NPTS,' NO PTS TOTAL.')
      WRITE(MSG,1401) NPTS
 1401 FORMAT(' NO PTS TOTAL', I8)
      CALL XVMESSAGE(MSG,' ')
      END IF
C
 1500 CONTINUE
      IF(DBUG .EQ. 1) THEN
C     CALL PRNT(2,3*NPTS,PTBUF,' AFT SAMP.')
      DO J=1,NPTS
        WRITE(MSG,1501) PTBUF(1,J),PTBUF(2,J),PTBUF(3,J)
 1501   FORMAT(' AFT SAMP ', 3I8)
        CALL XVMESSAGE(MSG,' ')
      ENDDO
      END IF
C
C-----------------------------------------------------------------
C-----CUT BACK ON THE NUMBER OF POINTS BY SELECTING (WEED) POINTS
C-----AT RANDOM (I HOPE).  MAKE SURE N IS IN RANGE 1 - NPTS AND
C-----IS NOT REPEATED.
      IF(PERC .EQ. 100) GO TO 1100
      WEED = PERC * NPTS / 100
      SEED1 = 15289
C
      DO 1000 I=1,WEED
 1001 CALL GET_RAN(SEED1,RANDOUT)
      N=RANDOUT*NPTS
      IF(N .LT. 1 .OR. N .GT. NPTS) GO TO 1001
      IF (I.EQ.1) GO TO 1003
      DO 1002 L=1,I
      IF(N .EQ. PT(3,L)) GO TO 1001
 1002 CONTINUE
 1003 PT(1,I) = PTBUF(1,N)
      PT(3,I) = N
 1000 PT(2,I) = PTBUF(2,N)
C
      NPTS = WEED
      CALL MVE(2,3*NPTS,PT,PTBUF,1,1)
 1100 CONTINUE
      IF(DBUG .EQ. 1) THEN
C     CALL PRNT(4,1,NPTS,' NPTS AFT WEED.')
      WRITE(MSG,1101) NPTS
 1101 FORMAT(' NPTS AFT WEED ', I8)
      CALL XVMESSAGE(MSG,' ')
      END IF
C
C----------------------------------------------------------------
C-----SORT EXTERIOR POINTS BY LINE AND SAMPLE IN ORDER TO READ DNS
      CALL MVE(2,NPTS,PTBUF(2,1),SORT(LINEIDX,1),3,2)
      CALL MVE(2,NPTS,PTBUF(1,1),SORT(SAMPIDX,1),3,2)
      CALL SORTX(SORT,NPTS)
C
C-------------------------------------------------------------------
C-----FILL PTBUF BY READING DNS OF SORTED POINTS
      CALL GETDN(NPTS)
C--------------------------------------------------------------------
C-----CHECK FOR THRESHHOLD CRITERIAN
      IF(MINDN .EQ. -9999 .AND. MAXDN .EQ. 32768) GO TO 650
      I = 0
  600 I = I + 1
      IF(I .GT. NPTS) GO TO 650
      IF(PTBUF(3,I) .GE. MINDN .AND. PTBUF(3,I) .LE. MAXDN) GO TO 600
      CALL MVE(2,3,PTBUF(1,NPTS),PTBUF(1,I),1,1)
      NPTS = NPTS - 1
      I = I - 1
      GO TO 600
  650 CONTINUE
C---------------------------------------------------------------------
      IF(NPTS .LT. 1) GO TO 997
      IF(DBUG .EQ. 0) RETURN
C     CALL PRNT(4,1,NPTS,' NPTS AFT THRESH.')
      WRITE(MSG,651) NPTS
  651 FORMAT(' NPTS AFT THRESH ', I8)
      CALL XVMESSAGE(MSG,' ')
C     CALL PRNT(2,NPTS*3,PTBUF,' PTBUF.')
      DO J=1,NPTS
        WRITE(MSG,652) PTBUF(1,J),PTBUF(2,J),PTBUF(3,J)
  652   FORMAT(' NO PTS TOTAL', 3I8)
        CALL XVMESSAGE(MSG,' ')
      ENDDO
C
C----------------------------------------------------------------
C
      RETURN

997   CALL XVMESSAGE(' NO PTS IN RANGE MIN TO MAX',' ')
      RETURN 1
      END
C
C
C**********************************************************************
C
      SUBROUTINE OPRATE(NSEG,ICONST,CONST,ATDL,ATDS,NPTS)

C      IMPLICIT INTEGER (A-Z)
      IMPLICIT NONE

      INCLUDE 'fortport'

      COMMON/C/IUNIT,OUNIT,ICOD,HBL,HBH,FUNC,RADI
      COMMON /E/ PTBUF,SEGM,SORT
      COMMON /H/ DUNIT

      LOGICAL*1 OBUF(10000)

      CHARACTER*200 MSG
      INTEGER OUNIT
      INTEGER*2 HBUF(10000)
      INTEGER*2 PTBUF(3,4000),SEGM(3,2000),SORT(2,4000)

      REAL*8 DNSUM,DNSUM2
      REAL CONST,LO,HI,DNSD,SDEV
      INTEGER ULIM/255/,LLIM/0/,STAT,HISBUF(256)
      INTEGER X,Y,NNS,D1,D2,XDSGRAPH, XDGCOLOR,PLANE
      INTEGER XDILINEWRITE, XDIMFILL,XDGLINIT
      INTEGER*4 ICONST, IDN, MDN, SECTION
      INTEGER*4 IHBUF(10000)
      BYTE BIDN, BMDN

      INTEGER*4 NSEG,ATDL,ATDS,DL,L,S,NPTS,D,J,DUNIT
      INTEGER*4 ES,FUNC,HBH,HBL,I,ICOD,IDNAVG,IERR,INUM
      INTEGER*4 ISW,IUNIT,MARK,MAXDN,MINDN,N,NS,RADI
      INTEGER*4 DS,SS

      CALL ZIA(IHBUF,10000)

C        LOOP THROUGH ALL SEGMENTS
      LO = HBL
      HI = HBH
      MARK = 0
      IF(ICOD .EQ. 2) THEN
         LLIM = -32768
         ULIM =  32767
      END IF
C
C        RE-OPEN OUTPUT AND INPUT DATA SETS WITH U_FORMAT = HALF
      CALL XVCLOSE(OUNIT,STAT,' ')
      CALL XVOPEN(OUNIT,STAT,'OP','UPDATE','U_FORMAT','HALF',' ')
      CALL XVCLOSE(IUNIT,STAT,' ')
      CALL XVOPEN(IUNIT,STAT,'U_FORMAT','HALF',' ')

      CALL MVE(-6,10000,ICONST,HBUF,0,1)
      ISW=1
      IDNAVG = 0
      DNSUM = 0.
      DNSUM2 = 0.
      INUM = 0
      MINDN = 32767
      MAXDN = -32768
      IF (ICOD.EQ.2) THEN
	CALL DFORM(HBUF,OBUF,10000,HISBUF,ISW,1,2,D1,D2,LO,HI,0)
      ENDIF

      DO 1000 N = 1, NSEG
      L = SEGM(1,N)
      SS = SEGM(2,N)
      ES = SEGM(3,N)
      NS = ES - SS + 1
      DL = L - ATDL
      DS = SS - ATDS

      GO TO (810,810,810,810,810,810,810,800), FUNC

C        INTERPOLATE
      CALL XVREAD(OUNIT,HBUF,STAT,'LINE',L,' ')
      CALL EXTRAP(NPTS,L,SS,ES,PTBUF,HBUF(SS),RADI)
      GO TO 900

C        COPY INPUT
800   CALL XVREAD(OUNIT,HBUF,STAT,'LINE',L,' ')
      CALL XVREAD(IUNIT,HBUF(SS),STAT,'LINE',L,'SAMP',SS,
     .		'NSAMPS',NS,' ')
      GO TO 900

C        ADD SUBTRACT MULTIPLY DIVIDE SETTO ZERO STATS
810   CALL XVREAD(OUNIT,HBUF,STAT,'LINE',L,' ')

      GO TO (820,840,880,830,831,831,832), FUNC

      CALL XVMESSAGE(' ILLEGAL FUNC IN OPRATE',' ')
      CALL ABEND
C
C        MULTIPLY
C
820   IF (CONST .NE. 0.0) GO TO 1820
         IF (N .EQ. NSEG) THEN
             CALL XVMESSAGE(' MULTIPLY BY ZERO NOT ALLOWED.',' ')
             CALL XVMESSAGE(' FLOATING POINT VALUE EXPECTED.',' ')
         END IF
         GO TO 900
1820   DO I=SS,ES
         IHBUF(I) = HBUF(I) * CONST
         IF(IHBUF(I) .GT. ULIM) IHBUF(I) = ULIM
         IF(IHBUF(I) .LT. LLIM) IHBUF(I) = LLIM
         HBUF(I)=IHBUF(I)
      END DO
      GO TO 900
C
C        DIVIDE
C
830   IF (CONST .NE. 0.0) GO TO 1830
         IF (N .EQ. NSEG) THEN
             CALL XVMESSAGE(' DIVIDE BY ZERO NOT ALLOWED.',' ')
             CALL XVMESSAGE(' FLOATING POINT VALUE EXPECTED.',' ')
         END IF
         GO TO 900
1830  DO I=SS,ES
         IHBUF(I) = HBUF(I) / CONST
         IF(IHBUF(I) .GT. ULIM) IHBUF(I) = ULIM
         IF(IHBUF(I) .LT. LLIM) IHBUF(I) = LLIM
         HBUF(I)=IHBUF(I)
      END DO
      GO TO 900
C
C        SET TO CONST
C
831   DO I=SS,ES
         HBUF(I) = ICONST
      END DO
      GO TO 900
C
C        CALCULATE MEAN, SD, MINDN AND MAXDN
C
832   DO I=SS,ES
         DNSUM = DNSUM + HBUF(I)
         DNSUM2 = DNSUM2 + (DFLOAT(HBUF(I))*HBUF(I))
         INUM = INUM + 1
         IF (HBUF(I) .LT. MINDN) MINDN=HBUF(I)
         IF (HBUF(I) .GT. MAXDN) MAXDN=HBUF(I)
      END DO
      IF (N .EQ. NSEG) THEN
         IDNAVG = (DNSUM/INUM) + .5                ! CALC MEAN
C        CALL PRNT(4,1,IDNAVG,'MEAN DN=.')
         WRITE(MSG,833) IDNAVG
833      FORMAT(' MEAN DN = ', I8)
         CALL XVMESSAGE(MSG,' ')
         DNSD = DNSUM2*INUM - DNSUM*DNSUM
         IF (INUM .NE. 0 .AND. DNSD .GT. 0) THEN   ! CALC STANDARD DEVIATION
            SDEV = SQRT(DNSD)/INUM
         ELSE
	    SDEV = 0.0
         END IF
C        CALL PRNT(7,1,SDEV,'STANDARD DEVIATION=.')
         WRITE(MSG,834) SDEV
834      FORMAT(' STANDARD DEVIATION = ', E12.4)
         CALL XVMESSAGE(MSG,' ')
C        CALL PRNT(4,1,INUM,'NUM PTS USED TO CALC AVG=.')
         WRITE(MSG,835) INUM
835      FORMAT(' NUM PTS USED TO CALC AVG = ', I8)
         CALL XVMESSAGE(MSG,' ')
C        CALL PRNT(4,1,MINDN,'MINDN=.')
         WRITE(MSG,836) MINDN
836      FORMAT(' MINDN = ', I8)
         CALL XVMESSAGE(MSG,' ')
C        CALL PRNT(4,1,MAXDN,'MAXDN=.')
         WRITE(MSG,837) MAXDN
837      FORMAT(' MAXDN = ', I8)
         CALL XVMESSAGE(MSG,' ')
      END IF
      GO TO 1000
C
C        ADD
C
840   IF (CONST .NE. 0.0) GOTO 1840
         IF (N .EQ. NSEG) THEN
             CALL XVMESSAGE(' ADDING ZERO NOT ALLOWED.',' ')
             CALL XVMESSAGE(' FLOATING POINT VALUE EXPECTED.',' ')
         END IF
         GO TO 900
1840   DO I=SS,ES
         IHBUF(I) = HBUF(I) + CONST
         IF(IHBUF(I) .GT. ULIM) IHBUF(I) = ULIM
         IF(IHBUF(I) .LT. LLIM) IHBUF(I) = LLIM
         HBUF(I)=IHBUF(I)
      END DO
      GO TO 900
C
C        SUBTRACT
C
880   IF (CONST .NE. 0.0) GO TO 1880
         IF (N .EQ. NSEG) THEN
             CALL XVMESSAGE(' SUBTRACTING ZERO NOT ALLOWED.',' ')
             CALL XVMESSAGE(' FLOATING POINT VALUE EXPECTED.',' ')
         END IF
         GO TO 900
1880   DO I=SS,ES
         IHBUF(I) = HBUF(I) - CONST
         IF(IHBUF(I) .GT. ULIM) IHBUF(I) = ULIM
         IF(IHBUF(I) .LT. LLIM) IHBUF(I) = LLIM
         HBUF(I)=IHBUF(I)
      END DO
C
C	Change the output line
C
900   CALL XVWRIT(OUNIT,HBUF,STAT,'LINE',L,' ')

C        WRITE THE NEW DNS TO THE DISPLAY
      IF(ICOD.EQ.2) THEN
        ISW = 0
      	CALL DFORM(HBUF(SS),OBUF,NS,HISBUF,ISW,0,0,0,0,0,0,0)
        
      ENDIF
      IF(ICOD.EQ.1) THEN
        CALL MVE(-3,NS,HBUF(SS),HBUF(SS),1,1)
      ENDIF
      X = DS
      Y = DL
      NNS = NS
      IF(ICOD.EQ.2) IERR = XDILINEWRITE(DUNIT,1,X,Y,NNS,OBUF)
      IF(ICOD.EQ.1) IERR = 
     & XDILINEWRITE(DUNIT,1,X,Y,NNS,HBUF(SS))
 1000 CONTINUE
C
C        RE-SET OUTPUT AND INPUT DATA SET U_FORMAT
      PLANE = XDSGRAPH(DUNIT)
      CALL XDDINFO(DUNIT, 35, 1, SECTION)
      IERR = XDGLINIT(DUNIT, SECTION)
      IDN = XDGCOLOR(DUNIT, 'BLACK')
      MDN = XDGCOLOR(DUNIT, 'WHITE')
      BMDN = INT2BYTE(MDN)
      BIDN = INT2BYTE(IDN) 
      IERR = XDIMFILL( DUNIT, PLANE, BMDN, BIDN)
      CALL XVCLOSE(OUNIT,STAT,' ')
      CALL XVOPEN(OUNIT,STAT,'OP','UPDATE',' ')
      CALL XVCLOSE(IUNIT,STAT,' ')
      CALL XVOPEN(IUNIT,STAT,' ')

      RETURN
      END

C**********************************************************************

      FUNCTION IEVEN(I)
      IEVEN=(I+1)/2*2
      RETURN
      END
C
C
C**********************************************************************
C


      SUBROUTINE PTADD(L,S,NPTS,PTBUF)

C        THIS ROUTINE WILL ADD THE NEW POINTS TO PTBUF OR SKIP THEM
C        IF THE ARE ALREADY RECORDED THERE.

C      IMPLICIT INTEGER (A-Z)
      IMPLICIT NONE
      INTEGER*2 PTBUF(3,4000)

      INTEGER*4 L,S,NPTS,D,J

      DO 90 J=1,NPTS
      D = IABS(L-PTBUF(2,J))
      IF(S .EQ. PTBUF(1,J) .AND. D .LE. 1) GO TO 100
   90 CONTINUE
      NPTS = NPTS + 1
      PTBUF(1,NPTS) = S
      PTBUF(2,NPTS) = L
  100 CONTINUE
C
      RETURN
      END
C
C
C**********************************************************************
C
      SUBROUTINE GETDN(NPTS)

C      IMPLICIT INTEGER (A-Z)
      IMPLICIT NONE
      COMMON/C/IUNIT,OUNIT,ICOD,HBL,HBH,FUNC,RADI
      COMMON /E/ PTBUF,SEGM,SORT
      COMMON /F/ LBUF,DBUG,NVERT,MINDN,MAXDN,PERC

      INTEGER OUNIT
      LOGICAL*1 LBUF(20000)
      INTEGER*2 PTBUF(3,4000),SEGM(3,2000),SORT(2,4000)

      INTEGER STAT

      INTEGER*4 NPTS,DBUG,E,EX,FUNC,HBH,HBL,I,ICOD
      INTEGER*4 IFP,ILP,IUNIT,J,L,MAXDN,MAXL,MINDN,MINL
      INTEGER*4 NONL,NP,NSS,NVERT,PERC,RADI,S,SAMP,SFP,SLP,SPT

      INTEGER*4 LINEIDX,SAMPIDX

C     Appropriate for little endian word order
      LINEIDX = 2
      SAMPIDX = 1

C        SORT HAS BEEN SORTED BY LINE THEN SAMP
      NP = 0
      SPT = 1
      MINL = SORT(LINEIDX,1)
      MAXL = SORT(LINEIDX,NPTS)
C
C        GET DNS ONE LINE AT A TIME
      DO 2000 L=MINL,MAXL
      NONL = 0
C
C        FIND NUMBER OF POINTS ON THIS LINE
      DO 1150 I=SPT,NPTS
      IF(SORT(LINEIDX,I) .NE. L) GO TO 1200
 1150 NONL = NONL + 1

C        IFP & ILP ARE ELEMENTS OF SORT WHICH ARE FIRST & LAST PTS ON LINE
 1200 IF(NONL .EQ. 0) GO TO 2000
      IFP = SPT
      ILP = IFP + NONL - 1
C-----SFP & SLP ARE SAMP # IN PIC OF FIRST AND LAST POINT ON LINE L
      SFP = SORT(SAMPIDX,IFP)
      SLP = SORT(SAMPIDX,ILP)
      NSS=SLP-SFP+1
      CALL XVREAD(OUNIT,LBUF,STAT,'LINE',L,'SAMP',SFP,'NSAMPS',NSS,' ')
C-----FOR EACH POINTS ON THIS LINE FILL PTBUF
      DO 1300 J=1,NONL
C-----S IS # WITHIN SORT OF THE JTH PT ON LINE
      S = IFP - 1 + J
C-----SAMP IS SAMP # OF J TH PT
      SAMP = SORT(SAMPIDX,S)
C-----E IS ELEMENT # WITHIN LINE BUFFER
      E = SAMP - SFP + 1
      EX = 2 * E - 1
      NP = NP + 1
      PTBUF(1,NP) = SAMP
      PTBUF(2,NP) = L
      IF(ICOD .EQ. 1) CALL MVE(3,1,LBUF(E),PTBUF(3,NP),1,1)
      IF(ICOD .EQ. 2) CALL MVE(2,1,LBUF(EX),PTBUF(3,NP),1,1)
 1300 CONTINUE
      SPT = SPT+NONL
 2000 CONTINUE
      IF(NP .NE. NPTS) CALL XVMESSAGE(' NO DNS READ NE NPTS',' ')
      RETURN

      END
C
C**********************************************************************
C
      SUBROUTINE HELP
      IMPLICIT NONE

      CALL XVMESSAGE(' KEYWORDS.............FUNCTION',' ')
      CALL XVMESSAGE(' ',' ')
      CALL XVMESSAGE(' ADD         *  ADD CONSTANT TO AREA',' ')
      CALL XVMESSAGE(' SUB  SUBT   *  SUBTRACT CONSTANT TO AREA',' ')
      CALL XVMESSAGE(' MUL  MULT   *  MULTPLY AREA BY CONSTANT',' ')
      CALL XVMESSAGE(' DIV  DIVI   *  DIVIDE AREA BY CONSTANT',' ')
      CALL XVMESSAGE(' ZERO        -  REPLACE AREA WITH ZEROES',' ')
      CALL XVMESSAGE(' SET  SETTO  +  REPLACE AREA WITH CONSTANT',' ')
      CALL XVMESSAGE(' STATS       -  CALC AVG, S.D., MIN/MAX DN ' //
     -                                            'OF AREA',' ')
      CALL XVMESSAGE(' COPY RESTOR -  RESTORE AREAS ORIGINAL CONDITION'
     -                                                 ,' ')
      CALL XVMESSAGE(' CIRC        +  COLLECT POINTS FOR RADIUS',' ')
      CALL XVMESSAGE(' INTERPOLATE -  FILL AREA WTH INTERPOLATED DNS',
     -                                                  ' ')
      CALL XVMESSAGE(' FIT  RANGE  ++ DN RANGE FOR DISPLAY OF HWD DATA'
     -                                                 ,' ')
      CALL XVMESSAGE(' RAW         -  NO STRETCH',' ')
      CALL XVMESSAGE(' ON          -  TURN VIDEO ON',' ')
      CALL XVMESSAGE(' OFF         -  TURN VIDEO OFF',' ')
      CALL XVMESSAGE(' LINE STRE   ++ DISP PICTURE WITH LINEAR STRETCH'
     -                                                 ,' ')
      CALL XVMESSAGE(' UP   U      +  MOVE DISPLAY WINDOW UP',' ')
      CALL XVMESSAGE(' DOWN D      +  MOVE DISPLAY WINDOW DOWN',' ')
      CALL XVMESSAGE(' LEFT L      +  MOVE DISPLAY WINDOW LEFT',' ')
      CALL XVMESSAGE(' RIGH R      +  MOVE DISPLAY WINDOW RIGHT',' ')
      CALL XVMESSAGE(' HOME        -  MOVE WINDOW TO UPPER LEFT CORNER'
     -                                                 ,' ')
      CALL XVMESSAGE(' MIN         +  MINIMUN DN USED IN INTERPOLATION'
     -                                                 ,' ')
      CALL XVMESSAGE(' MAX         +  MAXIMUM DN USED IN INTERPOLATION'
     -                                                 ,' ')
      CALL XVMESSAGE(' PERC        +  PRCNT BORDER PTS USED IN INTERP'
     -                                                 ,' ')
      CALL XVMESSAGE(' RADIUS      +  MAX DIST TO PTS USED IN INTERP'
     -                                                 ,' ')
      CALL XVMESSAGE(' RCUR        -  READ CURSOR POSITION',' ')
      CALL XVMESSAGE(' PCUR       ++  POSITION CURSOR TO PICTURE ' //
     -                                        'LOCATION',' ')
      CALL XVMESSAGE(' EXIT END    -  TERMINATE PROGRAM',' ')
      CALL XVMESSAGE(' DBUG        -  PRODUCE DBUG PRINT',' ')
      CALL XVMESSAGE(' @FILENAME   -  EXECUTE COMMANDS FOUND IN FILE'
     -                                                 ,' ')
      CALL XVMESSAGE(' ',' ')
      CALL XVMESSAGE(' -     REQUIRES NO PARAMETERS',' ')
      CALL XVMESSAGE(' *     REQUIRES ONE REAL PARAMETER',' ')
      CALL XVMESSAGE(' +     REQUIRES ONE INTEGER PARAMETER',' ')
      CALL XVMESSAGE(' ++    REQUIRES TWO INTEGER PARAMETERS',' ')
      RETURN
      END
C
C
C**********************************************************************
C
      SUBROUTINE CIRCLE(RAD,NSEG,NPTS,FUNC,*)
      IMPLICIT NONE

      INCLUDE 'fortport'
      COMMON /D/ NL,NS,NLDS,NSDS
      COMMON /E/ PTBUF,SEGM,SORT
      COMMON /G/ SL, SS
      COMMON /H/ DUNIT

      CHARACTER*100 MSG
      INTEGER SL,SS
      INTEGER*2 PTBUF(3,4000),SEGM(3,2000),SORT(2,4000)
      INTEGER X(2000),Y(2000)
      INTEGER RAD,STL,EL,FL,DL,NSEG,LL,LS,LC,SC
      INTEGER XDCLOCATION,XDIPOLYLINE,XDSGRAPH,XDGCOLOR
      INTEGER SECTION,PLANE
      LOGICAL*1 BDN
      INTEGER XDGLINIT

      INTEGER*4 NPTS,FUNC,DN,DUNIT,IERR,II,L,NL
      INTEGER*4 NLDS,NN,NNL,NS,NSDS,NVERT
      REAL*4 DS,DSQ

      INTEGER*4 LINEIDX,SAMPIDX

C     Appropriate for little endian word order
      LINEIDX = 2
      SAMPIDX = 1

C     CALL PRNT(4,1,RAD,'RADIUS =.')
      WRITE(MSG,201) RAD
201   FORMAT(' RADIUS = ', I8)
      CALL XVMESSAGE(MSG,' ')
      IERR = XDCLOCATION(DUNIT,1,SC,LC)
      STL = LC - RAD
      EL = LC + RAD
      NNL = EL - STL + 1
      FL = STL - 1
      DL = STL - LC - 1
      LL = MIN0((SL+512-1),NL)
      LS = MIN0((SS+512-1),NS)

      DO L = 1, NNL
        FL = FL + 1
        DL = DL + 1
        DSQ = RAD*RAD - DL*DL
        DS = SQRT(DSQ)
        SEGM(1,L) = FL + SL - 1
        SEGM(2,L) = INT(SC-DS+.5) + SS - 1
        SEGM(3,L) = INT(SC+DS+.5) + SS - 1
        IF (SEGM(1,L).LT.SL+1 .OR. SEGM(1,L).GT.LL-1 .OR. 
     +      SEGM(2,L).LT.SS+1 .OR. SEGM(3,L).GT.LS-1) THEN
           CALL XVMESSAGE(
     - ' CIRCLE IS TOO CLOSE TO EDGE OR OFF DISPLAY',' ')
           CALL XVMESSAGE(' TRY AGAIN',' ')
           RETURN1
        END IF
C        CALL PRNT(2,3,SEGM(1,L),' L,SS,ES =.')
      END DO
      NSEG = NNL
C         Print on graphics screen
      DO II = 1, NSEG
        X(II) = SEGM(2,II) - SS + 1
        Y(II) = SEGM(1,II) - SL + 1
        X(NSEG*2-(II-1)) = SEGM(3,II) - SS + 1
        Y(NSEG*2-(II-1)) = SEGM(1,II) - SL + 1
      END DO
      X(NSEG*2+1) = X(1)
      Y(NSEG*2+1) = Y(1)
      NN = NNL*2+1
      CALL XDDINFO(DUNIT, 35, 1, SECTION)
      IERR = XDGLINIT(DUNIT,SECTION)
      DN = XDGCOLOR(DUNIT,'WHITE')
      PLANE = XDSGRAPH(DUNIT)
      BDN = INT2BYTE(DN)
      IERR = XDIPOLYLINE(DUNIT,PLANE,BDN,NN,X,Y)
      NVERT = 2*NNL
C         IF INTERPOLATION, COLECT PTBUF
      IF (FUNC .EQ. 0) THEN
        NPTS = 1
        DO II = SEGM(2,1),SEGM(3,1)
          SORT(SAMPIDX,NPTS) = II
          SORT(LINEIDX,NPTS) = SEGM(1,1) - 1
          NPTS = NPTS + 1
        END DO
        DO II = 1, NSEG
          SORT(SAMPIDX,NPTS) = SEGM(2,II) - 1
          SORT(LINEIDX,NPTS) = SEGM(1,II)
          SORT(SAMPIDX,NPTS+1) = SEGM(2,II)
          SORT(LINEIDX,NPTS+1) = SEGM(1,II)
          SORT(SAMPIDX,NPTS+2) = SEGM(3,II)
          SORT(LINEIDX,NPTS+2) = SEGM(1,II)
          SORT(SAMPIDX,NPTS+3) = SEGM(3,II) + 1
          SORT(LINEIDX,NPTS+3) = SEGM(1,II)
          NPTS = NPTS + 4
        END DO
        DO II = SEGM(2,NSEG),SEGM(3,NSEG)
          SORT(SAMPIDX,NPTS) = II
          SORT(LINEIDX,NPTS) = SEGM(1,NSEG) + 1
          NPTS = NPTS + 1
        END DO
        NPTS = NPTS - 1
        CALL GETDN(NPTS)
      END IF
      RETURN
      END
C************************************************************************

 

           
