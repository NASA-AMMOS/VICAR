C
C  PROGRAM FFT11  --  1-D FAST FOURIER TRANSFORM
C
C  03 APR 85   ...LWK...   WRITTEN TO PROVIDE NON-AP EQUIVALENT OF FFT1
C  03 MAY 93   ...JFM...   MADE PORTABLE, CALL TO RCSFFT REPLACED BY CALL
C			   TO DFFT (renamed ported version of RCSFFT).
C
	INCLUDE 'VICMAIN_FOR'
	SUBROUTINE MAIN44

	IMPLICIT INTEGER (A-Z)
	COMMON/PASS/ SL, SS, NLO, NSO, NLI, NSI, IUN, EXT, CMP, ODD,
     .   INT
	LOGICAL XVPTST, EXT, FWD, CMP, ODD, INT
	CHARACTER*8 FMT
 	CHARACTER*50 STRING
	EXTERNAL FORWRD, INVERS

	FWD = .NOT.XVPTST( 'INVERSE')
	CMP = .FALSE.			! INITIALIZE
	ODD = .FALSE.
	INT = .FALSE.

	CALL XVUNIT( IUN, 'INP', 1, I, ' ')

	IF (FWD) THEN
	  CALL XVMESSAGE( 'FORWARD TRANSFORM',' ' )
	  CALL XVOPEN( IUN, I, 'OPEN_ACT', 'SA', 'IO_ACT', 'SA',
     .	   'U_FORMAT', 'REAL', ' ' )
	  CALL XVGET( IUN, I, 'FORMAT', FMT, ' ')
	  IF (FMT.EQ.'COMP'.OR.FMT.EQ.'COMPLEX') THEN
	    CALL XVCLOSE( IUN, I, ' ' )
	    CALL XVOPEN( IUN, I, 'OPEN_ACT', 'SA', 'IO_ACT', 
     .		'SA', ' ')
	    CMP = .TRUE.
	  ENDIF
          STRING(1:15) = 'INPUT FORMAT = '
	  STRING(16:) = FMT(1:)
	  CALL XVMESSAGE( STRING, ' ' )

	ELSE
	  CALL XVMESSAGE( 'INVERSE TRANSFORM', ' ' )
	  CALL XVOPEN( IUN, I, 'OPEN_ACT', 'SA', 'IO_ACT', 'SA', ' ')
	  CALL XVGET( IUN, I, 'FORMAT', FMT, ' ' )
	  IF (FMT.NE.'COMP'.AND.FMT.NE.'COMPLEX') THEN
	    CALL XVMESSAGE( ' ** FFT FORMAT IS NOT COMPLEX **', ' ')
	    CALL ABEND
	  ENDIF

	  CALL XVPARM( 'OFORM', FMT, I, J, 1, 0)
	  IF (FMT.EQ.'COMP'.OR.FMT.EQ.'COMPLEX') CMP = .TRUE.
	  IF (FMT.EQ.'BYTE' .OR. FMT.EQ.'HALF' .OR. FMT.EQ.'FULL')
     .	   INT = .TRUE.
	ENDIF

	CALL XVSIZE( SL, SS, NLO, NSO, NLI, NSI)
	IF (.NOT.FWD) THEN
	  IF (SS.NE.1 .OR. NSI.NE.NSO) THEN
	    CALL XVMESSAGE(' ** INVERSE TRANSFORM USES ENTIRE LINE **',
     .		' ' )
	    CALL ABEND
	  ENDIF
	  IF (NSI/2.NE.(NSI+1)/2 .AND. .NOT.CMP) THEN
	    CALL XVMESSAGE(' ** FFT OF REAL IMAGE MUST HAVE EVEN NS **',
     . 		' ' )
	    CALL ABEND
	  ENDIF
	ENDIF
	CALL PRNT( 4, 2, NLI, 'INPUT NL, NS = .')
	CALL PRNT( 4, 2, NLO, 'OUTPUT NL, NS = .')

	IF (.NOT.CMP .AND. NSO/2.NE.(NSO+1)/2) ODD = .TRUE.

	IF (SS-1+NSO .GT. NSI) THEN
	  NSI = NSI-SS+1		! # SAMPLES TO READ
	  IF (NSO-NSI.GT.1024) THEN
	    CALL XVMESSAGE(' ** EXTRAPOLATION BUFFER TOO SMALL **', ' ')
	    CALL ABEND
	  ENDIF
	  EXT = .TRUE.			! EXTRAPOLATION REQUIRED
	ENDIF

	BUFL = MAX0(NSO,NSI)*8+8
	IF (FWD) THEN
	  CALL STACKA ( 4, FORWRD, 1, BUFL, I)
	ELSE
	  CALL STACKA ( 5, INVERS, 1, BUFL, FMT, I)
	ENDIF

	RETURN
	END

C******************************************************************
	SUBROUTINE FORWRD( BUF, LEN)
C  PERFORM FORWARD FFT.

	IMPLICIT INTEGER (A-Z)
	CHARACTER*50 STRING
	REAL*4 BUF(LEN/4)
	LOGICAL EXT, CMP, ODD, REAL, INT
	COMMON/PASS/ SL, SS, NLO, NSO, NLI, NSI, IUN, EXT, CMP, ODD,
     .	 INT

	REAL = .NOT.(CMP.OR.ODD)

C  OPEN OUTPUT DATA SET:
	CALL XVUNIT( OUN, 'OUT', 1, I, ' ')
	CALL XVOPEN( OUN, I, 'OP', 'WRITE', 'OPEN_ACT', 'SA', 'IO_ACT',
     .	 'SA', 'U_NL', NLO, 'U_NS', NSO, 'O_FORMAT', 'COMP',
     .   'U_FORMAT', 'COMP', ' ')

C  INITIALIZE READS:
	CALL XVREAD( IUN, BUF, I, 'LINE', SL, 'SAMP', SS,
     .	 'NSAMPS', NSO, ' ' )

	N = NSO				! DIMENSION OF FFT
	IF (REAL) N = NSO/2

	DO L = 1,NLO

	  IF (REAL) THEN
	    IF (EXT) CALL EXTRPR( BUF, NSI, NSO)
	  ELSEIF (ODD) THEN			! FORM COMPLEX ELEMENTS
	    CALL MVE( 7, NSI, BUF(NSI), BUF(2*NSI-1), -2, -2)  ! REAL PARTS
	    CALL MVE( 7, NSI, 0., BUF(2), 0, 2)		! IMAGINARY PARTS
	    IF (EXT) CALL EXTRPC( BUF, NSI, NSO)
	  ELSE
	    IF (EXT) CALL EXTRPC( BUF, NSI, NSO)
	  ENDIF

C		PERFORM THE TRANSFORM:
	  CALL DFFT( BUF(1), BUF(2), N, N, N, 2, *901, *902)

	  IF (REAL) THEN
	    CALL REALTR( BUF(1), BUF(2), N, 2)
C		FILL THE REDUNDANT HALF:
	    CALL MVE( 7, (NSO-1)/2, BUF(3), BUF(2*NSO-1), 2, -2) ! REAL PARTS
	    CALL MVE( 7, (NSO-1)/2, BUF(4), BUF(2*NSO), 2, -2) ! IMAG'Y PARTS
	    CALL MULV( 7, (NSO-1)/2, -1.0, BUF(2*NSO), 0, -2) ! COMPLEX CONJ.
C  		CONVERT TO FFT1 FORMAT:  SCALE BY 0.5 
	    CALL MULV( 7, 2*NSO, 0.5, BUF, 0, 1)
	  ENDIF

	  IF (NSO/2 .EQ. (NSO+1)/2) THEN	! (ONLY IF EVEN)
C		TWITCH FOR FFT1 FORMAT:
	    BUF(NSO/2+1) = -BUF(NSO/2+1)
	    BUF(NSO/2+2) = -BUF(NSO/2+2)
	    BUF(NSO/2+NSO+1) = -BUF(NSO/2+NSO+1)
	    BUF(NSO/2+NSO+2) = -BUF(NSO/2+NSO+2)
	  ENDIF

C		FFT1 FORMAT: TAKE COMPLEX CONJUGATE
	  CALL MULV( 7, NSO, -1.0, BUF(2), 0, 2)
	  CALL XVWRIT( OUN, BUF, I, ' ' )

	  IF (L.LT.NLO) THEN
	    IF (SS.EQ.1 .AND. NSI.EQ.NSO) THEN
	      CALL XVREAD( IUN, BUF, I, ' ' )
	    ELSE
	      CALL XVREAD( IUN, BUF, I, 'SAMP', SS, 'NSAMPS',
     .	       NSO, ' ' )
	    ENDIF
	  ENDIF

	ENDDO

	RETURN
C
C     *** ERROR TERMINATION **

901	CALL XVMESSAGE(' A PRIME FACTOR OF NS EXCEEDS 23', ' ')
	CALL ABEND
902	STRING(1:44)=' TOO MANY SQUARE-FREE OR PRIME FACTORS IN NS'
	CALL XVMESSAGE(STRING, ' ')
	CALL ABEND
C
	END

C***************************************************************
	SUBROUTINE INVERS( BUF, LEN, FMT)
C  PERFORM INVERSE FFT.

	IMPLICIT INTEGER (A-Z)
	REAL*4 BUF(LEN/4), SCALE
	CHARACTER*8 FMT
	CHARACTER*50 STRING
	LOGICAL EXT, CMP, ODD, REAL, INT
	COMMON/PASS/ SL, SS, NLO, NSO, NLI, NSI, IUN, EXT, CMP, ODD,
     .	 INT

	REAL = .NOT.(CMP.OR.ODD)
	N = NSO

C  OPEN OUTPUT DATA SET:
	CALL XVUNIT( OUN, 'OUT', 1, I, ' ')
	IF (CMP) THEN
	  CALL XVOPEN( OUN, I, 'OP', 'WRITE', 'OPEN_ACT', 'SA',
     .	   'IO_ACT', 'SA', 'U_NL', NLO, 'U_NS', NSO, ' ')
	ELSE				! IMAGE IS TO BE REAL
	  CALL XVOPEN( OUN, I, 'OP', 'WRITE', 'OPEN_ACT', 'SA',
     .	   'IO_ACT', 'SA', 'U_NL', NLO, 'U_NS', NSO,
     .	   'U_FORMAT', 'REAL', 'O_FORMAT', FMT, ' ')
	  IF (.NOT.ODD) N = NSO/2
	ENDIF

	SCALE = 1./FLOAT(N)
	IF (REAL) SCALE = SCALE/4.

C  INITIALIZE READS:
	CALL XVREAD( IUN, BUF, I, 'LINE', SL, ' ')

	DO L = 1,NLO

C		CONVERT FROM FFT1 FORMAT: 
	  CALL MULV( 7, NSI, -1.0, BUF(2), 0, 2) ! TAKE COMPLEX CONJUGATE
	  IF (REAL) CALL MULV( 7, 2*NSI, 2.0, BUF, 0, 1)	! & SCALE BY 2.0
	  IF (NSO/2 .EQ. (NSO+1)/2) THEN	! (ONLY IF EVEN)
	    BUF(NSO/2+1) = -BUF(NSO/2+1)
	    BUF(NSO/2+2) = -BUF(NSO/2+2)
	    BUF(NSO/2+NSO+1) = -BUF(NSO/2+NSO+1)
	    BUF(NSO/2+NSO+2) = -BUF(NSO/2+NSO+2)
	  ENDIF

C		PERFORM THE TRANSFORM:
	  IF (REAL) CALL REALTR( BUF, BUF(2), N, -2)
	  CALL DFFT( BUF, BUF(2), N, N, N, -2, *901, *902)

	  IF (ODD) CALL MVE( 7, N-1, BUF(3), BUF(2), 2, 1) ! PACK REAL PARTS
	  CALL MULV( 7, 2*N, SCALE, BUF, 0, 1)	! APPLY SCALE FACTOR
	  IF (INT) CALL ADDV( 7, 2*N, 0.5, BUF, 0, 1)  ! ROUND UP

	  CALL XVWRIT( OUN, BUF, I, ' ')

	  IF (L.LT.NLO) CALL XVREAD( IUN, BUF, I, ' ')

	ENDDO

	RETURN
C
C     *** ERROR TERMINATION **

901	CALL XVMESSAGE(' A PRIME FACTOR OF NS EXCEEDS 23', ' ')
	CALL ABEND
902	STRING(1:44)=' TOO MANY SQUARE-FREE OR PRIME FACTORS IN NS'
	CALL XVMESSAGE(STRING, ' ')
	CALL ABEND
C
	END

C**************************************************************
	SUBROUTINE EXTRPC( BUF, NS, NT)
C
C   EXTRAPOLATE COMPLEX DATA WITH A COSINE FUNCTION

	IMPLICIT INTEGER (A-Z)
	REAL*4	ACOS(2048),D,THETA,AMPL,P1,P2,DC,A,PI/3.1415928/
	COMPLEX*8 BUF(1)

C  LOAD COSINE BUFFER
	D = PI/(NT-NS)
	NCOS = 2*(NT-NS)
	THETA = D
	DO J=1,NCOS
	  ACOS(J) = COS(THETA)
	  THETA = THETA+D
	ENDDO

C  PERFORM EXTRAPOLATION
	P1 = BUF(NS)
	P2 = BUF(1)
	AMPL = (P1-P2)*0.5
	JPHI = 0
	IF (P1.LT.P2) THEN
	  AMPL = -AMPL
	  JPHI = NT-NS
	ENDIF
	DC = (P1+P2)*0.5
	JTHETA = JPHI
	JFIRST = NS+1
	JLAST = NT 

	DO J=JFIRST,JLAST
	  JTHETA = JTHETA+1
	  A = AMPL*ACOS(JTHETA)+DC
	  BUF(J) = CMPLX(A,0.0)
	ENDDO

	RETURN
	END

C*************************************************************
	SUBROUTINE EXTRPR( BUF, NS, NT)
C
C   EXTRAPOLATE REAL DATA WITH A COSINE FUNCTION

	IMPLICIT INTEGER (A-Z)
	REAL*4	ACOS(2048),D,THETA,AMPL,P1,P2,DC,PI/3.1415928/
	REAL*4  BUF(1)

C  LOAD COSINE BUFFER
	D = PI/(NT-NS)
	NCOS = 2*(NT-NS)
	THETA = D
	DO J=1,NCOS
	  ACOS(J) = COS(THETA)
	  THETA = THETA+D
	ENDDO

C  PERFORM EXTRAPOLATION
	P1 = BUF(NS)
	P2 = BUF(1)
	AMPL = (P1-P2)*0.5
	JPHI = 0
	IF (P1.LT.P2) THEN
	  AMPL = -AMPL
	  JPHI = NT-NS
	ENDIF
	DC= (P1+P2)*0.5
	JTHETA = JPHI
	JFIRST = NS+1
	JLAST = NT 

	DO J=JFIRST,JLAST
	  JTHETA = JTHETA+1
	  BUF(J) = AMPL*ACOS(JTHETA)+DC
	ENDDO

	RETURN
	END
