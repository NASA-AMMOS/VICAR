	INCLUDE 'VICMAIN_FOR'
	SUBROUTINE MAIN44
C
C	CLUSAN  - CLUSTERING USING SIMULATED ANNEALING
C
C
C	REVISION:  A		NEW
C
C	ALGORITHM DESIGNER AND PROGRAMMER:  FRANK EVANS   DECEMBER 1985

C  6-APR-87  ...lwk... added LINC/SINC, THRESH parameters, fixed use of SS,NS
c  5-SEPT-94  Ported to Unix CRS (CRI)
C 23-MAR-01  ...rea... fixed bug in TEMP parameter (xvp returns real*4 value in
C                      real*8 variable)
C 05-FEB-10  ...lwk... replaced ENCODE statement with internal write

	IMPLICIT NONE
	INTEGER	MAXNPNTS,MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)	! maximum number of data points
	PARAMETER (MAXNCLUS = 100)	! maximum number of clusters
	INTEGER	UNIT, STATUS, COUNT,DEF ! Vicar I/O and parameter call stuff
	INTEGER	SL,SS,NL,NS,NLI,NSI 	! Vicar standard (NOT QUITE -- lwk)
	INTEGER	NSB			! number of samps per band in MSS image
	INTEGER	NPNTS			! number of points (object) to cluster
	INTEGER	NDIM			! number of dimensions (variables)
	INTEGER	NCLUS			! current number of clusters
	INTEGER	LINE,SAMP,  N,M, C, I	! counters
	INTEGER	MSS			! number of MSS bands in image
	INTEGER	NCYCLE			! number of temp cycles to do
	INTEGER	NITER			! number of iterations per temp cycle
	INTEGER	NCLUSWANT		! number of clusters desired
	INTEGER	MINNCLUS,MAXCLUS	! min and max number of clusters
	INTEGER	MINSIZE			! min number of objects in clusters
	INTEGER TRIES
	INTEGER	NCHANGE, NCYCSTOP
	INTEGER	SEED,   RECSIZ
	INTEGER	CYCLE, ITER		! current temp cycle and iteration
	INTEGER	OBJECT, TOCLUS, ORIGCLUS
	INTEGER	CLUS1,CLUS2, NUMT
	INTEGER	SPLTCLUS,SPLTVAR
	REAL*8	DISTFUNC, DIST, MINDIST, MINCLUS ! for finding closest clusters
	REAL*8	TEMP,TEMP0,TEMPFAC
	REAL*8	LUMPFRAC,SPLITFRAC	! how often to try to lump and split
	REAL	NCLUSFAC,NCLUSPAR(2),TEMPX
	REAL*8	ENERGY,NEWENERGY, DELTAE
	REAL*8	BOLTZ, AVGENERGY,MINENERGY
	LOGICAL	XVPTST, RESTART
C
	INTEGER	BANDS(12)		! the bands (variables) to cluster
	INTEGER	CLUS(MAXNPNTS)		! the cluster number for each object
	INTEGER NUMBER(MAXNCLUS)	! the number of objects in each cluster
	REAL*8	MEAN(12,MAXNCLUS)	! the cluster mean vectors
	REAL*8	COV(12,12,MAXNCLUS)	! the cluster covariance matrices
	REAL*8	DATA(12,MAXNPNTS)	! each object's values in all dims
	REAL*8	VARMEAN(12)		! the mean over all obj for each dim
	REAL*8	VARSTD(12)		! the std dev over all obj for each dim
	REAL*8	VARDATA(12)		! the variance over all for each dim
	REAL*8	SUM(12,MAXNCLUS)	! the sum of all objs in each cluster
	REAL*8	SUMSQ(12,MAXNCLUS)	! the sum of squares of all obj in clus
	REAL*8	PI(12,MAXNCLUS)		! the variance in each dim for all clus
	REAL*8	SUMPI(12)		! the sum of all cluster variances
C
        REAL	RANNUM
	REAL	BUFFER(60000)
	REAL	REALBUF(100)
	INTEGER	INTBUF(100)
	CHARACTER*8  CLASNAM
	CHARACTER*32 INFORMAT
	CHARACTER*80	STRING

	EQUIVALENCE (REALBUF,INTBUF) , (CLASNAM,INTBUF)

C
C  ADDED BY LWK:
	INTEGER INCR,LINC,SINC,NLO,NSO,NSBO,NS0,LINE0, THRESHDEF
	REAL THRESH
	INTEGER NUMPLIN(10000)

C	DATA	RNDOFF/1000000./
	DATA	MINENERGY/-.0000005/
C
C  'NUMPLIN' KEEPS TRACK OF HOW MANY POINTS LIE ABOVE 'THRESH' ON EACH LINE,
C  IS NEEDED ONLY TO KEEP THE STRUCTURE OF THE CLUSTER DATASET OUTPUT SOMEWHAT 
C  SIMILAR TO THAT OF THE INPUT.  IT IMPOSES A RESTRICTION ON # LINES OF THE
C  INPUT THAT ARE USED.
	

	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM

C		GET THE INPUT PARAMETERS
        CALL IFMESSAGE('CLUSAN (double precision) vers. 2016-11-15')
	RESTART = XVPTST('RESTART')

	CALL XVP('MSS',MSS,COUNT)		! number of bands in image
	CALL XVPARM('BANDS',BANDS,NDIM,DEF,12)	! which bands to use
	IF (NDIM.EQ.0)  THEN
	  NDIM = MSS
	  IF (RESTART) NDIM = NDIM-1
	  DO N = 1,NDIM
	    BANDS(N) = N
	  ENDDO
	ENDIF


C		OPEN THE IMAGE DATA FILE AND GET THE SIZE PARAMETERS
	CALL XVUNIT(UNIT,'INP',1,STATUS,' ')
	CALL XVOPEN(UNIT,STATUS, 'IO_ACT','SA','OPEN_ACT','SA',
     +		'U_FORMAT','REAL',' ')
	CALL XVGET(UNIT,STATUS, 'FORMAT',INFORMAT,'NS',NS,' ')
	CALL XVSIZE(SL,SS,NL,NS0,NLI,NSI) 
c        !note NS0 is user-specified maximum to use
	IF (NS0.EQ.NS) NS0 = NS/MSS

C  LINE/SAMP INCREMENTS
	CALL XVPARM( 'INCR', INCR, COUNT, DEF,1)
	IF (DEF .EQ. 1) THEN
	  CALL XVPARM( 'LINC', LINC, COUNT, DEF,1)
	  CALL XVPARM( 'SINC', SINC, COUNT, DEF,1)
	ELSE
	  LINC = INCR
	  SINC = INCR
	ENDIF
C  THRESH:
	CALL XVPARM( 'THRESH', THRESH, COUNT, THRESHDEF,1)

C		READ IN THE DATA POINTS INTO DATA(DIM,PNT) FROM THE IMAGE 
	NSB = NS/MSS		! number of samples per band in image
	NPNTS = 0
	LINE0 = 0
	DO LINE=1,NL,LINC
	    LINE0 = LINE0+1
	    CALL XVREAD(UNIT,BUFFER,STATUS,'SAMP',1,'NSAMPS',NS,
     +			'LINE',LINE+SL-1,' ')
	    NUMPLIN(LINE0) = 0
	    DO SAMP = SS,NS0,SINC
		IF (THRESHDEF .EQ. 0) THEN
		  DO N = 1,NDIM
		    IF (BUFFER(SAMP+(BANDS(N)-1)*NSB).LT.THRESH) GO TO 100
		  ENDDO
		ENDIF
		NPNTS = NPNTS + 1
		IF (NPNTS .GT. MAXNPNTS) THEN
		    CALL xvmessage(
     +                'MAXIMUM NUMBER OF DATA POINTS EXCEEDED',' ')
		    CALL ABEND
		ENDIF
		NUMPLIN(LINE0) = NUMPLIN(LINE0)+1
		DO N = 1,NDIM
		    DATA(N,NPNTS) = BUFFER(SAMP+(BANDS(N)-1)*NSB)
		ENDDO
C		   if restarting then also get which cluster point was in
		IF (RESTART)  CLUS(NPNTS) = NINT(BUFFER(SAMP+(MSS-1)*NSB))
100		CONTINUE
	    ENDDO
	ENDDO
	CALL XVCLOSE(UNIT,STATUS,' ')
	WRITE (STRING,101), 'NUMBER OF POINTS: ', NPNTS
101	FORMAT (A,I6)
	CALL NPRINT(STRING)
	IF (NPNTS.LE.0) CALL MABEND(' NO POINTS FOUND!')


C		FIND THE MEAN AND VARIANCE IN EACH DIMENSION
	DO N = 1,NDIM
	    VARMEAN(N) = 0.0
	    VARSTD(N) = 0.0	
	    DO I = 1,NPNTS
		VARMEAN(N) = VARMEAN(N) + DATA(N,I)
		VARSTD(N) = VARSTD(N) + DATA(N,I)**2
	    ENDDO
	    VARMEAN(N) = VARMEAN(N)/NPNTS
	    VARDATA(N) = (VARSTD(N) - NPNTS*VARMEAN(N)**2)/(NPNTS-1)
	    VARSTD(N) = DSQRT(VARDATA(N))
	    WRITE (STRING,103),'VARIABLE: ', N, 
     +			'   MEAN: ', VARMEAN(N), '   STD: ', VARSTD(N)
103	    FORMAT (A,I2,A,E11.3,A,E11.3)
	    CALL NPRINT(STRING)
	ENDDO
	CALL XVMESSAGE(' ',' ')



C		GET THE NUMBER OF CLUSTERS DESIRED
	CALL XVP('NCLUS',NCLUSPAR,COUNT)
	MINNCLUS = 2
	MAXCLUS = MAXNCLUS
	NCLUSWANT = NINT(NCLUSPAR(1))
	NCLUSFAC = 0.05/NCLUSPAR(2)**2	 ! set up the parabolic energy constant
	NCLUS = NCLUSWANT

	MINSIZE = 3



	IF (.NOT. RESTART) THEN
C	  START WITH NCLUS RANDOMLY PICKED CLUSTERS

	    TRIES = 0
120	    TRIES = TRIES + 1
	    IF (TRIES .GT. 5) CALL MABEND('CAN NOT MAKE ENOUGH CLUSTERS')
C	    SEED = 3923*SECNDS(0.0)	! seed the random number generator
C	    SEED = 3923*GET_SECONDS()   ! Portable version of SECNDS
C    the following is used during portablity testing:
	    SEED = 3923*(25*TRIES)      ! pick NCLUS objects at random
            DO C = 1,NCLUS
                CALL RANGEN(SEED,RANNUM)
                OBJECT = NPNTS*RANNUM + 1
	        DO N = 1,NDIM			! use their location for
	 	    MEAN(N,C) = DATA(N,OBJECT)	!  the seeds for the clusters
	        ENDDO
		NUMBER(C) = 0
	    ENDDO
C		ASSIGN ALL OF THE OBJECTS TO THEIR CLOSEST CLUSTER
	    DO I = 1,NPNTS
	        MINDIST = 1.0E20
	        DO C = 1,NCLUS
		    DIST = DISTFUNC(DATA(1,I),MEAN(1,C))
		    IF (DIST .LT. MINDIST) THEN
		        MINDIST = DIST
		        MINCLUS = C
		    ENDIF
	        ENDDO
	        CLUS(I) = MINCLUS
	        NUMBER(MINCLUS) = NUMBER(MINCLUS) + 1
	    ENDDO
C		MAKE SURE THE CLUSTERS HAVE ENOUGH MEMBERS, OTHERWISE GO BACK
	    DO C = 1,NCLUS
	        IF (NUMBER(C) .LT. MINSIZE) GOTO 120
	    ENDDO
	ENDIF

	CALL XVP('NCYCLE',NCYCLE,COUNT)
	IF (COUNT.EQ.0) NCYCLE = 100
	CALL XVPARM('NITER',NITER,COUNT,DEF,1)
	IF (DEF .EQ. 1) NITER = 4*NPNTS


C		CALCULATE THE STARTING ENERGY AND 
C		    SET UP ALL OF THE INTERMEDIATE CALCULATIONS
	CALL CALC(ENERGY)


C		SET UP CONTROL CONSTANTS

	CALL XVP('TEMP',TEMPX,COUNT)	! get the initial temperature
	IF (COUNT.EQ.0) TEMPX = 0.20
	TEMP0 = TEMPX/NPNTS		! internal temps are per object
	TEMPFAC = 3.0/NCYCLE		! set up the cooling rate

	LUMPFRAC = 4./NPNTS		! how often we try to lump
	SPLITFRAC = 4./NPNTS		! how often we try to split
	NCYCSTOP = 0
	AVGENERGY = ENERGY


	WRITE (STRING,121),'   ENERGY',ENERGY, '   TEMP',TEMP0*NPNTS
	CALL NPRINT (STRING)

C		CYCLE THROUGH THE COOLING CYCLES
	DO CYCLE = 1,NCYCLE
	    WRITE (STRING,117),'CYCLE: ',CYCLE
117	    FORMAT (A,I3)
	    CALL NPRINT (STRING)

	    TEMP = TEMP0 * DEXP(-TEMPFAC*(CYCLE-1))	! lower the temp

	    NCHANGE = 0
C		DO NITER ITERATIONS PER TEMP CYCLE
	    DO ITER = 1,NITER

C		EVERY SO OFTEN TRY LUMPING SOME CLUSTERS
		CALL RANGEN(SEED,RANNUM)
		IF (RANNUM .LT. LUMPFRAC .AND. NCLUS.GT.MINNCLUS) THEN
		    CALL NEWLUMP(CLUS1,CLUS2,NEWENERGY)
		    DELTAE = NEWENERGY - ENERGY
		    IF (DELTAE .LE. MINENERGY) THEN
		        CALL LUMP(CLUS1,CLUS2,ENERGY)
		    ELSE
			NUMT = NUMBER(CLUS1)+NUMBER(CLUS2)
		        BOLTZ = EXP(-DELTAE/(TEMP*NUMT))
			CALL RANGEN(SEED,RANNUM)
		        IF (RANNUM .LT. BOLTZ) THEN
		 	    CALL LUMP(CLUS1,CLUS2,ENERGY)
		        ENDIF
		    ENDIF
		ENDIF

C		EVERY SO OFTEN TRY SPLITTING SOME CLUSTERS
		CALL RANGEN(SEED,RANNUM)
		IF (RANNUM .LT. SPLITFRAC .AND. NCLUS.LT.MAXCLUS) THEN
		    CALL NEWSPLIT(SPLTCLUS,SPLTVAR,NEWENERGY)
		    DELTAE = NEWENERGY - ENERGY
		    IF (DELTAE .LE. MINENERGY) THEN
			CALL SPLIT(SPLTCLUS,SPLTVAR,ENERGY)
		    ELSE
		        BOLTZ = EXP(-DELTAE/(TEMP*NUMBER(SPLTCLUS)))
			CALL RANGEN(SEED,RANNUM)
		        IF (RANNUM .LT. BOLTZ) THEN
			    CALL SPLIT(SPLTCLUS,SPLTVAR,ENERGY)
		        ENDIF
		    ENDIF
		ENDIF


C			PICK AN OBJECT AT RANDOM
220		CONTINUE
		    CALL RANGEN(SEED,RANNUM)
		    OBJECT = NPNTS*RANNUM + 1
		    ORIGCLUS = CLUS(OBJECT)
		IF (NUMBER(ORIGCLUS) .LE. MINSIZE) GOTO 220
C			RANDOMLY ASSIGN IT TO ANOTHER CLUSTER
230		CONTINUE
		    CALL RANGEN(SEED,RANNUM)
		    TOCLUS = NCLUS*RANNUM + 1
		IF (TOCLUS .EQ. ORIGCLUS) GOTO 230

C			CALCULATE THE CHANGE IN ENERGY
		CALL NEWE(OBJECT,TOCLUS,NEWENERGY)
		DELTAE = NEWENERGY - ENERGY
		IF (DELTAE .LE. MINENERGY) THEN		! if lower then accept 
		    CALL RECALC(OBJECT,TOCLUS,ENERGY)	! the change
		    NCHANGE = NCHANGE + 1
		ELSE
		    BOLTZ = EXP(-DELTAE/TEMP)
		    CALL RANGEN(SEED,RANNUM)
		    IF (RANNUM .LT. BOLTZ) THEN		! else sometimes accept
			CALL RECALC(OBJECT,TOCLUS,ENERGY)	! it anyway
			NCHANGE = NCHANGE + 1
		    ENDIF
		ENDIF

	    ENDDO

	    WRITE (STRING,119),'   CHANGES:',NCHANGE,
     +				 '   CLUSTERS:',NCLUS
	    CALL NPRINT (STRING)

	    WRITE (STRING,121),'   ENERGY',ENERGY, '   TEMP',TEMP*NPNTS
	    CALL NPRINT (STRING)

C		IF THE ENERGY HASN'T CHANGED MUCH LATELY THEN STOP
	    IF (ABS(ENERGY-AVGENERGY) .LE. 0.005) THEN
		NCYCSTOP = NCYCSTOP + 1
		IF (NCYCSTOP .GE. 3 ) GOTO 290
	    ELSE
		NCYCSTOP = 0
	    ENDIF
	    AVGENERGY = 0.25*ENERGY + 0.75*AVGENERGY
	ENDDO

290	CONTINUE

119	FORMAT (A,I6,A,I3)
121	FORMAT (A,F9.5,A,F9.5)


C	DONE ANNEALING !



C		CALCULATE STUFF FOR OUTPUT

	DO C = 1,NCLUS			! zero the mean and covariance arrays
	    DO N = 1,NDIM
		MEAN(N,C) = 0.0
		DO M = 1,NDIM
		    COV(M,N,C) = 0.0
		ENDDO
	    ENDDO
	ENDDO
	DO I = 1,NPNTS			! calculate the cluster means
	    C = CLUS(I)
	    DO N = 1,NDIM
		MEAN(N,C) = MEAN(N,C) + DATA(N,I)
	    ENDDO
	ENDDO
	DO C = 1,NCLUS
	  DO N = 1,NDIM
	    MEAN(N,C) = MEAN(N,C)/NUMBER(C)
	  ENDDO
	ENDDO

	DO I = 1,NPNTS			! calculate the cluster covariances
	    C = CLUS(I)
	    DO N = 1,NDIM
	      DO M = 1,NDIM
	          COV(M,N,C)= COV(M,N,C)+(DATA(M,I)-MEAN(M,C))
     +				*(DATA(N,I)-MEAN(N,C))
		ENDDO
	    ENDDO
	ENDDO
	DO C = 1,NCLUS
	  DO N = 1,NDIM
	    DO M = 1,NDIM
	    COV(M,N,C) = COV(M,N,C)/(NUMBER(C)-1)
	    ENDDO
	  ENDDO
	ENDDO




C	OUTPUT THE STATISTICS DATASET

	CALL XVUNIT(UNIT,'OUT',1,STATUS,' ')
	RECSIZ = 2+NDIM+1+NDIM*(NDIM+1)/2
	CALL XVOPEN(UNIT,STATUS, 'U_NL',NCLUS, 'U_NS',RECSIZ,
     +	     'OP','WRITE', 'U_FORMAT','FULL', 'O_FORMAT','FULL',' ')

	DO C = 1,NCLUS			! for each cluster
c	    ENCODE(3,111,CLASNAM(6:8)) C	! 8 byte class name
	    ! encode not supported by new compiler, replace by:
	    write(clasnam(6:8),111) c
111	    FORMAT (I3)
	    CLASNAM(1:5) = 'CLASS'
	    INTBUF(3+NDIM) = NUMBER(C)		! number of objects in cluster
	    COUNT = 1
	    DO N = 1,NDIM
		REALBUF(2+N) = SNGL(MEAN(N,C))	! the means in each dim
		DO M = 1,N			! the upper triangular part of
		    REALBUF(3+NDIM+COUNT) = SNGL(COV(M,N,C))	! covariance matrix
		    COUNT = COUNT + 1			! by rows
		ENDDO
	    ENDDO
	    CALL XVWRIT(UNIT,INTBUF,STATUS,' ')	! one image line per cluster
	ENDDO
	CALL XVCLOSE(UNIT,STATUS,' ')

C	OUTPUT THE CLUSTER DATASET
C		CONTAINS THE NDIM COORDINATES AND THE CLUSTER NUMBER FOR
C		EACH DATA POINT (OBJECT) IN REAL MSS FORMAT WITH THE 
C		SAME NUMBER OF SAMPLES PER BAND AS IN THE INPUT IMAGE
	NLO = 1+(NL-SL)/LINC
	NSBO = 1+(NS0-SS)/SINC
	NSO = NSBO*(NDIM+1)
	CALL XVUNIT(UNIT,'OUT',2,STATUS,' ')
	CALL XVOPEN( UNIT, STATUS, 'U_NL',NLO, 'U_NS', NSO,
     +	    'OP','WRITE', 'U_FORMAT','REAL', 'O_FORMAT',INFORMAT,' ')

	I = 0
	DO LINE = 1,NLO
	    DO SAMP = 1,NSO
		BUFFER(SAMP) = 0.0
	    ENDDO
	    DO SAMP = 1,NUMPLIN(LINE)
		I = I + 1
		DO N = 1,NDIM
		    BUFFER(SAMP+(N-1)*NSBO) = SNGL(DATA(N,I))
		ENDDO
		BUFFER(SAMP+NDIM*NSBO) = FLOAT(CLUS(I))
	    ENDDO
	    CALL XVWRIT(UNIT,BUFFER,STATUS,' ')
	ENDDO
	CALL XVCLOSE(UNIT,STATUS,' ')

	RETURN
	END


	SUBROUTINE CALC(E)
C    CALC SETS UP THE INTERMEDIATE CALCULATED VALUES AND CALCULATES THE ENERGY
	IMPLICIT NONE
	INTEGER	MAXNPNTS, MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)
	PARAMETER (MAXNCLUS = 100)
	INTEGER	NDIM,NPNTS,NCLUS, N,I,C, NCLUSWANT
	INTEGER	NUMBER(MAXNCLUS), CLUS(MAXNPNTS)
	REAL*8	DATA(12,MAXNPNTS), VARDATA(12)
	REAL*8	SUM(12,MAXNCLUS), SUMSQ(12,MAXNCLUS)
	REAL*8	PI(12,MAXNCLUS), SUMPI(12)
	REAL*8	E
	REAL	NCLUSFAC
	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM

	DO C = 1,NCLUS
	    NUMBER(C) = 0
	    DO N = 1,NDIM
		SUM(N,C) = 0.0
		SUMSQ(N,C) = 0.0
	    ENDDO
	ENDDO
	DO N = 1,NDIM
	    SUMPI(N) = 0.0
	ENDDO

C	CALCULATE THE SUM AND SUM OF SQUARES OF ALL OF THE OBJECTS IN EACH CLUS
	DO I = 1,NPNTS
	    C = CLUS(I)
	    NUMBER(C) = NUMBER(C) + 1
	    DO N = 1,NDIM
		SUM(N,C) = SUM(N,C) + DATA(N,I)
		SUMSQ(N,C) = SUMSQ(N,C) + DATA(N,I)**2
	    ENDDO
	ENDDO
C	CALCULATE THE VARIANCE IN EACH DIM FOR EACH CLUSTER 
C	    AND THE SUM OF THE CLUSTER VARIANCES
	DO C = 1,NCLUS
	    DO N = 1,NDIM
		PI(N,C) = SUMSQ(N,C) - SUM(N,C)**2/NUMBER(C)
		SUMPI(N) = SUMPI(N) + PI(N,C)
	    ENDDO
	ENDDO

C	NORMALIZE THE SUM OF VARIANCES IN EACH DIMENSION BY THE TOTAL
C	    VARIANCE OF ALL OF THE DATA IN THAT DIM
C	    AND SUM OVER ALL THE DIMENSIONS
	E = 0.0
	DO N = 1,NDIM
	    E = E + SUMPI(N)/VARDATA(N)
	ENDDO

C	NORMALIZE THE ENERGY ACCORDING TO THE NUMBER OF OBJECTS, THE NUMBER
C	    OF DIMENSIONS AND THE NUMBER OF CLUSTERS SO THAT IT IS
C	    OF ORDER 1 AND IS INDEPENDENT OF THESE QUANTITIES.
C	  ADD IN THE PARABOLIC ENERGY FACTOR FOR THE DESIRED NUMBER OF CLUSTERS
	E = NCLUS**(2./NDIM)* E/(NPNTS*NDIM)
     +		 + NCLUSFAC*(NCLUS-NCLUSWANT)**2

	RETURN
	END



	SUBROUTINE RECALC(OBJECT,TO,E)
C    RECALC MOVES OBJECT TO CLUSTER TO AND RECALCULATES THE INTERMEDIATE
C	VALUES AND THE NEW ENERGY
C	USES THE INTERMEDIATE VALUES TO MINIMIZE THE NUMBER OF CALCULATIONS
C	  REQUIRED TO CALCULATE THE NEW ENERGY
	IMPLICIT NONE
	INTEGER	MAXNPNTS, MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)
	PARAMETER (MAXNCLUS = 100)
	INTEGER	OBJECT,FROM,TO
	INTEGER	NDIM,NPNTS,NCLUS, N, NCLUSWANT
	INTEGER	NUMBER(MAXNCLUS), CLUS(MAXNPNTS)
	REAL*8	DATA(12,MAXNPNTS), VARDATA(12)
	REAL*8	SUM(12,MAXNCLUS), SUMSQ(12,MAXNCLUS)
	REAL*8	PI(12,MAXNCLUS), SUMPI(12)
	REAL*8	E
	REAL	NCLUSFAC
	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM

	IF (TO .GT. NCLUS)  NCLUS = TO
	FROM = CLUS(OBJECT)
	CLUS(OBJECT) = TO
	E = 0.0
	NUMBER(FROM) = NUMBER(FROM) - 1
	NUMBER(TO) = NUMBER(TO) + 1
	DO N = 1,NDIM
	    SUMPI(N) = SUMPI(N) - PI(N,FROM) - PI(N,TO)
	    SUM(N,FROM) = SUM(N,FROM) - DATA(N,OBJECT)
	    SUM(N,TO) = SUM(N,TO) + DATA(N,OBJECT)
	    SUMSQ(N,FROM) = SUMSQ(N,FROM) - DATA(N,OBJECT)**2
	    SUMSQ(N,TO) = SUMSQ(N,TO) + DATA(N,OBJECT)**2
	    PI(N,FROM) = SUMSQ(N,FROM) - SUM(N,FROM)**2/NUMBER(FROM)
	    PI(N,TO) = SUMSQ(N,TO) - SUM(N,TO)**2/NUMBER(TO)
	    SUMPI(N) = SUMPI(N) + PI(N,FROM) + PI(N,TO)

	    E = E + SUMPI(N)/VARDATA(N)
	ENDDO
	E = NCLUS**(2./NDIM)* E/(NPNTS*NDIM)
     +		 + NCLUSFAC*(NCLUS-NCLUSWANT)**2

	RETURN
	END

	SUBROUTINE NEWE(OBJECT,TO,E)
C    NEWE CALCULATES WHAT THE ENERGY WOULD BE IF OBJECT WAS MOVED TO
C	CLUSTER TO, BUT DOES NOT ACTUALLY MOVE THE OBJECT OR CHANGE
C	THE INTERMEDIATE VALUES
	IMPLICIT NONE
	INTEGER	MAXNPNTS, MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)
	PARAMETER (MAXNCLUS = 100)
	INTEGER	NUMF,NUMT
	REAL*8	X0,X2,SUMF,SUMT,SUMSQF,SUMSQT,PIF,PIT,SUMPI0
	INTEGER	OBJECT,FROM,TO
	INTEGER	NDIM,NPNTS,NCLUS, N, NCLUSWANT
	INTEGER	NUMBER(MAXNCLUS), CLUS(MAXNPNTS)
	REAL*8	DATA(12,MAXNPNTS), VARDATA(12)
	REAL*8	SUM(12,MAXNCLUS), SUMSQ(12,MAXNCLUS)
	REAL*8	PI(12,MAXNCLUS), SUMPI(12)
	REAL*8	E
	REAL	NCLUSFAC
	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM

	FROM = CLUS(OBJECT)
	E = 0.0
	NUMF = NUMBER(FROM) - 1
	NUMT = NUMBER(TO) + 1
	DO N = 1,NDIM
	    X0 = DATA(N,OBJECT)
	    SUMF = SUM(N,FROM) - X0
	    SUMT = SUM(N,TO) + X0
	    X2 = X0**2
	    SUMSQF = SUMSQ(N,FROM) - X2
	    SUMSQT = SUMSQ(N,TO) + X2
	    PIF = SUMSQF - SUMF**2/NUMF
	    PIT = SUMSQT - SUMT**2/NUMT
	    SUMPI0 = SUMPI(N) + PIF - PI(N,FROM) + PIT - PI(N,TO)
	    E = E + SUMPI0/VARDATA(N)
	ENDDO
	E = NCLUS**(2./NDIM)* E/(NPNTS*NDIM)
     +		 + NCLUSFAC*(NCLUS-NCLUSWANT)**2

	RETURN
	END


	SUBROUTINE LUMP(CLUS1,CLUS2,E)
C    LUMP LUMPS CLUS1 AND CLUS2 TOGETHER AND RECALCULATES EVERYTHING
	IMPLICIT NONE
	INTEGER	MAXNPNTS, MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)
	PARAMETER (MAXNCLUS = 100)
	INTEGER	CLUS1,CLUS2
	INTEGER	NDIM,NPNTS,NCLUS, N,I, NCLUSWANT
	INTEGER	NUMBER(MAXNCLUS), CLUS(MAXNPNTS)
	REAL*8	DATA(12,MAXNPNTS), VARDATA(12)
	REAL*8	SUM(12,MAXNCLUS), SUMSQ(12,MAXNCLUS)
	REAL*8	PI(12,MAXNCLUS), SUMPI(12)
	REAL*8	E
	REAL	NCLUSFAC
	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM


	NUMBER(CLUS1) = NUMBER(CLUS1) + NUMBER(CLUS2)
	DO N = 1,NDIM
	    SUM(N,CLUS1) = SUM(N,CLUS1) + SUM(N,CLUS2)
	    SUMSQ(N,CLUS1) = SUMSQ(N,CLUS1) + SUMSQ(N,CLUS2)
	    SUMPI(N) = SUMPI(N) - PI(N,CLUS1) - PI(N,CLUS2)
	    PI(N,CLUS1) = SUMSQ(N,CLUS1) - SUM(N,CLUS1)**2/NUMBER(CLUS1)
	    SUMPI(N) = SUMPI(N) + PI(N,CLUS1)
	ENDDO

	DO N = 1,NDIM
	    SUM(N,CLUS2) = SUM(N,NCLUS)
	    SUM(N,NCLUS) = 0.0
	    SUMSQ(N,CLUS2) = SUMSQ(N,NCLUS)
	    SUMSQ(N,NCLUS) = 0.0
	    PI(N,CLUS2) = PI(N,NCLUS)
	    PI(N,NCLUS) = 0.0
	ENDDO
	NUMBER(CLUS2) = NUMBER(NCLUS)
	NUMBER(NCLUS) = 0
	DO I = 1,NPNTS
	    IF (CLUS(I) .EQ. CLUS2)  CLUS(I) = CLUS1
	    IF (CLUS(I) .EQ. NCLUS)  CLUS(I) = CLUS2
	ENDDO
	NCLUS = NCLUS - 1
	E = 0.0
	DO N = 1,NDIM
	    E = E + SUMPI(N)/VARDATA(N)
	ENDDO
	E = NCLUS**(2./NDIM)* E/(NPNTS*NDIM)
     +		 + NCLUSFAC*(NCLUS-NCLUSWANT)**2

	RETURN
	END


	SUBROUTINE NEWLUMP(CLUS1,CLUS2,E)
C    NEWLUMP  CALCULATES WHICH CLUSTERS TO LUMP BASED ON THE MINIMUM
C	MAHALANOBIS DISTANCE BETWEEN CLUSTERS AND CALCULATES WHAT THE
C	NEW ENERGY WOULD BE, BUT DOES NOT ACTUALLY CHANGE ANYTHING
	IMPLICIT NONE
	INTEGER	MAXNPNTS, MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)
	PARAMETER (MAXNCLUS = 100)
	REAL*8	SUM0,SUMSQ0, PI0,SUMPI0
	REAL*8	MAHA,MINMAHA
	INTEGER	CLUS1,CLUS2, C1,C2,   NUM0
	INTEGER	NDIM,NPNTS,NCLUS, N, NCLUSWANT
	INTEGER	NUMBER(MAXNCLUS), CLUS(MAXNPNTS)
	REAL*8	DATA(12,MAXNPNTS), VARDATA(12)
	REAL*8	SUM(12,MAXNCLUS), SUMSQ(12,MAXNCLUS)
	REAL*8	PI(12,MAXNCLUS), SUMPI(12)
	REAL*8	E
	REAL	NCLUSFAC
	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM

	MINMAHA = 1.0E20
	DO C1 = 1,NCLUS-1
	    DO C2 = C1+1,NCLUS
		MAHA = 0.0
		DO N = 1,NDIM
		    MAHA = MAHA +
     +			 ( SUM(N,C1)/NUMBER(C1) - SUM(N,C2)/NUMBER(C2) )**2
     +			 /( (PI(N,C1) + PI(N,C2))/(NUMBER(C1)+NUMBER(C2)) )
		ENDDO
		IF (MAHA .LT. MINMAHA) THEN
		    MINMAHA = MAHA
		    CLUS1 = C1
		    CLUS2 = C2
		ENDIF
	    ENDDO
	ENDDO


	NUM0 = NUMBER(CLUS1) + NUMBER(CLUS2)
	E = 0.0
	DO N = 1,NDIM
	    SUM0 = SUM(N,CLUS1) + SUM(N,CLUS2)
	    SUMSQ0 = SUMSQ(N,CLUS1) + SUMSQ(N,CLUS2)
	    SUMPI0 = SUMPI(N) - PI(N,CLUS1) - PI(N,CLUS2)
	    PI0 = SUMSQ0 - SUM0**2/NUM0
	    SUMPI0 = SUMPI0 + PI0
	    E = E + SUMPI0/VARDATA(N)
	ENDDO
	E = (NCLUS-1)**(2./NDIM)* E/(NPNTS*NDIM)
     +		 + NCLUSFAC*(NCLUS-1 - NCLUSWANT)**2

	RETURN
	END


	SUBROUTINE SPLIT(SPLTCLUS,SPLTVAR,E)
C    SPLIT SPLITS CLUSTER SPLTCLUS ALONG THE SPLTVAR VARIABLE AND RECALCULATES
C	THE ENERGY AND EVERYTHING
	IMPLICIT NONE
	INTEGER	MAXNPNTS, MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)
	PARAMETER (MAXNCLUS = 100)
	INTEGER	SPLTCLUS,SPLTVAR
	INTEGER	NDIM,NPNTS,NCLUS, N,I, NCLUSWANT
	INTEGER	NUMBER(MAXNCLUS), CLUS(MAXNPNTS)
	REAL*8	DATA(12,MAXNPNTS), VARDATA(12)
	REAL*8	SUM(12,MAXNCLUS), SUMSQ(12,MAXNCLUS)
	REAL*8	PI(12,MAXNCLUS), SUMPI(12)
	REAL*8	E, SPLTMEAN
	REAL	NCLUSFAC
	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM

	NCLUS = NCLUS + 1
	SPLTMEAN = SUM(SPLTVAR,SPLTCLUS)/NUMBER(SPLTCLUS)
	DO I = 1,NPNTS
	    IF (CLUS(I) .EQ. SPLTCLUS) THEN
		IF (DATA(SPLTVAR,I) .LT. SPLTMEAN) THEN
		    CLUS(I) = NCLUS
		    NUMBER(SPLTCLUS) = NUMBER(SPLTCLUS) - 1
		    NUMBER(NCLUS) = NUMBER(NCLUS) + 1
		    DO N = 1,NDIM
			SUM(N,SPLTCLUS) = SUM(N,SPLTCLUS) - DATA(N,I)
			SUMSQ(N,SPLTCLUS) = SUMSQ(N,SPLTCLUS) - DATA(N,I)**2
			SUM(N,NCLUS) = SUM(N,NCLUS) + DATA(N,I)
			SUMSQ(N,NCLUS) = SUMSQ(N,NCLUS) + DATA(N,I)**2
		    ENDDO
		ENDIF
	    ENDIF
	ENDDO
	DO N = 1,NDIM
	    SUMPI(N) = SUMPI(N) - PI(N,SPLTCLUS)
	    PI(N,SPLTCLUS) = SUMSQ(N,SPLTCLUS)
     +			   - SUM(N,SPLTCLUS)**2/NUMBER(SPLTCLUS)
	    PI(N,NCLUS) = SUMSQ(N,NCLUS)
     +			 - SUM(N,NCLUS)**2/NUMBER(NCLUS)
	    SUMPI(N) = SUMPI(N) + PI(N,SPLTCLUS) + PI(N,NCLUS) 
	ENDDO

	E = 0.0
	DO N = 1,NDIM
	    E = E + SUMPI(N)/VARDATA(N)
	ENDDO
	E = NCLUS**(2./NDIM)* E/(NPNTS*NDIM)
     +		 + NCLUSFAC*(NCLUS-NCLUSWANT)**2

	RETURN
	END


	SUBROUTINE NEWSPLIT(SPLTCLUS,SPLTVAR,E)
C    NEWSPLIT DETERMINES WHICH CLUSTER TO SPLIT ACCORDING TO THE MAXIMUM
C	VARIANCE  AND CALCULATES WHAT THE NEW ENERGY WOULD BE
	IMPLICIT NONE
	INTEGER	MAXNPNTS, MAXNCLUS
	PARAMETER (MAXNPNTS = 50000)
	PARAMETER (MAXNCLUS = 100)
	REAL*8	SUM1(12),SUM2(12),SUMSQ1(12),SUMSQ2(12), SUMPI0, PI1,PI2
	INTEGER	NUM1,NUM2
	INTEGER	SPLTCLUS,SPLTVAR
	INTEGER	NDIM,NPNTS,NCLUS, N,I,C, NCLUSWANT
	INTEGER	NUMBER(MAXNCLUS), CLUS(MAXNPNTS)
	REAL*8	DATA(12,MAXNPNTS), VARDATA(12)
	REAL*8	SUM(12,MAXNCLUS), SUMSQ(12,MAXNCLUS)
	REAL*8	PI(12,MAXNCLUS), SUMPI(12)
	REAL*8	E, SPLTMEAN, CLUSVAR,MAXCLUSVAR
	REAL	NCLUSFAC
	COMMON	/CLUS/	NPNTS,NCLUS, VARDATA, DATA, NUMBER, CLUS,
     +		SUM,SUMSQ, PI, SUMPI, NCLUSWANT,NCLUSFAC
	COMMON  /CLUS1/ NDIM


	MAXCLUSVAR = -1.0E20
	DO C = 1,NCLUS
	    DO N = 1,NDIM
		CLUSVAR = PI(N,C)/VARDATA(N)
		IF (CLUSVAR .GT. MAXCLUSVAR) THEN
		    MAXCLUSVAR = CLUSVAR
		    SPLTCLUS = C
		    SPLTVAR = N
		ENDIF
	    ENDDO
	ENDDO

	NUM1 = 0
	NUM2 = 0
	DO N = 1,NDIM
	    SUM1(N) = 0
	    SUMSQ1(N) = 0
	    SUM2(N) = 0
	    SUMSQ2(N) = 0
	ENDDO
	SPLTMEAN = SUM(SPLTVAR,SPLTCLUS)/NUMBER(SPLTCLUS)
	DO I = 1,NPNTS
	    IF (CLUS(I) .EQ. SPLTCLUS) THEN
		IF (DATA(SPLTVAR,I) .LT. SPLTMEAN) THEN
		    NUM1 = NUM1 + 1
		    DO N = 1,NDIM
			SUM1(N) = SUM1(N) + DATA(N,I)
			SUMSQ1(N) = SUMSQ1(N) + DATA(N,I)**2
		    ENDDO
		ELSE
		    NUM2 = NUM2 + 1
		    DO N = 1,NDIM
			SUM2(N) = SUM2(N) + DATA(N,I)
			SUMSQ2(N) = SUMSQ2(N) + DATA(N,I)**2
		    ENDDO
		ENDIF
	    ENDIF
	ENDDO

	E = 0.0
	DO N = 1,NDIM
	    SUMPI0 = SUMPI(N) - PI(N,SPLTCLUS)
	    PI1 = SUMSQ1(N) - SUM1(N)**2/NUM1
	    PI2 = SUMSQ2(N) - SUM2(N)**2/NUM2
	    SUMPI0 = SUMPI0 + PI1 + PI2
	    E = E + SUMPI0/VARDATA(N)
	ENDDO
	E = (NCLUS+1)**(2./NDIM)* E/(NPNTS*NDIM)
     +		 + NCLUSFAC*(NCLUS+1 - NCLUSWANT)**2

	RETURN
	END


	REAL*8 FUNCTION DISTFUNC(X1,X2)
C    RETURNS EUCLIDEAN DISTANCE BETWEEN X1 AND X2
	IMPLICIT INTEGER (A-Z)
	REAL*8  X1(12),X2(12), D
	COMMON /CLUS1/ NDIM

	D = 0
	DO N = 1,NDIM
	    D = D + (X1(N)-X2(N))**2
	ENDDO
	DISTFUNC = SQRT(D)
	RETURN
	END


	SUBROUTINE NPRINT(STRING)
C    USES XVMESSAGE TO PRINT A STRING BUT DOES NOT PRINT THE EXTRA SPACES AT END
	IMPLICIT NONE
	CHARACTER*(*) STRING
	INTEGER	I

	I = LEN(STRING)
	DO WHILE (STRING(I:I) .EQ. ' ' .AND. I .GT. 0)
	    I = I - 1
	ENDDO

	CALL XVMESSAGE(STRING(1:I),' ')

	RETURN
	END
