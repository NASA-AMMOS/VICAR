C  PROGRAM GRAFIMG
C  6 MAR 1995  ...CRI...  MSTP S/W CONVERSION (VICAR PORTING)
	INCLUDE 'VICMAIN_FOR'
	SUBROUTINE MAIN44

	IMPLICIT NONE

	INTEGER	UNITIN
	INTEGER	SL, SS, NL, NS
	REAL BUFFER(1024), IMAGE(256,256), X, Y, Z
	REAL ZMINIMG, ZMAXIMG, ZMIN, ZMAX, LTICK, STICK, ZTICK
	REAL XSCALE, YSCALE, ZSCALE, ZTOP, ZBTM
	INTEGER	LINE, SAMP, STATUS, COUNT, NLI, NSI
        INTEGER WRGR, PUTGR,CLGR
        INTEGER SUBSAM, SUBLIN, GS, GL
        INTEGER GRIDL, GRIDS, TYPE, LINETK, SAMPTK, ZTK
	CHARACTER*3 ZTICKS
	CHARACTER*4 CUBE, LTICKS
	CHARACTER*5 MODE, STICKS
	LOGICAL MAKECUBE, COMB, FIT

	COMMON /OUTCOM/ XSCALE, YSCALE, ZSCALE, IMAGE

        CALL IFMESSAGE('GRAFIMG version 06-MAR-95')

C OPEN THE INPUT IMAGE FILE

	CALL XVUNIT (UNITIN, 'INP', 1, STATUS,' ')
	CALL XVOPEN (UNITIN,STATUS,'IO_ACT','SA','OPEN_ACT',
     +               'SA','U_FORMAT','REAL',' ')

C GET SOME INPUT PARAMETERS

	CALL XVSIZE (SL,SS,NL,NS,NLI,NSI)
        CALL XVP('ZMIN',ZMIN,COUNT)
        CALL XVP('ZMAX',ZMAX,COUNT)
        CALL XVP('ZTOP',ZTOP,COUNT)
        CALL XVP('ZBTM',ZBTM,COUNT)
        CALL XVP('SINC',SUBSAM,COUNT)
        CALL XVP('LINC',SUBLIN,COUNT)
        CALL XVP('LTICKINC',LTICK,COUNT)
        CALL XVP('STICKINC',STICK,COUNT)
        CALL XVP('ZTICKINC',ZTICK,COUNT)

C ARE WE GOING TO DRAW ANY TICK MARKS ?
C   LINE

	LINETK = 0
	CALL XVP ('LTICKS',LTICKS,COUNT)
	IF (LTICKS(1:3).EQ.'TOP') THEN
	    LINETK = 1
	ELSEIF (LTICKS(1:3).EQ.'BTM') THEN
	    LINETK = 2
	ELSEIF (LTICKS(1:4).EQ.'BOTH') THEN
	    LINETK = 3
	ENDIF

C   SAMPLE

	SAMPTK = 0
	CALL XVP ('STICKS',STICKS,COUNT)
	IF (STICKS(1:4).EQ.'LEFT') THEN
	    SAMPTK = 1
	ELSEIF (STICKS(1:5).EQ.'RIGHT') THEN
	    SAMPTK = 2
	ELSEIF (STICKS(1:4).EQ.'BOTH') THEN
	    SAMPTK = 3
	ENDIF

C   Z AXIS

	ZTK = 0
	CALL XVP ('ZTICKS',ZTICKS,COUNT)
	IF (ZTICKS(1:2).EQ.'TL') THEN
	    ZTK = 1
	ELSEIF (ZTICKS(1:2).EQ.'TR') THEN
	    ZTK = 2
	ELSEIF (ZTICKS(1:2).EQ.'BL') THEN
	    ZTK = 3
	ELSEIF (ZTICKS(1:2).EQ.'BR') THEN
	    ZTK = 4
	ELSEIF (ZTICKS(1:3).EQ.'ALL') THEN
	    ZTK = 5
	ENDIF

C FIND OUT IF WE ARE TO PUT A CUBE AROUND THE GRID

	FIT = .FALSE.
	MAKECUBE = .FALSE.
	CALL XVP ('CUBE',CUBE,COUNT)
	IF (CUBE(1:4).EQ.'CUBE') MAKECUBE = .TRUE.
	IF (CUBE(1:3).EQ.'FIT') THEN
	    MAKECUBE = .TRUE.
	    FIT = .TRUE.
	ENDIF

C NOW TEST TO MAKE SURE THAT NO GREATER THAN A 256 X 256 MESH IS USED

        GS = ( NS - 1 ) / SUBSAM + 1
        GL = ( NL - 1 ) / SUBLIN + 1

C RESET IF GREATER THAN A 256 X 256 MESH WAS REQUESTED

        IF( GS .GT. 256 ) THEN
	    SUBSAM = NS / 256  +  1
	    GS = ( NS - 1 ) / SUBSAM + 1
        ENDIF
        IF( GL .GT. 256 ) THEN
	    SUBLIN = NL / 256 +  1 
	    GL = ( NL - 1 ) / SUBLIN + 1
        ENDIF

C	IF (NS .GT. 256 .OR. NL .GT. 256)  CALL MABEND('REGION TOO LARGE')

	ZMINIMG=999999.
	ZMAXIMG=-999999.
	DO GRIDL = 1, GL 
            LINE = SL + (GRIDL - 1)*SUBLIN 
	    CALL XVREAD (UNITIN, BUFFER, STATUS, 
     +			'LINE',LINE, 'SAMP',SS, 'NSAMPS',NS,' ')
	    DO GRIDS = 1, GS
                SAMP = 1 + (GRIDS - 1)*SUBSAM 
		IMAGE(GRIDS,GRIDL) = BUFFER(SAMP)
		IF (IMAGE(GRIDS,GRIDL).LT.ZMINIMG) ZMINIMG=IMAGE(GRIDS,GRIDL)
		IF (IMAGE(GRIDS,GRIDL).GT.ZMAXIMG) ZMAXIMG=IMAGE(GRIDS,GRIDL)
	    ENDDO
	ENDDO

	CALL XVCLOSE (UNITIN, STATUS,' ')

	CALL XVP ('XSCALE', XSCALE, COUNT)
	CALL XVP ('YSCALE', YSCALE, COUNT)
	CALL XVP ('ZSCALE', ZSCALE, COUNT)

	TYPE = 1
	COMB = .FALSE.
	CALL XVP ('MODE',MODE,COUNT)
	IF (MODE(1:4).EQ.'BOTH') TYPE = 1
	IF (MODE(1:4).EQ.'XONL') TYPE = 2
	IF (MODE(1:4).EQ.'YONL') TYPE = 3
	IF (MODE(1:4).EQ.'PREV') TYPE = 4
	IF (MODE(1:4).EQ.'DOTS') TYPE = 5

C		Preview and dots
	IF (MODE(1:4).EQ.'PRDT') THEN
	    COMB = .TRUE.
	    TYPE = 5
	ENDIF

	STATUS = WRGR (1, 1, 3)
        IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	IF (TYPE.NE.4) THEN
	 IF ((TYPE.EQ.1).OR.(TYPE.EQ.2).OR.(TYPE.EQ.5)) THEN
	  DO LINE = 1, GL, 2
	    DO SAMP = 1, GS
	      IF((IMAGE(LINE,SAMP).LT.ZMIN).OR.
     +         (IMAGE(LINE,SAMP).GT.ZMAX))THEN
		    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
                    IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	      ELSE
		    CALL OUTGRAF (LINE, SAMP)
		    IF (TYPE.EQ.5) THEN
                      STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
                      IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
                    endif
	      ENDIF
	    ENDDO
	    STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    IF (LINE .LT. GL) THEN
	        DO SAMP = GS, 1, -1
	          IF((IMAGE(LINE,SAMP).LT.ZMIN).OR.
     +		     (IMAGE(LINE,SAMP).GT.ZMAX)) THEN
		    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
                    IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
		  ELSE
		    CALL OUTGRAF (LINE+1, SAMP)
		    IF (TYPE.EQ.5) THEN
                      STATUS = PUTGR (1, 0.0, 0.0, 0.0)
                      IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
                    endif
		  ENDIF
	        ENDDO
	        STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
                IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    ENDIF
	  ENDDO
	END IF

	IF (COMB) TYPE = 4	! Preview as well as dots

	IF ((TYPE.EQ.1).OR.(TYPE.EQ.3)) THEN
	  DO SAMP = 1, GS, 2
	    DO LINE = 1, GL
	        IF((IMAGE(LINE,SAMP).LT.ZMIN).OR.
     +		     (IMAGE(LINE,SAMP).GT.ZMAX)) THEN
		    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
                    IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
		ELSE
		    CALL OUTGRAF (LINE, SAMP)
		ENDIF
	    ENDDO
	    STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    IF (SAMP .LT. GS) THEN
	        DO LINE = GL, 1, -1
	          IF((IMAGE(LINE,SAMP).LT.ZMIN).OR.
     +		     (IMAGE(LINE,SAMP).GT.ZMAX)) THEN
		    STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
                    IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
		  ELSE
		    CALL OUTGRAF (LINE, SAMP+1)
		  ENDIF
	        ENDDO
	        STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
                IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    ENDIF
	  ENDDO
	 ENDIF
	ENDIF

C PREVIEW MODE (PROFILE AROUND EDGE OF GRID)

	IF (TYPE.EQ.4) THEN
C	  Left
	    SAMP = 1
	    DO LINE = 1, GL
	        IF((IMAGE(LINE,SAMP).LT.ZBTM).OR.
     +		     (IMAGE(LINE,SAMP).GT.ZTOP)) THEN
		    STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
                   IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
		ELSE
		    CALL OUTGRAF (LINE, SAMP)
		ENDIF
	    ENDDO
C	  Bottom
	    LINE = GL
	    DO SAMP = 1, GS
	        IF((IMAGE(LINE,SAMP).LT.ZBTM).OR.
     +		     (IMAGE(LINE,SAMP).GT.ZTOP)) THEN
		  STATUS = PUTGR (1, 0.0, 0.0, 0.0)
                  IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
		ELSE
		    CALL OUTGRAF (LINE, SAMP)
		ENDIF
	    ENDDO
C	  Right
	    SAMP = GS
	    DO LINE = GL, 1, -1
	        IF((IMAGE(LINE,SAMP).LT.ZBTM).OR.
     +		     (IMAGE(LINE,SAMP).GT.ZTOP)) THEN
		   STATUS = PUTGR (1, 0.0, 0.0, 0.0)
                   IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
		ELSE
		    CALL OUTGRAF (LINE, SAMP)
		ENDIF
	    ENDDO
C	  Top
	    LINE = 1
	    DO SAMP = GS, 1, -1
	        IF((IMAGE(LINE,SAMP).LT.ZBTM).OR.
     +		     (IMAGE(LINE,SAMP).GT.ZTOP)) THEN
		   STATUS = PUTGR (1, 0.0, 0.0, 0.0)
                   IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
		ELSE
		    CALL OUTGRAF (LINE, SAMP)
		ENDIF
	    ENDDO
	    STATUS =  PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	ENDIF

C PUT THE CUBE AROUND THE DATA

	IF (MAKECUBE) THEN

	    IF (FIT) THEN
		ZBTM = ZMINIMG
		ZTOP = ZMAXIMG
	    ENDIF
	    X = FLOAT(GS) * XSCALE
	    Y = FLOAT(GL) * YSCALE
	    ZBTM = ZBTM * ZSCALE
	    Z = ZSCALE * IMAGE(1,1)
	    STATUS = PUTGR (1, YSCALE, XSCALE, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, YSCALE, XSCALE, ZBTM)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
   	    STATUS = PUTGR (1, YSCALE, X, ZBTM)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    Z = ZSCALE * IMAGE(GL,1)
	    STATUS = PUTGR (1, YSCALE, X, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    STATUS = PUTGR (1, YSCALE, X, ZBTM)
	    IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
            STATUS = PUTGR (1, Y, X, ZBTM)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    Z = ZSCALE * IMAGE(GL,GS)
	    STATUS = PUTGR (1, Y, X, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    STATUS = PUTGR (1, Y, X, ZBTM)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, Y, XSCALE, ZBTM)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    Z = ZSCALE * IMAGE(1,GS)
	    STATUS = PUTGR (1, Y, XSCALE, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    STATUS =  PUTGR (1, Y, XSCALE, ZBTM)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, YSCALE, XSCALE, ZBTM)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	  IF (ZTOP.NE.0.0) THEN

	    Z = ZSCALE * IMAGE(1,1)
	    ZTOP = ZTOP * ZSCALE
	    STATUS = PUTGR (1, YSCALE, XSCALE, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, YSCALE, XSCALE, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, YSCALE, X, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    Z = ZSCALE * IMAGE(GL,1)
	    STATUS = PUTGR (1, YSCALE, X, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    STATUS =  PUTGR (1, YSCALE, X, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, Y, X, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    Z = ZSCALE * IMAGE(GL,GS)
	    STATUS =  PUTGR (1, Y, X, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    STATUS = PUTGR (1, Y, X, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, Y, XSCALE, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    Z = ZSCALE * IMAGE(1,GS)
	    STATUS =  PUTGR (1, Y, XSCALE, Z)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	    STATUS = PUTGR (1, Y, XSCALE, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, YSCALE, XSCALE, ZTOP)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    STATUS = PUTGR (1, 0.0, 0.0, 0.0)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	  ENDIF
	ENDIF

	STATUS = CLGR (1)
        IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	RETURN
	END

	SUBROUTINE OUTGRAF (LINE, SAMP)
	IMPLICIT NONE
	INTEGER	LINE, SAMP, PUTGR,status
	REAL	IMAGE(256,256)
	REAL	X, Y, Z, XSCALE, YSCALE, ZSCALE
	COMMON /OUTCOM/ XSCALE, YSCALE, ZSCALE, IMAGE

	X = XSCALE*FLOAT(SAMP)
	Y = YSCALE*FLOAT(LINE)
	Z = ZSCALE*IMAGE(SAMP,LINE)
        STATUS = PUTGR (1, Y, X, Z)
        IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	RETURN
	END
