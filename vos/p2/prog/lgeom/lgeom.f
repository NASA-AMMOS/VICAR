C                       LGEOM
C       28 APR 93  SP           Made portable for UNIX.  Changed code to use 
C                               BYTE2INT AND INT2BYTE for converting 
C                               between BYTE and INTEGER.  Gave control over
C                               progress messages to PRINT parameter.  Added
C                               PMEM parameter.  Changed call to STACKA so 
C                               GDIR and BDIR allocated in one chunk to insure
C                               they are contiguous.
C	07 JUL 92  HJF		CORRECT ERROR WITH 'NOIN WHEN R = IRMAX+.5
C				PROGRAM WAS USING LINE IRMAX+1 WHICH WAS NOT
C				IN MEMORY. CHANGED GSUB, GSUBH, GSUB1, GSUBH1
C				ALSO, ADDED NOIZ OPTION TO NOT INTERPOLATE
C				WHEN DN IS ZERO.
C
C	05 APR 91  HJF		USE STACKA TO ALLOCATE SPACE TO AVOID
C				EXCEEDING PAGE FILE QUOTA FOR SMALL QUOTAS
C				AND ALLOW USE OF LARGER WORKING SETS AND
C				PICTURE SIZES
C
C	08 NOV 90  HJF		USE WORKING SET EXTENT TO ALLOCATE SPACE.
C				ONE PASS VERSION WHEN ENTIRE INPUT PICTURE
C				FITS IN MEMORY
C
C	31 OCT 90  HJF		KEEP TRACK OF IDS BLOCK NUMBERS IN MEMORY.
C				READ IDS IN FORWARD DIRECTION TO IMPROVE
C				EXECUTION TIME.
C      
C      20 APR 90   ...SP...     INCREASED BUFFER SIZES TO ALLOW FOR LARGER
C                               IMAGES.  ADDED PRINT PARAMETER FOR PRINTING
C                               TIEPOINT VALUES AND PERIODIC PROGRESS MESSAGES.
C                               CHANGED FBI,CSD,PBN,MAXNB,NSAMP TO INTEGER*4.
C                               ADDED SOME FLOATs TO PREVENT INTEGER OVERFLOW.
C                               INCREASED NUMBER OF TIEPOINT RECTANGLES ALLOWED
C                               TO 40000.
C      14 OCT 88   ...SP...     CHANGED TO IGNORE FORMAT PARAMETER BECAUSE 
C                               VICAR2 USES ONLY THE FORMAT IN LABEL.
C                               CHANGED GSUB AND GSUBH TO SET NEXSAM FALSE
C                               IF NSAMP LE 0 TO ALLOW MAPTRANS POLECASE TO 
C                               WORK.
C      20 APR 88   ...SP...     CORRECTED ROUNDING FROM ADDING .5 TO USING NINT
C                               IN GSUBH.  THIS AFFECTS THE CASE OF NEGATIVE
C                               HALFWORD DNS.
C       1 SEP 87   ...SP...     CORRECTED CODE WHERE NSI USED INSTEAD OF NWI
C                               FOR NUMBER OF SAMPLES IN SUBROUTINE GSUBH.
C      31 JUL 87   ...FM...     MODIFIED HELP FILE TO GIVE CORRECT INFORMATION 
C                               ABOUT PARAMETERS "PDS" AND "PARMS".
C      14 MAY 87   ...SP...     CORRECTED AN INFREQUENT ROUNDING PROBLEM IN 
C                               GSUB AND GSUBH THAT LED TO AN OVERINDEXED ARRAY.
C                               (R WAS EQUAL TO RMAX AND RFRAC .GE. SMALL, BUT
C                                BIGBUF(IR+1) UNDEFINED.)
C                               ALSO CORRECTED CASE WHERE IP .EQ. NSI AND
C                               LBUF(INDEX+1) UNDEFINED.)
C      16 APR 87   ...SP...     CORRECTED THE COUNT OF RECTANGLES IN THE 
C                               TIEPOINT GRID BY SUBTRACTING 1.  THIS WAS
C                               CAUSING VARIOUS ERRORS.
C      16 APR 86   ...SP...     CORRECTED HANDLING OF SS VALUE FOR HALFWORD.
C       1 APR 87   ...SP...     REDUCED SIZE OF IDS AND UPDATED HELP AS 
C                               SUGGESTED BY LWK.
C      25 JAN 84   ...DFS...    FIX BOUNDARY CHECK WITH RER
C      16 JAN 84   ...DFS...	FIX NSI IN GSUBH
C      15 SEP 83   ...DFS...    CONVERT FOR USE ON VAX/VMS
C      12 APR 81   ...JBS...    CONVERT TO FIXED POINT INTENSITY INTERP
C      12 APR 81   ...JBS...    ALLOW NEGATIVE DN
C       8 OCT 80   ...JBS...    CORRECT RARE SPACE ALLOCATION PROBLEM
C       9 OCT 79   ...JBS...    ADD SAVE AREAS TO GSUB, GSUBH.  OVERLAY.
C      12 OCT 78   ...JBS...    ADD HALFWORD OPTION
C      27 JUN 75   ...DAH...    CHANGES FOR CONVERSION TO 360/OS
C      21 JUN 71     HJF31      VICAR 4-1
C       3 MAY 71     HJF31      REDUCE SIZE FOR RELEASE 7
C
C       THIS PROGRAM WILL REMOVE GEOMETRIC DISTORTION FROM RECORDED
C       PICTURES BASED ON USER INPUT DISPLACEMENT RECTANGLES
C
      PROGRAM LGEOM
C
C       MUST CONFORM TO "MAIN44" STANDARD
      INCLUDE 'VICMAIN_FOR'
C
C--BEGIN MAIN PROGRAM
C
      SUBROUTINE MAIN44

      IMPLICIT NONE
C
C       VARIABLES:
C
C	BLOCK KEEPS TRACK OF BLOCK NUMBER ON IDS
C	BIGBUF IS THE WORKING BUFFER, ALSO KNOWN AS LBUF AND I2BUF.
C	MAXBUF IS THE SIZE (IN BYTES) OF BIGBUF.
C	MAXP2 IS THE SIZE (IN BYTES) OF THE SECOND PASS BUFFER
C	FBI - FIRST BYTE INDEX
C	CSD - CURRENT STRING DISPLACEMENT
C	BBC - BUFFER BYTE COUNT
C	GDIR - GROUP DIRECTORY FOR BLOCKS ON IDS
C	BDIR - BLOCK DIRECTORY FOR GROUPS ON IDS
C	CNT - COUNT OF BLOCKS FOR EACH GROUP
C	LOC - CURRENT LOC FOR EACH GROUP
C
C	IN PASS 1, THE INPUT PICTURE IS READ AND STRINGS OF POINTS FOR THE
C	OUTPUT PICTURE ARE WRITTEN ON THE INTERMEDIATE DATASET (IDS).
C	THE GROUP NUMBER FOR EACH BLOCK ON THE IDS IS SAVED IN GDIR.
C	IN PASS 2, DATA FOR ONE GROUP OF LINES AT A TIME IS READ FROM THE
C	IDS AND WRITTEN TO THE OUTPUT DATASET.
C
C	AT THE END OF PASS 1, GDIR IS TRANSFORMED INTO BDIR SO PASS 2 KNOWS
C	WHICH BLOCKS BELONG TO EACH GROUP AND CAN READ THEM IN THE FORWARD
C	DIRECTION AND TAKE ADVANTAGE OF DISK BLOCKING.
C
C	IF THE ENTIRE PICTURE FITS IN MEMORY, LGEOM OPERATES IN A ONE-PASS
C	MODE AND THE IDS IS NOT USED.
C
C	INPUT,IDS,AND OUT ARE THE UNIT NUMBERS FOR VICAR2
C	V2UNITS KEEPS TRACK OF THE UNIT NUMBERS OF THE FILES
	INTEGER INPUT,IDS,OUT

	EXTERNAL LGM ! SUBROUTINE CALLED BY STACKA

      INTEGER MAXNBPAR,BUFLENPAR,COUNT,NAH,NAV,MAXREC
      PARAMETER (MAXNBPAR=1200)     ! MAXIMUM NUMBER OF BUFFERS FOR PASS 1.
      PARAMETER (BUFLENPAR=1000)    ! DEFAULT NS FOR IDS FILE.

	INTEGER*2 CNT(MAXNBPAR)
	INTEGER*4 LOC(MAXNBPAR)

      INTEGER MAXBUF,MAXP2,MAXTP,IUSE,IDEL,LPB,ILC,IMAX
      INTEGER IND,ILB
      INTEGER I,NSO,NSI
      INTEGER NB,K,K1,MEMSIZE
      REAL FSSI,FLNT
C
C--EQUIVALENT AREA
      INTEGER SLI,SSI,NLO,NBO,NLI,NBI
      INTEGER LOCAT(10)
C
      INTEGER CBBC,CCSD,CFBI,ICR,ISAMP,LD,MAXBBC,MAXB1
      INTEGER SC,BLOCK,BUFLEN,MAXCSD
      INTEGER B,FBI(MAXNBPAR), PIXSIZ
      INTEGER MAXNB,BBC(MAXNBPAR)
      LOGICAL HALFW,XVPTST,NOIN,NOIZ, PRINT
      REAL LARGE,SMALL,FLN,FSM,FSMT,RMIN
      REAL RMAX, RATIO
      INTEGER XVPIXSIZEU
      CHARACTER*8 FMT
      CHARACTER*256 IDSNAM
C
C--INCLUDE COMMON BLOCKS 

      COMMON /V2UNITS/ INPUT,IDS,OUT

      COMMON/P1/ HALFW,NOIN,NOIZ,ILC,ILB,IUSE,IDEL,LPB,IMAX,NB,FSSI,FLNT

      COMMON /A1/ ICR,FLN,FSM,FSMT,LARGE,SMALL,
     .             RMIN,RMAX,CBBC,CCSD,CFBI,B,PRINT,
     .             SC,ISAMP,LD,BLOCK,BUFLEN,MAXBBC,MAXCSD,
     .             LOCAT,FBI,BBC,CNT,LOC
C
      EQUIVALENCE (SLI,LOCAT(1)),(SSI,LOCAT(2)),(NLO,LOCAT(3)),
     2            (NBO,LOCAT(4)),(NLI,LOCAT(5)),(NBI,LOCAT(6))
C
      DATA MAXNB/MAXNBPAR/
      DATA NOIN,NOIZ,HALFW /.FALSE.,.FALSE.,.FALSE./
      DATA LARGE,SMALL,BLOCK /0.99,0.01,0/

C--BEGIN EXECUTION

	PRINT = XVPTST( 'PRINT' ) ! PRINT TIEPOINTS AND PROGRESS MESSAGES

	CALL XVEACTION('SA',' ') ! SET XV ERROR ACTION
	CALL XVUNIT(INPUT,'INP',1,IND,' ')
	CALL XVOPEN(INPUT,IND,' ')
	CALL XVPARM('IDSNS',BUFLEN,I,K,0)
	BUFLEN=(BUFLEN/4)*4
	IF (BUFLEN .LT. 100) THEN
	  CALL XVMESSAGE('IDSNS too small, 1000 bytes used',' ')
	  BUFLEN = 1000
	ENDIF
C
C--Get the name and unit number of the IDS 
	CALL XVPARM('IDSNAM',IDSNAM,I,K,0)
	CALL XVUNIT(IDS,'XX',1,IND,'U_NAME',IDSNAM,' ')

C--Get image size
      CALL XVSIZE(SLI,SSI,NLO,NSO,NLI,NSI)
      IF (NSO .GT. 32767)
     .     CALL MABEND( 'ERROR: NSO > 32767')

      CALL XVGET( INPUT, IND, 'FORMAT', FMT, ' ') 
      IND = XVPIXSIZEU( PIXSIZ, FMT, INPUT)  !PIXEL SIZE IN BYTES

      IF ( PIXSIZ .NE. 1 .AND. PIXSIZ .NE. 2 )
     .     CALL MABEND('ERROR:INP. IMAGE IS NOT BYTE OR HALF FORMAT')
C
C--GET NUMBER OF BYTES PER LINE
      NBO = NSO*PIXSIZ
      NBI = NSI*PIXSIZ
C
C-- SET HALFWORD FLAG IF INPUT IS HALFWORD
      HALFW = PIXSIZ .EQ. 2
C
C--INDEX TO LBUF FOR BYTE 0 OF FIRST OF ILC INPUT LINES
      IUSE = 4*NLI
      IDEL = 4*((NBI+3)/4)

	CALL XVPCNT('INP',COUNT) ! FIND MAX # OF RECTANGLES
	IF(COUNT.EQ.2) THEN ! IF 2 INPUTS, LGEOM WAS CALLED FROM MAP2
	 MAXREC=401 ! ASSUME MAX OF 401 RECTANGLES FROM MAP2
	 MAXTP=441  ! AND MAX OF 441 TIEPOINTS
	ELSE
	 CALL XVP('NAH',NAH,COUNT)
         IF (COUNT .EQ. 0)        CALL MABEND('NAH not specified')
	 CALL XVP('NAV',NAV,COUNT)
         IF (COUNT .EQ. 0)        CALL MABEND('NAV not specified')
	 MAXREC=(NAV*NAH)+1 ! MAX # OF RECTANGLES
	 MAXTP=(NAH+1)*(NAV+1) ! MAX # OF TIEPOINTS
	ENDIF

        CALL GET_MEM_SIZE(MEMSIZE) ! GET PHYSICAL MEMORY SIZE
	MAXBUF = MEMSIZE-48*MAXREC ! SUBTRACT SIZE OF INCRMNTS ->SIZE OF BIGBUF
	MAXB1=4*NLI+IDEL*NLI+NBO ! MAXBUF FOR 1 PASS LGEOM
	IF(MAXBUF.GT.MAXB1) MAXBUF=MAXB1
	IF(MAXBUF.LT.150000) MAXBUF=150000
	IF(MAXBUF.LT.16*MAXTP) MAXBUF=16*MAXTP
C MAKE SURE BUF CAN HOLD THE TIEPOINTS

C
C   SEE IF WE CAN DO IT IN ONE PASS
C
	ILB=0 ! ASSUME 2 PASSES
	ILC=(MAXBUF-4*NLI-NBO)/IDEL
	IF(ILC.GE.NLI) THEN
	  ILB=4*NLI+IDEL*NLI+1
	  LPB=NLO
	  IMAX=IUSE+NLI*IDEL
	  CALL XVUNIT(OUT,'OUT',1,IND,' ')
	  CALL XVOPEN(OUT,IND,'OP','WRITE','U_NS',NSO,'U_NL',NLO,' ')
	  K=1 ! PROVIDE DUMMY NL FOR IDS
	  GOTO 120 ! WE CAN DO IT IN 1 PASS
	ENDIF
C
	MAXP2=MAXBUF+48*MAXREC ! USE BIGBUF + INCRMNTS IN SECOND PASS
50	LPB=(MAXP2-BUFLEN)/NBO ! LINES PER BUFFER
	NB=(NLO+LPB-1)/LPB ! NUMBER OF BUFFERS
	ILC=(MAXBUF-4*NLI-NB*BUFLEN)/IDEL ! INPUT LINES IN CORE
	IF(NB.LE.MAXNB.AND.ILC.GE.8) GOTO 100 ! IF OK, GOTO 100
	BUFLEN=BUFLEN-100 ! MAKE BUFLEN SMALLER
	IF(BUFLEN.GE.100) GOTO 50 ! IF BUFLEN OK, GO TRY THIS VALUE

	CALL TOOBIG ! EXPLAIN THIS IMAGE IS TOO BIG AND ABEND.

100	CONTINUE

C--CALCULATE NUMBER OF LINES NEEDED FOR IDS.
C  TOTAL SIZE OF IDS = RATIO * OUTPUT IMAGE, DEFAULT RATIO OF 2.0

	CALL XVP('RATIO',RATIO,COUNT)
	K=(RATIO*NBO*NLO)/BUFLEN ! EST # OF LINES IN IDS FOR GDIR-BDIR
	K1=(1.1*NBO*NLO)/BUFLEN ! ESTIMATE FOR DISK SIZE

C--OPEN IDS  (Note that since this is an intermediate data set that is written
C             and read and then deleted by the same program, we can assume that
C             it will be read on the same machine that writes it.  Thus it is
C             not a problem that lgeom mixes bytes and halfwords in this file.

      CALL XVOPEN(IDS,IND,'OP','WRITE','U_NS',BUFLEN,'U_NL',K1,
     2    'U_FORMAT','BYTE','O_FORMAT','BYTE',' ')

      IMAX=IUSE+(ILC-1)*IDEL
      FBI(1)=IMAX+IDEL+1
C--INDEX TO LBUF FOR BYTE 1 OF FIRST OF NB BUFFERS
      DO I = 2,NB
        FBI(I) = FBI(I-1)+BUFLEN
      END DO

      DO I = 1,NB
	BBC(I)=0
	CNT(I)=0
      END DO

      MAXBBC=BUFLEN-2
      MAXCSD=BUFLEN-12
120   FSSI=SSI   ! FLOATING TEST VALUES
      FLNT=SLI+NLO
      FSMT=SSI+NSO

	CALL STACKA(7,LGM,3,MAXBUF,48*MAXREC,6*K,MAXREC,K)
C USE STACKA TO ALLOCATE THE 3 BIG BUFFERS AND CALL LGM
	RETURN
	END

	SUBROUTINE LGM(LBUF,L1,INCRMNTS,L2,GDIR,L3,MAXREC,K)
	BYTE LBUF(L1)
	REAL INCRMNTS(12,MAXREC)
	INTEGER*2 GDIR(*)
C
        CALL CHECK_VMS_PAGE_FILE_QUOTA  ! DUMMY SUBROUTINE IF NOT VMS.

	CALL LGEM(LBUF,LBUF,LBUF,INCRMNTS,GDIR,GDIR,MAXREC,K)

C CALL LGEM TO DO THE WORK, PASSING LBUF 3 TIMES FOR THE EQUIVALENT
C BYTE, INTEGER*2 AND INTEGER*4 ARRAY, AND PASSING GDIR 2 TIMES.
C BDIR WILL BE PLACED RIGHT AFTER THE END OF THE GDIR THAT WAS
C ACTUALLY USED.  K IS THE ESTIMATED # OF BLOCKS ON IDS.  IF THE
C PAGE FILE QUOTA IS EXCEEDED, STACKA DOES NOT RETURN AN ERROR AND
C NO ERROR WILL OCCUR UNTIL THE UNAVAILABLE MEMORY IS ACTUALLY USED.
C THAT IS THE REASON FOR ONLY USING THE GDIR-BDIR SPACE THAT IS
C ACTUALLY REQUIRED AND POSSIBLY REQUESTING MORE THAN IS AVAILABLE.

	RETURN
	END

	SUBROUTINE LGEM(LBUF,I2BUF,BIGBUF,INCRMNTS,GDIR,BDIR,MAXREC,K)
	IMPLICIT NONE
	INTEGER MAXREC,K
	BYTE LBUF(*)
	INTEGER*2 I2BUF(*)
	INTEGER*4 BIGBUF(*)
	REAL INCRMNTS(12,MAXREC)
	INTEGER*2 GDIR(*)
	INTEGER*4 BDIR(*),BO

C	INPUT,IDS,AND OUT ARE THE UNIT NUMBERS FOR VICAR2
C	V2UNITS KEEPS TRACK OF THE UNIT NUMBERS OF THE FILES
	INTEGER INPUT,IDS,OUT
C
	INTEGER MAXNBPAR
	PARAMETER (MAXNBPAR=1200) ! MAXIMUM NUMBER OF BUFFERS FOR PASS 1.

	INTEGER*2 CNT(MAXNBPAR)
	INTEGER*4 LOC(MAXNBPAR)

      INTEGER IUSE,IDEL,LPB,ILC,IMAX
      INTEGER IRMIN,IR,IRMAX,INFORM,IFR,IND,ILB
      INTEGER I,ITEMP,NSO,NRECT
      INTEGER NB,LABREC
      REAL RLT,FSSI,FLNT
C
C--EQUIVALENT AREA
      INTEGER SLI,SSI,NLO,NBO,NLI,NBI
      INTEGER LOCAT(10)
C
      INTEGER CBBC,CCSD,CFBI,ICR,ISAMP,LD,MAXBBC
      INTEGER SC,BLOCK,BUFLEN,MAXCSD
      INTEGER B,FBI(MAXNBPAR)
      INTEGER BBC(MAXNBPAR)
      LOGICAL HALFW,DONE,NEXREC,XVPTST,NOIN,NOIZ, PRINT
      REAL LARGE,SMALL,FLN,FSM,FSMT,RMIN
      REAL RMAX
      CHARACTER*80 PBUF
C
C--INCLUDE COMMON BLOCK -- USED TO SEQUENCE BUFFERS

      COMMON /V2UNITS/ INPUT,IDS,OUT

      COMMON/P1/ HALFW,NOIN,NOIZ,ILC,ILB,IUSE,IDEL,LPB,IMAX,NB,FSSI,FLNT

      COMMON /A1/ ICR,FLN,FSM,FSMT,LARGE,SMALL,
     .             RMIN,RMAX,CBBC,CCSD,CFBI,B,PRINT,
     .             SC,ISAMP,LD,BLOCK,BUFLEN,MAXBBC,MAXCSD,
     .             LOCAT,FBI,BBC,CNT,LOC
C
      EQUIVALENCE (SLI,LOCAT(1)),(SSI,LOCAT(2)),(NLO,LOCAT(3)),
     2            (NBO,LOCAT(4)),(NLI,LOCAT(5)),(NBI,LOCAT(6))
C
C
C--Get tiepoints and fill array of INCRMNTS
      CALL GET_TIEPOINTS(BIGBUF,INCRMNTS,NRECT,PRINT)
      IF(NRECT.GT.MAXREC) CALL MABEND('TOO MANY RECTANGLES')
C
      IF (XVPTST('NOIN')) NOIN = .TRUE. 	! COULD ALREADY BE SET
      IF (XVPTST('NOIZ')) NOIZ = .TRUE.		! COULD ALREADY BE SET
      IF (NOIN) THEN
	  LARGE = 0.5
	  SMALL = 0.5
      ENDIF
C
      IRMIN=1
      IR=1
      IRMAX=ILC
C--BEGIN MAIN IRMIN LOOP
      DO WHILE (IRMIN.NE.NLI)
        IF (IRMAX.GT.NLI) IRMAX = NLI
C--BEGIN IR LOOP
        DO IR = IR,IRMAX
          BIGBUF(IR) = IUSE
C--STORE POINTER FOR NEW LINE
          ITEMP = IUSE+1
          IUSE = IUSE+IDEL
          IF (IUSE.GT.IMAX) IUSE = 4*NLI
	  CALL XVREAD(INPUT,LBUF(ITEMP),INFORM,'LINE',IR,' ')
C--END IR LOOP
        END DO
        IF (PRINT)  THEN
           WRITE (PBUF, 55) IRMIN, IRMAX
55         FORMAT('PROCESSING INPUT LINES',I6,' TO',I6)
           CALL XVMESSAGE( PBUF, ' ')
        END IF
C--DOUBLE CHECK FINAL VALUE OF IR FOR DIFFERENT COMPILERS
        IR = IRMAX+1
        RMIN = IRMIN-SMALL
        RMAX = IRMAX+SMALL
        ICR = 1
C--INDEX TO CURRENT RECTANGLE, ALSO USED TO START RECT SEARCH
        B = 1
        CFBI = FBI(1)
        CBBC = BBC(1)
        LD = 0
        FLN = SLI
        FSM = FSSI
C
C--FLN IS CURRENT LINE AND FSM IS CURRENT SAMPLE
C
C--BEGIN OUTER FLN LOOP
        DONE = .FALSE.
        DO WHILE (.NOT.DONE)
C--DONE INDICATES WHETHER ALL LINES AND ALL RECTANGLES HAVE BEEN DONE,
C--     INDICATED BY THE CONDITION (FLN.GE.FLNT)
C--NEXREC INDICATES WHETHER THERE ARE ANY MORE RECTANGLES ON THE CURRENT
C--       LINE TO BE PROCESSED.
          NEXREC = .TRUE.
C
C--SEARCH FOR RECTANGLE LINE FOR FLN
C--IF LAST LINE OF RECTANGLES, TERMINATE SEARCH
          DO WHILE ((FLN.GT.INCRMNTS(2,ICR)).AND.
     2              (INCRMNTS(2,ICR).NE.INCRMNTS(2,NRECT)))
            ICR = ICR+1
          END DO
C
C--SEARCH FOR RECTANGLE ON THIS LINE FOR FSM
C--IF LAST RECTANGLE ON LINE, TERMINATE SEARCH
          DO WHILE ((FSM.GT.INCRMNTS(4,ICR)).AND. ICR .LT. NRECT .AND.
     2              (INCRMNTS(2,ICR).EQ.INCRMNTS(2,ICR+1)))
            ICR = ICR+1
          END DO
C--SAVE INDEX TO FIRST RECT ON LINE
          IFR = ICR
          RLT = INCRMNTS(2,ICR)
C--STORE LAST LINE THAT USES THIS RECTANGLE
          IF (RLT.EQ.INCRMNTS(2,NRECT)) RLT = FLNT
C
C--BEGIN INNER FLN LOOP
          DO WHILE (NEXREC.AND.(.NOT.DONE))
	   IF(ILB.NE.0) THEN ! IF ONE-PASS
	    IF (HALFW) THEN
		CALL GSUBH1(INCRMNTS,LBUF(ILB),LBUF,I2BUF,BIGBUF)
	      ELSE
		CALL GSUB1(INCRMNTS,LBUF(ILB),LBUF,I2BUF,BIGBUF)
	    ENDIF

	  ELSE
	
            IF (HALFW) THEN
                CALL GSUBH(INCRMNTS,GDIR,LBUF,I2BUF,BIGBUF,K)
              ELSE
                CALL GSUB(INCRMNTS,GDIR,LBUF,I2BUF,BIGBUF,K)
            END IF
            BBC(B) = CBBC

	  ENDIF

            FLN = FLN+1
C--CHECK FOR ALL LINES DONE
            IF (FLN.GE.FLNT) THEN
                DONE = .TRUE.
              ELSE
C--STEP LINE DISPLACEMENT
                LD = LD+1
C--CHECK FOR ALL LINES IN THIS BUFFER DONE
                IF (LD.GE.LPB) THEN
                  LD = 0
                  B = B+1
                  CFBI = FBI(B)
                  CBBC = BBC(B)
                END IF
                FSM = FSSI

                IF (FLN.GT.RLT) THEN
                    NEXREC = .FALSE.
                  ELSE
                    ICR = IFR
                END IF
            END IF
C--END INNER FLN LOOP
          END DO
C--END OUTER FLN LOOP
        END DO
        IRMIN = IRMAX
        IRMAX = IRMIN+ILC-1
        IR = IRMIN+1
C--END MAIN IRMIN LOOP
      END DO

	IF(ILB.NE.0) THEN ! IF ONE PASS
	  CALL XVCLOSE(OUT,IND,' ')
	  RETURN
	ENDIF

      DO B = 1,NB
        IF (BBC(B).NE.0) THEN
          ITEMP  =  (FBI(B)+1)/2
          I2BUF((BBC(B)+1)/2+ITEMP) = 0
	  CALL XVWRIT(IDS,LBUF(FBI(B)),IND,' ')
          BLOCK = BLOCK+1
	  IF(BLOCK.GT.K) CALL MABEND('IDS_NL OVFLO, INCREASE RATIO')
	  CNT(B)=CNT(B)+1
	  GDIR(BLOCK)=B
        END IF
      END DO
C
C--UPDATE NL IN LABEL
      CALL XLDEL(IDS,'SYSTEM','NL',IND,' ')
      CALL XLADD(IDS,'SYSTEM','NL',BLOCK,IND,'FORMAT','INT',' ')
C
      CALL XVCLOSE(IDS,IND,' ')
      CALL XVCLOSE(INPUT,IND,' ')
      CALL XVOPEN(IDS,IND,' ')
      CALL XVUNIT(OUT,'OUT',1,IND,' ')
      CALL XVOPEN(OUT,IND,'OP','WRITE','U_NS',NSO,'U_NL',NLO,' ')
C
C--CONVERT GDIR TABLE TO BDIR TABLE FOR PASS 2
	LOC(1)=0
	DO 500 I=2,NB
500	LOC(I)=LOC(I-1)+CNT(I-1) ! SET UP LOC TABLE
	BO=(BLOCK+1)/2 ! OFFSET FOR BDIR TO PUT IT RIGHT AFTER GDIR
	DO 600 I=1,BLOCK
	B=GDIR(I)
	LOC(B)=LOC(B)+1
600	BDIR(LOC(B)+BO)=I ! STORE BLOCK # IN BDIR
C
C--CALL IN SECOND PASS TO READ INTERMEDIATE DISK AND WRITE OUTPUT
      CALL LGP2(LABREC,NB,BUFLEN,NLO,NBO,LPB,CNT,BDIR(BO+1),LBUF,I2BUF,
     .          PRINT)
      CALL XVCLOSE(IDS,IND,'CLOS_ACT','DELETE',' ') 
      CALL XVCLOSE(OUT,IND,' ')
      RETURN
C--END OF MAIN44 (MAIN BODY OF LGEOM)
      END
C
C                       GSUB
C
C       SUBROUTINE TO PROCESS ONE LINE OF BYTE DATA FOR LGEOM
C
      SUBROUTINE GSUB(INCRMNTS,GDIR,LBUF,I2BUF,BIGBUF,K)
C
C       NOTE:
C               IN THE COMMENTS, VERTICAL REFERS TO LINE POSITION
C               WHEN IT IS A REAL NUMBER, AND HORIZONTAL REFERS TO
C               SAMPLE POSITION WHEN IT IS A REAL NUMBER.
C
C               COORDINATE PAIRS ARE GIVEN WITH THE VERTICAL COORDINATE
C               FIRST.
C
C       METHOD:
C
C               EACH OUTPUT POINT IS USED TO GENERATE A COORDINATE IN THE
C               INPUT FILE FOR A DATA POINT, HERE DENOTED BY (R,P), WHERE
C               R IS THE LINE NUMBER AND P IS THE SAMPLE NUMBER.    IF
C               INTERPOLATION IS ACTIVE, THE POINT IS INTERPOLATED USING
C               ITS FOUR NEAREST NEIGHBORS AS FOLLOWS.
C
C               VAL1    TRY1                    VAL2
C                *       *                       *
C              (IR,IP)                         (IR,IP+1)
C
C
C                      (R,P)
C                        *
C
C
C              (IR+1,IP)                      (IR+1,IP+1)
C                *       *                       *
C               VAL3    TRY2                    VAL4
C
C
C               FIRST VAL1 AND VAL2 ARE INTERPOLATED SO THAT
C                       TRY1 = VAL1+(P-IP)*(VAL2-VAL1)
C
C               TRY2 IS THEN INTERPOLATED SIMILARLY USING VAL3 AND VAL4,
C               AND THEN A VALUE FOR POINT (R,P) IS INTERPOLATED FROM
C               TRY1 AND TRY2.
C
C
C--ALL VARIABLES MUST BE EXPLICITLY TYPED
      IMPLICIT NONE

      include 'fortport'  ! DEFINES INT2BYTE AND BYTE2INT CONVERSIONS.

C--PASSED VARIABLES
C
C       INCRMNTS    -- ARRAY CONTAINING INFORMATION OF RECTANGLES
C
        INTEGER*2 I2BUF(*)
        BYTE LBUF(*)
	REAL INCRMNTS(12,*)
	INTEGER*2 GDIR(*)
C
C--LOCAL VARIABLES
C
C       DELP   -- CHANGE IN HORIZONTAL POSITION PER UNIT CHANGE IN VERTICAL
C                 POSITION.
C       DELR   -- CHANGE IN VERTICAL POSITION PER UNIT CHANGE IN HORIZONTAL
C                 POSITION.
C       ICR    -- INDEX TO FIRST DIMENSION OF INCRMNTS ARRAY (Index to Current
C                 Rectangle)
C	IDS    -- UNIT NUMBER OF INTERMEDIATE DATA SET
C       INDEX  -- TEMPORARY VARIABLE FOR ARRAY INDEXING
C       IP     -- INTEGER VALUE OF P
C       IR     -- INTEGER VALUE OF R
C       ITEMP  -- INTEGER TEMPORARY VARIABLE
C       ITEMP2 -- SECOND INTEGER TEMP.
C       NEXSAM -- FLAG TO INDICATE WHETHER THERE ARE MORE SAMPLES TO BE
C                 PROCESSED ON THE CURRENT LINE
C       NSAMP  -- NUMBER OF SAMPLES LEFT TO PROCESS
C       P      -- HORIZONTAL POSITION OF CURRENT POINT IN INPUT FILE.
C       PFRAC  -- FRACTIONAL PART OF P
C       POINT  -- PIXEL VALUE OF INTERPOLATED POINT (R,P) IN INPUT FILE
C       R      -- VERTICAL POSITION OF CURRENT POINT IN INPUT FILE
C       RER    -- FINAL VALUE OF R FOR CURRENT PASS
C       RFRAC  -- FRACTIONAL PART OF R
C       TEMP   -- REAL TEMPORARY VARIABLE
C       VAL1   -- VALUE OF POINT (IR,IP) OF INPUT PICTURE
C       VAL2   -- SAME FOR (IR,IP+1)
C       VAL3   -- SAME FOR (IR+1,IP)
C       VAL4   -- SAME FOR (IR+1,IP+1)
C	V2UNITS KEEPS TRACK OF THE UNIT NUMBERS OF THE FILES
      INTEGER INPUT,IDS,OUT
      COMMON /V2UNITS/ INPUT,IDS,OUT


      LOGICAL HALFW,NOIN,NOIZ
      INTEGER DUMMY !DUMMY ARRAY USED TO PREVENT WARNINGS FROM COMPILERS THAT
                    !WANT ALL OCCURRENCES OF A COMMON BLOCK TO HAVE SAME SIXE.
      COMMON /P1/ HALFW,NOIN,NOIZ,DUMMY(9)
      INTEGER NSAMP,IR,IP,ITEMP,ITEMP2,INDEX,LD,K
      INTEGER VAL1,VAL2,VAL3,VAL4,POINT,SAMP,HFBI,HBBC,HCSD
      REAL RER,R,P,DELR,DELP,TEMP,RFRAC,PFRAC,TEMP2,INZ
      LOGICAL NEXSAM, PRINT
C
C--INCLUDE COMMON BLOCK
      INTEGER ICR,CBBC,CCSD,CFBI,B,SC,ISAMP,BLOCK
      INTEGER BUFLEN,MAXBBC,MAXCSD,LOCAT(10),BIGBUF(*)
      REAL FLN,FSM,FSMT,LARGE,SMALL,RMIN,RMAX
      INTEGER MAXNBPAR
      PARAMETER (MAXNBPAR=1200)     ! MAXIMUM NUMBER OF BUFFERS FOR PASS 1.

	INTEGER*2 CNT(MAXNBPAR)
	INTEGER   LOC(MAXNBPAR),FBI(MAXNBPAR),BBC(MAXNBPAR)
C
C--VARIABLES EQUIVALENCED INTO COMMON BLOCK
      INTEGER SLI,SSI,NLO,NSO,NLI,NSI
C

      COMMON /A1/ ICR,FLN,FSM,FSMT,LARGE,SMALL,
     .             RMIN,RMAX,CBBC,CCSD,CFBI,B,PRINT,
     .             SC,ISAMP,LD,BLOCK,BUFLEN,MAXBBC,MAXCSD,
     .             LOCAT,FBI,BBC,CNT,LOC
C
      EQUIVALENCE (SLI,LOCAT(1)),(SSI,LOCAT(2)),(NLO,LOCAT(3)),
     2            (NSO,LOCAT(4)),(NLI,LOCAT(5)),(NSI,LOCAT(6))
C
C--BEGIN EXECUTION
C
C--INITIALIZE FOR FIRST RUN
      SC = 0
      SAMP = 0
      HFBI = (CFBI+1)/2
      HBBC = CBBC/2
      HCSD = CCSD/2
C
C--BEGIN MAIN RECTANGLE PROCESSING LOOP
      DO WHILE (SAMP.LT.NSO)
C
C--DETERMINE COORDINATE IN INPUT FILE OF CURRENT POINT
        ITEMP = FLN-INCRMNTS(1,ICR)
        DELR = INCRMNTS(12,ICR)+ITEMP*INCRMNTS(11,ICR)
        DELP = INCRMNTS(7,ICR)+ITEMP*INCRMNTS(8,ICR)
        ITEMP2 = FSM-INCRMNTS(3,ICR)
        P = INCRMNTS(5,ICR)+ITEMP*INCRMNTS(9,ICR)+DELP*ITEMP2
        R = INCRMNTS(6,ICR)+ITEMP2*INCRMNTS(12,ICR)+ITEMP*
     2      (INCRMNTS(10,ICR)+ITEMP2*INCRMNTS(11,ICR))
        ITEMP = INCRMNTS(4,ICR)
        IF ((INCRMNTS(2,ICR).NE.INCRMNTS(2,ICR+1)).OR.(ITEMP.GT.FSMT))
     2       ITEMP = FSMT
C
        RER = (ITEMP-FSM)*DELR+R
        NSAMP = ITEMP-FSM
        FSM = ITEMP
        ISAMP = SAMP+NSAMP
C
        NEXSAM = .TRUE.
        IF (NSAMP .LE. 0)  NEXSAM = .FALSE.       ! ADDED FOR MAPTRANS.
C
C--BEGIN SAMPLE PROCESSING LOOP
        DO WHILE (NEXSAM)
C
C--BEGIN MAIN IF BLOCK
          IF (R.LT.RMIN) THEN
              IF (RER.LT.RMIN) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+1
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-1
              END IF
              IF (SC.NE.0) THEN
                I2BUF(HFBI+HCSD) = SC
                SC = 0
              END IF
            ELSE IF (R.GE.RMAX) THEN	! CHANGED .GT. TO .GE.		HJF
              IF (RER.GE.RMAX) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+1
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-1
              END IF
              IF (SC.NE.0) THEN
                I2BUF(HFBI+HCSD) = SC
                SC = 0
              END IF
            ELSE
              IR = R
              RFRAC = R-IR
              IP = P
              PFRAC = P-IP
C
C--CHECK FOR POINTS OUTSIDE OF BOUNDARY
              IF ((P.LT.0).OR.
     2           ((IP.EQ.0).AND.(PFRAC.LE.LARGE)).OR.
     3            (IP.GT.NSI).OR.
     4           ((IP.EQ.NSI).AND.(PFRAC.GE.SMALL))) THEN
C
C--CURRENT POINT NO GOOD
                  IF (SC.NE.0) THEN
                    I2BUF(HFBI+HCSD) = SC
                    SC = 0
                  END IF
                ELSE
C
C--POINT IS WITHIN BOUNDARIES
                  IF ((RFRAC.GE.SMALL).AND.(RFRAC.LT.LARGE) .AND.
     .                (RMAX .GE. IR+1)                          )  THEN
                      INDEX = BIGBUF(IR)+IP
                      VAL1 = BYTE2INT( LBUF(INDEX) )
                      IF (IP .EQ. NSI) THEN
                        VAL2 = VAL1
                      ELSE
                        VAL2 = BYTE2INT( LBUF(INDEX+1) )
                      END IF
                      INDEX = IP+BIGBUF(IR+1)
                      VAL3   = BYTE2INT( LBUF(INDEX) )
                      IF (IP .EQ. NSI) THEN
                        VAL4 = VAL3
                      ELSE
                        VAL4 = BYTE2INT( LBUF(INDEX+1) )
                      END IF
		      IF(NOIZ) THEN
			TEMP = INZ(FLOAT(VAL1),FLOAT(VAL2),PFRAC)
			TEMP2 = INZ(FLOAT(VAL3),FLOAT(VAL4),PFRAC)
			POINT = INZ(TEMP,TEMP2,RFRAC)+0.5
		      ELSE
                      	TEMP = FLOAT(VAL1)+PFRAC*(VAL2-VAL1)
                      	TEMP2 = FLOAT(VAL3)+PFRAC*(VAL4-VAL3)
                      	POINT = TEMP+RFRAC*(TEMP2-TEMP)+0.5
		      ENDIF
                    ELSE
                      IF (RFRAC.GE.LARGE) IR = IR+1
                      INDEX = IP+BIGBUF(IR)
                      VAL1 = BYTE2INT( LBUF(INDEX) )
                      POINT = VAL1
                      IF (PFRAC.GE.SMALL) THEN
                        VAL2 = BYTE2INT( LBUF(INDEX+1) )
                        POINT = VAL2
                        IF (PFRAC.LE.LARGE) THEN
			  IF(NOIZ) THEN
			   POINT = INZ(FLOAT(VAL1),FLOAT(VAL2),PFRAC)+.5
			  ELSE
                           POINT = FLOAT(VAL1)+PFRAC*(VAL2-VAL1)+0.5
			  ENDIF
                        END IF
                      END IF
                  END IF
                  IF ((SC.NE.0).AND.(CBBC.GE.MAXBBC)) THEN
                    I2BUF(HFBI+HCSD) = SC
                    SC = 0
                  END IF
                  IF (SC.EQ.0) THEN
C
C--FORCE CBBC TO BE A MULTIPLE OF TWO
                      IF ( MOD(CBBC,2) .EQ. 1) CBBC = CBBC+1
                      HBBC = CBBC/2
                      IF (CBBC.GE.MAXCSD) THEN
C--ZERO LAST STRING COUNT IN BUFFER
                        I2BUF(HFBI+HBBC) = 0
                        CBBC = 0
                        HBBC = 0
			CALL XVWRIT(IDS,LBUF(CFBI),ITEMP,' ')
                        BLOCK = BLOCK+1
		        IF(BLOCK.GT.K) GOTO 900
			CNT(B)=CNT(B)+1 ! ADD TO COUNT FOR THIS GROUP
			GDIR(BLOCK)=B ! SAVE GROUP # FOR THIS BLOCK
                      END IF
                      CCSD = CBBC
                      HCSD = HBBC
                      SC = 1
                      INDEX = HFBI+HBBC
C--STORE LINE DISPLACEMENT
                      I2BUF(INDEX+1) = LD
C--STORE SAMPLE DISPLACEMENT
                      I2BUF(INDEX+2) = SAMP
C--STORE FIRST DATA POINT IN STRING
                      LBUF(CFBI+CBBC+6) = INT2BYTE(POINT)
                      CBBC = CBBC+7
                    ELSE
                      SC = SC+1
                      LBUF(CFBI+CBBC) =  INT2BYTE(POINT)
                      CBBC = CBBC+1
                  END IF
C
C--END BOUNDARY CHECKING IF BLOCK
              END IF
C
C--PREPARE FOR NEXT SAMPLE IN RECTANGLE
              SAMP = SAMP+1
              R = R+DELR
              P = P+DELP
              NSAMP = NSAMP-1
C
C--END MAIN IF BLOCK
          END IF
          IF (NSAMP.EQ.0) NEXSAM = .FALSE.
C
C--END SAMPLE PROCESSING LOOP
        END DO
C
C--NEXT RECTANGLE
        ICR = ICR+1
C
C--END MAIN RECTANGLE PROCESSING LOOP
      END DO
      IF (SC.NE.0) THEN
        I2BUF(HFBI+HCSD) = SC
      END IF
      RETURN
C
900	CALL MABEND('IDS_NL OVFLO, INCREASE RATIO')
C--END OF SUBROUTINE GSUB
      END
C
C                       GSUBH
C
C       SUBROUTINE TO PROCESS ONE LINE OF HALFWORD DATA FOR LGEOM
C
C       IDENTICAL TO GSUB EXCEPT FOR INDEXING OF ARRAYS AND LENGTH
C       OF DATA (HALFWORD INSTEAD OF BYTE)
C
      SUBROUTINE GSUBH(INCRMNTS,GDIR,LBUF,I2BUF,BIGBUF,K)
C
C--ALL VARIABLES MUST BE EXPLICITLY TYPED
      IMPLICIT NONE

C
C--PASSED VARIABLES
C
        INTEGER*2 I2BUF(*)
        BYTE LBUF(*)
	REAL INCRMNTS(12,*)
	INTEGER*2 GDIR(*)
C
C--LOCAL VARIABLES
C
C       DELP   -- CHANGE IN HORIZONTAL POSITION PER UNIT CHANGE IN VERTICAL
C                 POSITION.
C       DELR   -- CHANGE IN VERTICAL POSITION PER UNIT CHANGE IN HORIZONTAL
C                 POSITION.
C       ICR    -- INDEX TO FIRST DIMENSION OF INCRMNTS ARRAY (Index to Current
C                 Rectangle)
C	IDS    -- UNIT NUMBER OF INTERMEDIATE DATA SET
C       INDEX  -- TEMPORARY VARIABLE FOR ARRAY INDEXING
C       IP     -- INTEGER VALUE OF P
C       IR     -- INTEGER VALUE OF R
C       ITEMP  -- INTEGER TEMPORARY VARIABLE
C       ITEMP2 -- SECOND INTEGER TEMP.
C       NEXSAM -- FLAG TO INDICATE WHETHER THERE ARE MORE SAMPLES TO BE
C                 PROCESSED ON THE CURRENT LINE
C       NSAMP  -- NUMBER OF SAMPLES LEFT TO PROCESS
C	NWI    -- LOCAL VERSION OF NSI (NUMBER SAMPLES IN).  NOTE THAT NSI IN
C                 GSUBH IS THE SAME AS NBI IN MAIN44 BECAUSE OF THE WAY THAT
C                 THE COMMON BLOCK IS SET UP.
C       P      -- HORIZONTAL POSITION OF CURRENT POINT IN INPUT FILE.
C       PFRAC  -- FRACTIONAL PART OF P
C       POINT  -- PIXEL VALUE OF INTERPOLATED POINT (R,P) IN INPUT FILE
C       R      -- VERTICAL POSITION OF CURRENT POINT IN INPUT FILE
C       RER    -- FINAL VALUE OF R FOR CURRENT PASS
C       RFRAC  -- FRACTIONAL PART OF R
C       TEMP   -- REAL TEMPORARY VARIABLE
C       VAL1   -- VALUE OF POINT (IR,IP) OF INPUT PICTURE
C       VAL2   -- SAME FOR (IR,IP+1)
C       VAL3   -- SAME FOR (IR+1,IP)
C       VAL4   -- SAME FOR (IR+1,IP+1)
C	V2UNITS KEEPS TRACK OF THE UNIT NUMBERS OF THE FILES
      INTEGER INPUT,IDS,OUT
      COMMON /V2UNITS/ INPUT,IDS,OUT
      LOGICAL HALFW,NOIN,NOIZ
      INTEGER DUMMY !DUMMY ARRAY USED TO PREVENT WARNINGS FROM COMPILERS THAT
                    !WANT ALL OCCURRENCES OF A COMMON BLOCK TO HAVE SAME SIXE.
      COMMON /P1/ HALFW,NOIN,NOIZ,DUMMY(9)
      INTEGER NSAMP,IR,IP,ITEMP,ITEMP2,INDEX,LD,SAMP,HFBI,CSD,HBBC,NWI
      REAL RER,R,P,DELR,DELP,TEMP,RFRAC,PFRAC,VAL1,VAL2,VAL3
      REAL VAL4,TEMP2,POINT,INZ
      LOGICAL NEXSAM, PRINT
C--INCLUDE COMMON BLOCK
      INTEGER ICR,CBBC,CCSD,CFBI,B,SC,ISAMP,BLOCK,K
      INTEGER BUFLEN,MAXBBC,MAXCSD,LOCAT(10),BIGBUF(*)
      REAL FLN,FSM,FSMT,LARGE,SMALL,RMIN,RMAX
      INTEGER MAXNBPAR
      PARAMETER (MAXNBPAR=1200)     ! MAXIMUM NUMBER OF BUFFERS FOR PASS 1.

	INTEGER*2 CNT(MAXNBPAR)
	INTEGER   LOC(MAXNBPAR),FBI(MAXNBPAR),BBC(MAXNBPAR)
C
C--VARIABLES EQUIVALENCED INTO COMMON BLOCK
      INTEGER SLI,SSI,NLO,NSO,NLI,NSI
C
      COMMON /A1/ ICR,FLN,FSM,FSMT,LARGE,SMALL,
     .             RMIN,RMAX,CBBC,CCSD,CFBI,B,PRINT,
     .             SC,ISAMP,LD,BLOCK,BUFLEN,MAXBBC,MAXCSD,
     .             LOCAT,FBI,BBC,CNT,LOC
C
      EQUIVALENCE (SLI,LOCAT(1)),(SSI,LOCAT(2)),(NLO,LOCAT(3)),
     2            (NSO,LOCAT(4)),(NLI,LOCAT(5)),(NSI,LOCAT(6))
C
C--BEGIN EXECUTION
C
C--INITIALIZE FOR FIRST RUN
      SC = 0
      SAMP = 0
      NWI = NSI/2
      HFBI = (CFBI+1)/2
      CSD = CCSD/2
      HBBC = CBBC/2
C
C--BEGIN MAIN RECTANGLE PROCESSING LOOP
      DO WHILE (SAMP.LT.NSO)
C
C--DETERMINE COORDINATE IN INPUT FILE OF CURRENT POINT
        ITEMP = FLN-INCRMNTS(1,ICR)
        DELR = INCRMNTS(12,ICR)+ITEMP*INCRMNTS(11,ICR)
        DELP = INCRMNTS(7,ICR)+ITEMP*INCRMNTS(8,ICR)
        ITEMP2 = FSM-INCRMNTS(3,ICR)
        P = INCRMNTS(5,ICR)+ITEMP*INCRMNTS(9,ICR)+DELP*ITEMP2
        R = INCRMNTS(6,ICR)+ITEMP2*INCRMNTS(12,ICR)+ITEMP*
     2      (INCRMNTS(10,ICR)+ITEMP2*INCRMNTS(11,ICR))
        ITEMP = INCRMNTS(4,ICR)
        IF ((INCRMNTS(2,ICR).NE.INCRMNTS(2,ICR+1)).OR.(ITEMP.GT.FSMT)) 
     2       ITEMP = FSMT
C
        RER = (ITEMP-FSM)*DELR+R
        NSAMP = ITEMP-FSM
        FSM = ITEMP
        NSAMP = NSAMP*2
        ISAMP = SAMP+NSAMP
C
        NEXSAM = .TRUE.
        IF (NSAMP .LE. 0)  NEXSAM = .FALSE.       ! ADDED FOR MAPTRANS.
C
C--BEGIN SAMPLE PROCESSING LOOP
        DO WHILE (NEXSAM)
C
C--BEGIN MAIN IF BLOCK
          IF (R.LT.RMIN) THEN
              IF (RER.LT.RMIN) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+2
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-2
              END IF
              IF (SC.NE.0) THEN
                I2BUF(HFBI+CSD) = SC
                SC = 0
              END IF
            ELSE IF (R.GE.RMAX) THEN
              IF (RER.GE.RMAX) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+2
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-2
              END IF
              IF (SC.NE.0) THEN
                I2BUF(HFBI+CSD) = SC
                SC = 0
              END IF
            ELSE
              IR = R
              RFRAC = R-IR
              IP = P
              PFRAC = P-IP
C
C--CHECK FOR POINTS OUTSIDE OF BOUNDARY
              IF ((P.LT.0).OR.
     2           ((IP.EQ.0).AND.(PFRAC.LE.LARGE)).OR.
     3            (IP.GT.NWI).OR.
     4           ((IP.EQ.NWI).AND.(PFRAC.GE.SMALL))) THEN
C
C--CURRENT POINT NO GOOD
                  IF (SC.NE.0) THEN
                    I2BUF(HFBI+CSD) = SC
                    SC = 0
                  END IF
                ELSE
C
C--POINT IS WITHIN BOUNDARIES
                  IF ((RFRAC.GE.SMALL).AND.(RFRAC.LT.LARGE) .AND.
     .                (RMAX .GE. IR+1)                          )  THEN
                      INDEX = (BIGBUF(IR)+1)/2+IP
                      VAL1 = I2BUF(INDEX)
                      IF (IP .EQ. NWI) THEN
                        VAL2 = VAL1
                      ELSE
                        VAL2 = I2BUF(INDEX+1)
                      END IF
                      INDEX = IP+(BIGBUF(IR+1)+1)/2
                      VAL3 = I2BUF(INDEX)
                      IF (IP .EQ. NWI) THEN
                        VAL4 = VAL3
                      ELSE
                        VAL4 = I2BUF(INDEX+1)
                      END IF
		      IF(NOIZ) THEN
			TEMP = INZ(VAL1,VAL2,PFRAC)
			TEMP2 = INZ(VAL3,VAL4,PFRAC)
			POINT = INZ(TEMP,TEMP2,RFRAC)
		      ELSE
                      	TEMP = VAL1+PFRAC*(VAL2-VAL1)
                      	TEMP2 = VAL3+PFRAC*(VAL4-VAL3)
                      	POINT = TEMP+RFRAC*(TEMP2-TEMP)
		      ENDIF
                    ELSE
                      IF (RFRAC.GE.LARGE) IR = IR+1
                      INDEX = IP+(BIGBUF(IR)+1)/2
                      POINT = I2BUF(INDEX)
                      IF (PFRAC.GE.SMALL) THEN
                        VAL1 = POINT
                        POINT = I2BUF(INDEX+1)
                        IF (PFRAC.LE.LARGE) THEN
                          VAL2 = POINT
			  IF(NOIZ) THEN
			    POINT = INZ(VAL1,VAL2,PFRAC)
			  ELSE
                            POINT = VAL1+PFRAC*(VAL2-VAL1)
			  ENDIF
                        END IF
                      END IF
                  END IF
                  IF ((SC.NE.0).AND.(HBBC.GE.MAXBBC/2)) THEN
                    I2BUF(HFBI+CSD) = SC
                    SC = 0
                  END IF
                  IF (SC.EQ.0) THEN
                      IF (HBBC.GE.MAXCSD/2) THEN
C--ZERO LAST STRING COUNT IN BUFFER
                        I2BUF(HFBI+HBBC) = 0
                        HBBC = 0
			CALL XVWRIT(IDS,LBUF(HFBI*2-1),ITEMP,' ')
                        BLOCK = BLOCK+1
		        IF(BLOCK.GT.K) GOTO 900
                        CNT(B)=CNT(B)+1
			GDIR(BLOCK)=B
                      END IF
                      CSD = HBBC
                      SC = 2
                      INDEX = HFBI+HBBC
C--STORE LINE DISPLACEMENT
                      I2BUF(INDEX+1) = LD
C--STORE SAMPLE DISPLACEMENT
                      I2BUF(INDEX+2) = SAMP
C--STORE FIRST DATA POINT IN STRING
                      I2BUF(INDEX+3) = NINT( POINT )
                      HBBC = HBBC+4
                    ELSE
                      SC = SC+2
                      INDEX = HFBI+HBBC
                      I2BUF(INDEX) = NINT( POINT )
                      HBBC = HBBC+1
                  END IF
C
C--END BOUNDARY CHECKING IF BLOCK
              END IF
C
C--PREPARE FOR NEXT SAMPLE IN RECTANGLE
              SAMP = SAMP+2
              R = R+DELR
              P = P+DELP
              NSAMP = NSAMP-2
C
C--END MAIN IF BLOCK
          END IF
          IF (NSAMP.EQ.0) NEXSAM = .FALSE.
C
C--END SAMPLE PROCESSING LOOP
        END DO
C
C--NEXT RECTANGLE
        ICR = ICR+1
C
C--END MAIN RECTANGLE PROCESSING LOOP
      END DO
      IF (SC.NE.0) THEN
        I2BUF(HFBI+CSD) = SC
      END IF
      CFBI = HFBI*2-1
      CBBC = HBBC*2
      CCSD = CSD*2
      RETURN
C
900	CALL MABEND('IDS_NL OVFLO, INCREASE RATIO')
C--END OF SUBROUTINE GSUBH
      END
C
C                       GSUB1
C
C       SUBROUTINE TO PROCESS ONE LINE OF BYTE DATA FOR LGEOM (1 PASS)
C
      SUBROUTINE GSUB1(INCRMNTS,LINBUF,LBUF,I2BUF,BIGBUF)
C
C--ALL VARIABLES MUST BE EXPLICITLY TYPED
      IMPLICIT NONE

      include 'fortport'  ! DEFINES INT2BYTE AND BYTE2INT CONVERSIONS.

C
C--PASSED VARIABLES
C
C       INCRMNTS    -- ARRAY CONTAINING INFORMATION ON RECTANGLES
C
        INTEGER*2 I2BUF(*)
        BYTE LBUF(*)
	REAL INCRMNTS(12,*)
	BYTE LINBUF(*)
C
C--LOCAL VARIABLES
C
C       DELP   -- CHANGE IN HORIZONTAL POSITION PER UNIT CHANGE IN VERTICAL
C                 POSITION.
C       DELR   -- CHANGE IN VERTICAL POSITION PER UNIT CHANGE IN HORIZONTAL
C                 POSITION.
C       ICR    -- INDEX TO FIRST DIMENSION OF INCRMNTS ARRAY (Index to Current
C                 Rectangle)
C	OUT    -- UNIT NUMBER OF OUTPUT DATA SET
C       INDEX  -- TEMPORARY VARIABLE FOR ARRAY INDEXING
C       IP     -- INTEGER VALUE OF P
C       IR     -- INTEGER VALUE OF R
C       ITEMP  -- INTEGER TEMPORARY VARIABLE
C       ITEMP2 -- SECOND INTEGER TEMP.
C       NEXSAM -- FLAG TO INDICATE WHETHER THERE ARE MORE SAMPLES TO BE
C                 PROCESSED ON THE CURRENT LINE
C       NSAMP  -- NUMBER OF SAMPLES LEFT TO PROCESS
C       P      -- HORIZONTAL POSITION OF CURRENT POINT IN INPUT FILE.
C       PFRAC  -- FRACTIONAL PART OF P
C       POINT  -- PIXEL VALUE OF INTERPOLATED POINT (R,P) IN INPUT FILE
C       R      -- VERTICAL POSITION OF CURRENT POINT IN INPUT FILE
C       RER    -- FINAL VALUE OF R FOR CURRENT PASS
C       RFRAC  -- FRACTIONAL PART OF R
C       TEMP   -- REAL TEMPORARY VARIABLE
C       VAL1   -- VALUE OF POINT (IR,IP) OF INPUT PICTURE
C       VAL2   -- SAME FOR (IR,IP+1)
C       VAL3   -- SAME FOR (IR+1,IP)
C       VAL4   -- SAME FOR (IR+1,IP+1)
C	V2UNITS KEEPS TRACK OF THE UNIT NUMBERS OF THE FILES
      INTEGER INPUT,IDS,OUT
      COMMON /V2UNITS/ INPUT,IDS,OUT
      LOGICAL HALFW,NOIN,NOIZ
      INTEGER DUMMY !DUMMY ARRAY USED TO PREVENT WARNINGS FROM COMPILERS THAT
                    !WANT ALL OCCURRENCES OF A COMMON BLOCK TO HAVE SAME SIXE.
      COMMON /P1/ HALFW,NOIN,NOIZ,DUMMY(9)
      INTEGER NSAMP,IR,IP,ITEMP,ITEMP2,INDEX,LD
      INTEGER VAL1,VAL2,VAL3,VAL4,POINT,SAMP
      REAL RER,R,P,DELR,DELP,TEMP,RFRAC,PFRAC,TEMP2,INZ
      LOGICAL NEXSAM, PRINT
C
C--INCLUDE COMMON BLOCK
      INTEGER ICR,CBBC,CCSD,CFBI,B,SC,ISAMP,BLOCK
      INTEGER BUFLEN,MAXBBC,MAXCSD,LOCAT(10),BIGBUF(*)
      REAL FLN,FSM,FSMT,LARGE,SMALL,RMIN,RMAX
      INTEGER MAXNBPAR
      PARAMETER (MAXNBPAR=1200)     ! MAXIMUM NUMBER OF BUFFERS FOR PASS 1.

	INTEGER*2 CNT(MAXNBPAR)
	INTEGER   LOC(MAXNBPAR),FBI(MAXNBPAR),BBC(MAXNBPAR)
C
C--VARIABLES EQUIVALENCED INTO COMMON BLOCK
      INTEGER SLI,SSI,NLO,NSO,NLI,NSI
C
      COMMON /A1/ ICR,FLN,FSM,FSMT,LARGE,SMALL,
     .             RMIN,RMAX,CBBC,CCSD,CFBI,B,PRINT,
     .             SC,ISAMP,LD,BLOCK,BUFLEN,MAXBBC,MAXCSD,
     .             LOCAT,FBI,BBC,CNT,LOC
C
      EQUIVALENCE (SLI,LOCAT(1)),(SSI,LOCAT(2)),(NLO,LOCAT(3)),
     2            (NSO,LOCAT(4)),(NLI,LOCAT(5)),(NSI,LOCAT(6))
C
      SAMP = 0
      CALL ZBA(LINBUF,NSO) ! ZERO THE OUTPUT BUFFER
C
C--BEGIN MAIN RECTANGLE PROCESSING LOOP
      DO WHILE (SAMP.LT.NSO)
C
C--DETERMINE COORDINATE IN INPUT FILE OF CURRENT POINT
        ITEMP = FLN-INCRMNTS(1,ICR)
        DELR = INCRMNTS(12,ICR)+ITEMP*INCRMNTS(11,ICR)
        DELP = INCRMNTS(7,ICR)+ITEMP*INCRMNTS(8,ICR)
        ITEMP2 = FSM-INCRMNTS(3,ICR)
        P = INCRMNTS(5,ICR)+ITEMP*INCRMNTS(9,ICR)+DELP*ITEMP2
        R = INCRMNTS(6,ICR)+ITEMP2*INCRMNTS(12,ICR)+ITEMP*
     2      (INCRMNTS(10,ICR)+ITEMP2*INCRMNTS(11,ICR))
        ITEMP = INCRMNTS(4,ICR)
        IF ((INCRMNTS(2,ICR).NE.INCRMNTS(2,ICR+1)).OR.(ITEMP.GT.FSMT))
     2       ITEMP = FSMT
C
        RER = (ITEMP-FSM)*DELR+R
        NSAMP = ITEMP-FSM
        FSM = ITEMP
        ISAMP = SAMP+NSAMP
C
        NEXSAM = .TRUE.
        IF (NSAMP .LE. 0)  NEXSAM = .FALSE.       ! ADDED FOR MAPTRANS.
C
C--BEGIN SAMPLE PROCESSING LOOP
        DO WHILE (NEXSAM)
C
C--BEGIN MAIN IF BLOCK
          IF (R.LT.RMIN) THEN
              IF (RER.LT.RMIN) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+1
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-1
              END IF
            ELSE IF (R.GE.RMAX) THEN
              IF (RER.GE.RMAX) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+1
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-1
              END IF
            ELSE
              IR = R
              RFRAC = R-IR
              IP = P
              PFRAC = P-IP
C
C--CHECK FOR POINTS OUTSIDE OF BOUNDARY
              IF ((P.LT.0).OR.
     2           ((IP.EQ.0).AND.(PFRAC.LE.LARGE)).OR.
     3            (IP.GT.NSI).OR.
     4           ((IP.EQ.NSI).AND.(PFRAC.GE.SMALL))) GOTO 100
C
C--POINT IS WITHIN BOUNDARIES
                  IF ((RFRAC.GE.SMALL).AND.(RFRAC.LT.LARGE) .AND.
     .                (RMAX .GE. IR+1)                          )  THEN
                      INDEX = BIGBUF(IR)+IP
                      VAL1 = BYTE2INT( LBUF(INDEX) )
                      IF (IP .EQ. NSI) THEN
                        VAL2 = VAL1
                      ELSE
                        VAL2 = BYTE2INT( LBUF(INDEX+1) )
                      END IF
                      INDEX = IP+BIGBUF(IR+1)
                      VAL3 = BYTE2INT( LBUF(INDEX) )
                      IF (IP .EQ. NSI) THEN
                        VAL4 = VAL3
                      ELSE
                        VAL4 = BYTE2INT( LBUF(INDEX+1) )
                      END IF
		      IF(NOIZ) THEN
			TEMP = INZ(FLOAT(VAL1),FLOAT(VAL2),PFRAC)
			TEMP2 = INZ(FLOAT(VAL3),FLOAT(VAL4),PFRAC)
			POINT = INZ(TEMP,TEMP2,RFRAC)+.5
		      ELSE
                      	TEMP = FLOAT(VAL1)+PFRAC*(VAL2-VAL1)
                      	TEMP2 = FLOAT(VAL3)+PFRAC*(VAL4-VAL3)
                      	POINT = TEMP+RFRAC*(TEMP2-TEMP)+0.5
		      ENDIF
                    ELSE
                      IF (RFRAC.GE.LARGE) IR = IR+1
                      INDEX = IP+BIGBUF(IR)
                      VAL1 = BYTE2INT( LBUF(INDEX) )
                      POINT = VAL1
                      IF (PFRAC.GE.SMALL) THEN
                        VAL2 = BYTE2INT( LBUF(INDEX+1) )
                        POINT = VAL2
                        IF (PFRAC.LE.LARGE) THEN
			  IF(NOIZ) THEN
			   POINT = INZ(FLOAT(VAL1),FLOAT(VAL2),PFRAC)+.5
			  ELSE
                           POINT = FLOAT(VAL1)+PFRAC*(VAL2-VAL1)+0.5
			  ENDIF
                        END IF
                      END IF
                  END IF

		LINBUF(SAMP+1)= INT2BYTE(POINT) ! STORE SAMPLE
C
C--PREPARE FOR NEXT SAMPLE IN RECTANGLE
100	      SAMP=SAMP+1
              R = R+DELR
              P = P+DELP
              NSAMP = NSAMP-1
C
C--END MAIN IF BLOCK
          END IF
          IF (NSAMP.EQ.0) NEXSAM = .FALSE.
C
C--END SAMPLE PROCESSING LOOP
        END DO
C
C--NEXT RECTANGLE
        ICR = ICR+1
C
C--END MAIN RECTANGLE PROCESSING LOOP
      END DO

	CALL XVWRIT(OUT,LINBUF,ITEMP,' ') ! WRITE OUTPUT LINE
	RETURN
C
C--END OF SUBROUTINE GSUB1
      END
C
C                       GSUBH1
C
C       SUBROUTINE TO PROCESS ONE LINE OF HALFWORD DATA FOR LGEOM (ONE-PASS)
C
C       SIMILAR TO GSUB1 EXCEPT FOR INDEXING OF ARRAYS AND LENGTH
C       OF DATA (HALFWORD INSTEAD OF BYTE)
C
      SUBROUTINE GSUBH1(INCRMNTS,LINBUF,LBUF,I2BUF,BIGBUF)
C
C--ALL VARIABLES MUST BE EXPLICITLY TYPED
      IMPLICIT NONE


C
C--PASSED VARIABLES
C
        INTEGER*2 I2BUF(*)
        BYTE LBUF(*)
	REAL INCRMNTS(12,*)
	INTEGER*2 LINBUF(*)
C
C--LOCAL VARIABLES
C
C       DELP   -- CHANGE IN HORIZONTAL POSITION PER UNIT CHANGE IN VERTICAL
C                 POSITION.
C       DELR   -- CHANGE IN VERTICAL POSITION PER UNIT CHANGE IN HORIZONTAL
C                 POSITION.
C       ICR    -- INDEX TO FIRST DIMENSION OF INCRMNTS ARRAY (Index to Current
C                 Rectangle)
C	IDS    -- UNIT NUMBER OF INTERMEDIATE DATA SET
C       INDEX  -- TEMPORARY VARIABLE FOR ARRAY INDEXING
C       IP     -- INTEGER VALUE OF P
C       IR     -- INTEGER VALUE OF R
C       ITEMP  -- INTEGER TEMPORARY VARIABLE
C       ITEMP2 -- SECOND INTEGER TEMP.
C       NEXSAM -- FLAG TO INDICATE WHETHER THERE ARE MORE SAMPLES TO BE
C                 PROCESSED ON THE CURRENT LINE
C       NSAMP  -- NUMBER OF SAMPLES LEFT TO PROCESS
C	NWI    -- NUMBER OF WORDS INPUT
C       NWO    -- NUMBER OF WORDS OUTPUT
C       P      -- HORIZONTAL POSITION OF CURRENT POINT IN INPUT FILE.
C       PFRAC  -- FRACTIONAL PART OF P
C       POINT  -- PIXEL VALUE OF INTERPOLATED POINT (R,P) IN INPUT FILE
C       R      -- VERTICAL POSITION OF CURRENT POINT IN INPUT FILE
C       RER    -- FINAL VALUE OF R FOR CURRENT PASS
C       RFRAC  -- FRACTIONAL PART OF R
C       TEMP   -- REAL TEMPORARY VARIABLE
C       VAL1   -- VALUE OF POINT (IR,IP) OF INPUT PICTURE
C       VAL2   -- SAME FOR (IR,IP+1)
C       VAL3   -- SAME FOR (IR+1,IP)
C       VAL4   -- SAME FOR (IR+1,IP+1)
C	V2UNITS KEEPS TRACK OF THE UNIT NUMBERS OF THE FILES
      INTEGER INPUT,IDS,OUT
      COMMON /V2UNITS/ INPUT,IDS,OUT
      LOGICAL HALFW,NOIN,NOIZ
      INTEGER DUMMY !DUMMY ARRAY USED TO PREVENT WARNINGS FROM COMPILERS THAT
                    !WANT ALL OCCURRENCES OF A COMMON BLOCK TO HAVE SAME SIXE.
      COMMON /P1/ HALFW,NOIN,NOIZ,DUMMY(9)
      INTEGER NSAMP,IR,IP,ITEMP,ITEMP2,INDEX,LD,SAMP
      REAL RER,R,P,DELR,DELP,TEMP,RFRAC,PFRAC,VAL1,VAL2,VAL3
      REAL VAL4,TEMP2,POINT,INZ
      LOGICAL NEXSAM, PRINT
C--INCLUDE COMMON BLOCK
      INTEGER ICR,CBBC,CCSD,CFBI,B,SC,ISAMP,BLOCK
      INTEGER BUFLEN,MAXBBC,MAXCSD,LOCAT(10),BIGBUF(*)
      REAL FLN,FSM,FSMT,LARGE,SMALL,RMIN,RMAX
      INTEGER MAXNBPAR
      PARAMETER (MAXNBPAR=1200)     ! MAXIMUM NUMBER OF BUFFERS FOR PASS 1.

	INTEGER*2 CNT(MAXNBPAR)
	INTEGER   LOC(MAXNBPAR),FBI(MAXNBPAR),BBC(MAXNBPAR)
C
C--VARIABLES EQUIVALENCED INTO COMMON BLOCK
      INTEGER SLI,SSI,NLO,NBO,NLI,NBI,NWO,NWI
C
      COMMON /A1/ ICR,FLN,FSM,FSMT,LARGE,SMALL,
     .             RMIN,RMAX,CBBC,CCSD,CFBI,B,PRINT,
     .             SC,ISAMP,LD,BLOCK,BUFLEN,MAXBBC,MAXCSD,
     .             LOCAT,FBI,BBC,CNT,LOC
C
      EQUIVALENCE (SLI,LOCAT(1)),(SSI,LOCAT(2)),(NLO,LOCAT(3)),
     2            (NBO,LOCAT(4)),(NLI,LOCAT(5)),(NBI,LOCAT(6))
C
C
      SAMP = 0
      NWI = NBI/2
      NWO = NBO/2
      CALL ZBA(LINBUF,NBO) ! ZERO THE OUTPUT LINE
C
C--BEGIN MAIN RECTANGLE PROCESSING LOOP
      DO WHILE (SAMP.LT.NWO)
C
C--DETERMINE COORDINATE IN INPUT FILE OF CURRENT POINT
        ITEMP = FLN-INCRMNTS(1,ICR)
        DELR = INCRMNTS(12,ICR)+ITEMP*INCRMNTS(11,ICR)
        DELP = INCRMNTS(7,ICR)+ITEMP*INCRMNTS(8,ICR)
        ITEMP2 = FSM-INCRMNTS(3,ICR)
        P = INCRMNTS(5,ICR)+ITEMP*INCRMNTS(9,ICR)+DELP*ITEMP2
        R = INCRMNTS(6,ICR)+ITEMP2*INCRMNTS(12,ICR)+ITEMP*
     2      (INCRMNTS(10,ICR)+ITEMP2*INCRMNTS(11,ICR))
        ITEMP = INCRMNTS(4,ICR)
        IF ((INCRMNTS(2,ICR).NE.INCRMNTS(2,ICR+1)).OR.(ITEMP.GT.FSMT)) 
     2       ITEMP = FSMT
C
        RER = (ITEMP-FSM)*DELR+R
        NSAMP = ITEMP-FSM
        FSM = ITEMP
        ISAMP = SAMP+NSAMP
C
        NEXSAM = .TRUE.
        IF (NSAMP .LE. 0)  NEXSAM = .FALSE.       ! ADDED FOR MAPTRANS.
C
C--BEGIN SAMPLE PROCESSING LOOP
        DO WHILE (NEXSAM)
C
C--BEGIN MAIN IF BLOCK
          IF (R.LT.RMIN) THEN
              IF (RER.LT.RMIN) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+1
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-1
              END IF
            ELSE IF (R.GE.RMAX) THEN
              IF (RER.GE.RMAX) THEN
                  SAMP = ISAMP
                  NEXSAM = .FALSE.
                ELSE 
                  SAMP = SAMP+1
                  R = R+DELR
                  P = P+DELP
                  NSAMP = NSAMP-1
              END IF
            ELSE
              IR = R
              RFRAC = R-IR
              IP = P
              PFRAC = P-IP
C
C--CHECK FOR POINTS OUTSIDE OF BOUNDARY
              IF ((P.LT.0).OR.
     2           ((IP.EQ.0).AND.(PFRAC.LE.LARGE)).OR.
     3            (IP.GT.NWI).OR.
     4           ((IP.EQ.NWI).AND.(PFRAC.GE.SMALL))) GOTO 100
C
C--POINT IS WITHIN BOUNDARIES
                  IF ((RFRAC.GE.SMALL).AND.(RFRAC.LT.LARGE) .AND.
     .                (RMAX .GE. IR+1)                          )  THEN
                      INDEX = (BIGBUF(IR)+1)/2+IP
                      VAL1 = I2BUF(INDEX)
                      IF (IP .EQ. NWI) THEN
                        VAL2 = VAL1
                      ELSE
                        VAL2 = I2BUF(INDEX+1)
                      END IF
                      INDEX = IP+(BIGBUF(IR+1)+1)/2
                      VAL3 = I2BUF(INDEX)
                      IF (IP .EQ. NWI) THEN
                        VAL4 = VAL3
                      ELSE
                        VAL4 = I2BUF(INDEX+1)
                      END IF
		      IF(NOIZ) THEN
			TEMP = INZ(VAL1,VAL2,PFRAC)
			TEMP2 = INZ(VAL3,VAL4,PFRAC)
			POINT = INZ(TEMP,TEMP2,RFRAC)
		      ELSE
                      	TEMP = VAL1+PFRAC*(VAL2-VAL1)
                      	TEMP2 = VAL3+PFRAC*(VAL4-VAL3)
                      	POINT = TEMP+RFRAC*(TEMP2-TEMP)
		      ENDIF
                    ELSE
                      IF (RFRAC.GE.LARGE) IR = IR+1
                      INDEX = IP+(BIGBUF(IR)+1)/2
                      POINT = I2BUF(INDEX)
                      IF (PFRAC.GE.SMALL) THEN
                        VAL1 = POINT
                        POINT = I2BUF(INDEX+1)
                        IF (PFRAC.LE.LARGE) THEN
                          VAL2 = POINT
			  IF(NOIZ) THEN
			    POINT = INZ(VAL1,VAL2,PFRAC)
			  ELSE
                            POINT = VAL1+PFRAC*(VAL2-VAL1)
			  ENDIF
                        END IF
                      END IF
                  END IF

		LINBUF(SAMP+1) = NINT(POINT) ! STORE OUTPUT WORD
C
C--PREPARE FOR NEXT SAMPLE IN RECTANGLE
100           SAMP = SAMP+1
              R = R+DELR
              P = P+DELP
              NSAMP = NSAMP-1
C
C--END MAIN IF BLOCK
          END IF
          IF (NSAMP.EQ.0) NEXSAM = .FALSE.
C
C--END SAMPLE PROCESSING LOOP
        END DO
C
C--NEXT RECTANGLE
        ICR = ICR+1
C
C--END MAIN RECTANGLE PROCESSING LOOP
      END DO

	CALL XVWRIT(OUT,LINBUF,ITEMP,' ')

      RETURN
C
C--END OF SUBROUTINE GSUBH1
      END
C
C	INZ FUNCTION
C
C	INTERPOLATE NON-ZERO DN VALUES
C	USE NEAREST NEIGHBOR IF EITHER DN IS ZERO
C
	REAL FUNCTION INZ(VAL1,VAL2,FRAC)
C
	IF(VAL1.EQ.0.0.OR.VAL2.EQ.0.0) THEN
		IF(FRAC .LT. .5) THEN
			INZ=VAL1
		ELSE
			INZ=VAL2
		ENDIF
	ELSE
		INZ=VAL1+FRAC*(VAL2-VAL1)
	ENDIF
	RETURN
	END
C               LGP2
C
C       SECOND PASS FOR LGEOM
C
      SUBROUTINE LGP2(LABREC,NB,BUFLEN,NLO,NSO,LPB,CNT,BDIR,LBUF,I2BUF,
     .                PRINT)
C
      IMPLICIT NONE
C
C       PASSED VARIABLES:
C
	INTEGER NB,BUFLEN,NLO,NSO,LPB,LABREC
	INTEGER*2 CNT(*)
	INTEGER*4 BDIR(*)
	BYTE LBUF(*)
	INTEGER*2 I2BUF(*)
        LOGICAL PRINT
C
C       LOCAL VARIABLES:
C
C	V2UNITS KEEPS TRACK OF THE UNIT NUMBERS OF THE FILES
      INTEGER INPUT,IDS,OUT
      COMMON /V2UNITS/ INPUT,IDS,OUT
      INTEGER IB,G,ITEMP,NL
      INTEGER SC,INDEX,I2IND,I,IND
      CHARACTER*80 PBUF
C
C
C
C--BEGIN EXECUTION
C
C--INITIALIZE ARRAY INDEXES
	IB=1 ! INDEX TO BDIR
	G=1 ! GROUP NUMBER
	NL=NLO ! SAVE NLO FOR TEST
40	CALL ZBA(LBUF(BUFLEN+1),LPB*NSO) ! ZERO LPB LINES OF OUTPUT
        IF (PRINT)  THEN
           WRITE (PBUF, 55) (G-1)*LPB+1,MIN(NL,G*LPB)
55         FORMAT('PROCESSING OUTPUT LINES',I6,' TO',I6)
           CALL XVMESSAGE( PBUF, ' ')
        END IF
80	IF(CNT(G).EQ.0) GOTO 300 ! IF NO MORE DATA FOR THIS GROUP
100	CALL XVREAD(IDS,LBUF,IND,'LINE',BDIR(IB) ,' ')
	IB=IB+1
	CNT(G)=CNT(G)-1
	INDEX=1
	I2IND=1
150	SC=I2BUF(I2IND) ! STRING COUNT
	IF(SC.EQ.0) GOTO 80 ! IF END OF BLOCK, GOTO 80	
	ITEMP = I2BUF(I2IND+1)*NSO+I2BUF(I2IND+2)+BUFLEN
	CALL MVB(LBUF(INDEX+6),LBUF(ITEMP+1),SC)
	INDEX=(INDEX+6+SC)                         ! STEP INDEX 
        IF ( MOD(INDEX,2) .EQ. 0) INDEX= INDEX+1   ! (ADD 1 IF NECESSARY)
	I2IND=(INDEX+1)/2
	GOTO 150

300	INDEX=BUFLEN
	DO 400 I=1,LPB
	CALL XVWRIT(OUT,LBUF(INDEX+1),IND,' ')
	NLO = NLO-1
	IF(NLO.EQ.0) RETURN
400	INDEX=INDEX+NSO
	G=G+1 ! STEP TO NEXT GROUP
	GOTO 40
C
C--END OF LGP2
      END
C
      SUBROUTINE GET_TIEPOINTS(BUF,INCREMENTS,NRECT,PRINT)
      IMPLICIT NONE
C
C	GET_TIEPOINTS reads in the tiepoints parameter, calculates
C	the offsets needed by the main program, and stores them in
C	INCREMENTS.
C
C	Passed variables:
C
C INCREMENTS -- Array of increments needed by LGEOM to step across
C		the rectangles
C BUF	-- Large working buffer

      REAL INCREMENTS(12,*),BUF(*)
C
C	Local variables:
C
C
C       Output image rectangle:         Input image quadrilateral
C
C                                                      * (A2,B2)
C       (X1,Y1)*      * (X1,Y2)         (A1,B1)*
C
C                                                    * (A4,B4)
C       (X2,Y1)*      * (X2,Y2)         (A3,B3)*
C
C NAH	-- Number of rectangles (areas) horizontally
C NAV	-- Number of rectangles (areas) vertically
C TX1,TY1 etc -- Temporary real variables to fill common block
C DELX,DELY  -- X2-X1,Y2-Y1
C TOP     -- index into buffer of top line of rects
C BOTTOM  -- index into buffer for bottom line of rects
C ROW     -- current rectangle row
C COL     -- current rectangle column
C NVALS   -- number of values needed in TIEPOINTS
C NRECT   -- total number of rectangles
C
      INTEGER NAH,NAV,TOP,BOTTOM,ROW,COL,NVALS,I,N,NRECT
      CHARACTER*80 PBUF
      REAL DELX,DELY
      REAL X1,Y1,A1,B1,TX1,Y2,A2,B2,X2,TY1,A3,B3,TX2,TY2,A4,B4
C
C COUNT -- Variable count returned from xvparm
C DEFAULTED -- Default flag from xvparm
C PDS	-- Logical indicating the presence of a parameter data set.
C PRINT -- Print extra info.
      INTEGER COUNT,DEFAULTED
      LOGICAL PRINT
C
C--Begin execution
C
C--Check for the presence of a parameter data set
      CALL XVPCNT('INP',COUNT)
      IF (COUNT .EQ. 2) THEN
	  CALL LOAD_PDS(BUF,BUF,INCREMENTS,NRECT)
	  RETURN
      ENDIF
C
C--Get the size of the grid
      CALL XVPARM('NAH',NAH,COUNT,DEFAULTED,0)
      IF (COUNT .EQ. 0) THEN
	  CALL XVMESSAGE('NAH not specified',' ')
	  CALL ABEND
      ENDIF
      CALL XVPARM('NAV',NAV,COUNT,DEFAULTED,0)
      IF (COUNT .EQ. 0) THEN
	  CALL XVMESSAGE('NAV not specified',' ')
	  CALL ABEND
      ENDIF
C
C--Get the tiepoints
      CALL XVPARM('TIEPOINT',BUF,COUNT,DEFAULTED,0)
C
C--Check for proper number of tiepoints
      NVALS = 4*(NAH + 1) * (NAV + 1)
      IF (COUNT .NE. NVALS) THEN
	  CALL XVMESSAGE('Improper number of tiepoints specified',' ')
	  CALL ABEND
      ENDIF

C CODE TO PRINT TIEPOINTS

      IF (PRINT) THEN
      CALL XVMESSAGE( '   TIEPOINTS:',' ')
      DO I = 1, NVALS, 4
         WRITE(PBUF,9000) BUF(I), BUF(I+1), BUF(I+2), BUF(I+3)
9000     FORMAT( 4F10.3 )
         CALL XVMESSAGE ( PBUF(1:40), ' ')
      END DO
      END IF
C
C--Verify that the rectangles in the output image are whole numbers
      NVALS = 4*(NAH + 1)
      DO ROW = 1, NAV*NVALS+1, NVALS
	X1 = BUF(ROW)
	I = X1			! TRUNCATE
	IF ((X1 - I) .NE. 0) THEN
	    CALL XVMESSAGE
     2      ('Grid on output not on integral pixel numbers',' ')
	    CALL ABEND
	ENDIF
      ENDDO
      DO COL = 1, 4*NAH+1, 4
	Y1 = BUF(COL)
	I = Y1			! TRUNCATE
	IF ((Y1 - I) .NE. 0) THEN
	    CALL XVMESSAGE
     2      ('Grid on output not on integral pixel numbers',' ')
	    CALL ABEND
	ENDIF
      ENDDO
C
C--Cycle through the rectangles, storing each set of increments
      N = 1
      TOP = 1
      BOTTOM = 4 * NAH + 5
      DO ROW = 1,NAV
	DO COL = 1,NAH
C
C--Move current tiepoint pair into local variables

          X1 = BUF(TOP )
          Y1 = BUF(TOP+1 )
          A1 = BUF(TOP+2 )
          B1 = BUF(TOP+3 )
          TX1 = BUF(TOP+4 )
          Y2 = BUF(TOP+5 )
          A2 = BUF(TOP+6 )
          B2 = BUF(TOP+7 )

          X2 = BUF(BOTTOM )
          TY1 = BUF(BOTTOM+1 )
          A3 = BUF(BOTTOM+2 )
          B3 = BUF(BOTTOM+3 )
          TX2 = BUF(BOTTOM+4 )
          TY2 = BUF(BOTTOM+5 )
          A4 = BUF(BOTTOM+6 )
          B4 = BUF(BOTTOM+7 )
C
C--Verify that tiepoint represents a rectangle
	  IF ((X1 .NE. TX1) .OR. (X2 .NE. TX2) .OR.
     2      (Y1 .NE. TY1) .OR. (Y2 .NE. TY2)) 
     3      CALL MABEND('Tiepoints are not rectangular')
C
C--Now store the increments
	  INCREMENTS(1,N) = X1
	  INCREMENTS(2,N) = X2
	  INCREMENTS(3,N) = Y1
	  INCREMENTS(4,N) = Y2
	  INCREMENTS(5,N) = B1
	  INCREMENTS(6,N) = A1
	  DELX = X2 - X1
	  DELY = Y2 - Y1
	  INCREMENTS(7,N) = (B2 - B1)/DELY
	  INCREMENTS(8,N) = (B4 - B3 - B2 + B1) / (DELX * DELY)
	  INCREMENTS(9,N) = (B3 - B1) / DELX
	  INCREMENTS(10,N) = (A3 - A1) / DELX
	  INCREMENTS(11,N) = (A4 - A3 - A2 + A1) / (DELY * DELX)
	  INCREMENTS(12,N) = (A2 - A1) / DELY
C
C--Next rectangle
	  TOP = TOP + 4
	  BOTTOM = BOTTOM + 4
	  N = N + 1
	ENDDO
C
C--Next line of rectangles
	TOP = TOP + 4
	BOTTOM = BOTTOM + 4
      ENDDO
      NRECT = N - 1
C
C--End of GET_TIEPOINTS
      RETURN
      END
C
C
      SUBROUTINE LOAD_PDS(BUF,I_BUF,INCREMENTS,ISAVE)
      IMPLICIT NONE

	INTEGER  MAXRPAR,INCRPAR
	PARAMETER (MAXRPAR=400) ! MAX RECTS FROM MAP2
	PARAMETER (INCRPAR=401) ! MAX RECTS FROM MAP2
C
C
C	LOAD_PDS gets the LGEOM parameters from a parameter
C	data set (PDS)  in the old format, and sorts them into
C	the INCREMENTS array.
C
C	Passed variables:
      REAL BUF(*),INCREMENTS(12,INCRPAR)
      INTEGER I_BUF(*)	! Same address as BUF
C
C	Local variables:
      CHARACTER*43 NORECT
      CHARACTER*38 NOSAMP
      CHARACTER*36 NOLINE
      CHARACTER*21 LINES  
      CHARACTER*21 RECTAN 
      CHARACTER*4  CSAVE
C
      INTEGER IND,INPUT,NP,LOCSMP,I,J,K,INDEX,NSAMP,NB
      INTEGER IM,IN,M,N,ISAVE,MLOC,NLOC
      INTEGER*2 ITAB(3,INCRPAR)
      REAL ROW,SAM,VMA,TEMP,TEMPM,TEMP2
      LOGICAL HALFW,NOIN,NOIZ
      INTEGER DUMMY !DUMMY ARRAY USED TO PREVENT WARNINGS FROM COMPILERS THAT
                    !WANT ALL OCCURRENCES OF A COMMON BLOCK TO HAVE SAME SIXE.
      COMMON /P1/ HALFW,NOIN,NOIZ,DUMMY(9)

      DATA NORECT/'THERE WERE NOT ENOUGH PARAMETERS FOR GEOM.'/
      DATA NOSAMP/'GEOM COULD NOT FIND ANY SAMPLE CARDS.'/
      DATA NOLINE/'GEOM COULD NOT FIND ANY LINE CARDS.'/
      DATA LINES/'TOO MANY LINE CARDS.'/
      DATA RECTAN/'TOO MANY RECTANGLES.'/
C==================================================================
C
      CALL XVUNIT(INPUT,'INP',2,IND,' ')
      CALL XVOPEN(INPUT,IND,' ')
C
C--CALL READ READING INTO BUF
      CALL XVREAD(INPUT,BUF,IND,' ')
      NP = I_BUF(1)
      BUF(NP+2) = 0
      CALL XVCLOSE(INPUT,IND,' ')

C
C     THE LINE NUMBERS FROM THE USER INPUT CARDS ARE GOING TO BE STORED
C     IN ITAB AND THEN THEY WILL BE SORTED IN ASCENDING ORDER
C     WHEN THE COMPUTATION IS DONE FOR EACH RECTANGLE,THE CORRESPONDING
C     SAMPLE NUMBERS MUST BE USED ALSO. LOCSMP WILL TELL WHERE IN BUF
C     THE SAMPLE VALUES ARE STORED WHICH CORRESPOND TO A LINE NUMBER.
C     K WILL BE USED TO COUNT THE NUMBER OF LINES IN ITAB
      LOCSMP=0
      K=0
      I = 1
C
C--BEGIN PARAMETER PROCESSING LOOP
      DO WHILE ((I.LT.NP).AND.(K.LT.MAXRPAR))
        I = I+1
        CALL MVLC(I_BUF(I), CSAVE, 4)   ! MOVE TO CHARACTER VARIABLE.
C
C--BEGIN PARAMETER PROCESSING IF BLOCK
        IF (CSAVE.EQ.'SAMP') THEN
            LOCSMP = I+2
          ELSE IF (CSAVE.EQ.'NBUF') THEN
	    NB = I_BUF(I+2)
          ELSE IF (CSAVE.EQ.'NOIN') THEN
C--FORCE NO INTERPOLATION (USE NEAREST POINT)
	    NOIN = .TRUE.	! SET FLAG FOR MAIN44
	  ELSE IF (CSAVE.EQ.'NOIZ') THEN
C--NO INTERPOLATION FOR ZERO DN POINTS
	    NOIZ = .TRUE.
          ELSE IF (CSAVE.EQ.'HALF') THEN
            HALFW = .TRUE.
          ELSE IF (CSAVE.EQ.'LINE') THEN
            K = K+1
            ITAB(1,K)=BUF(I+2)
            ITAB(2,K)=I+2
            ITAB(3,K)=LOCSMP
            IF (K.EQ.INCRPAR) CALL XVMESSAGE(LINES,' ')
C
C--END PARAMETER PROCESSING IF BLOCK
        END IF
C
C--END PARAMETER PROCESSING LOOP
      END DO
C
C
      IF (LOCSMP.EQ.0) THEN
C--NO KEYWORD 'SAMPLE' FOUND
        CALL XVMESSAGE(NOSAMP,' ')
        CALL ABEND
      END IF
C
C--NOW THAT THE LINES ARE ALL IN ITAB - SORT THEM IN ASCENDING ORDER
      DO I = 1,K-1
        M = I+1
        DO J = M,K
          IF (ITAB(1,I).GT.ITAB(1,J)) THEN
            DO N = 1,3
              ISAVE = ITAB(N,I)
              ITAB(N,I) = ITAB(N,J)
              ITAB(N,J) = ISAVE
            END DO
          END IF
        END DO
C--END OF SORT
      END DO
C--WHEN THE LINES ARE SORTED, PROCESS THE RECTANGLES IN THAT ORDER
C
C--ISAVE WILL INDICATE WHERE IN THE BUFFER INCREMENTS THE RESULTS OF THE
C--RECTANGLE CALCULATIONS SHOULD BE STORED
C
C--NSAMP WILL BE USED WITH EACH LINE THAT IS PROCESSED TO TELL HOW
C--MANY SAMPLES WERE SPECIFIED FOR THIS LINE. THE NUMBER OF
C--RECTANGULAR CALCULATIONS DONE WILL BE ONE LESS THAN THE NUMBER
C--OF SAMPLES
      ISAVE=0
C
C--BEGIN PARAMETER STORAGE LOOP
      J = 0
      DO WHILE ((J.LT.K).AND.(ISAVE.LT.MAXRPAR))
        J = J+1
        NSAMP = 1
        INDEX = ITAB(3,J)+1
C
C--COUNT THE NUMBER PER LINE
        CALL MVLC(BUF(INDEX), CSAVE, 4)   ! MOVE TO CHARACTER VARIABLE.
        DO WHILE ((CSAVE.NE.'LINE').AND.(INDEX.LE.NP))
          NSAMP = NSAMP+1
          INDEX = INDEX+1
          CALL MVLC(BUF(INDEX), CSAVE, 4)   ! MOVE TO CHARACTER VARIABLE.
        END DO
C
C--CHECK FOR ERROR (LACK OF KEYWORD "LINE")
        IF (INDEX.GT.NP) THEN
          CALL XVMESSAGE(NOLINE,' ')
          CALL ABEND
        END IF
C
C--IM IS A SUBSCRIPT TO PICK UP THE FIRST LINE IN THE RECTANGLE FROM
C--BUF
        IM=ITAB(2,J)
        CALL MVLC(BUF(IM+1+2*NSAMP), CSAVE, 4)   ! MOVE TO CHARACTER VARIABLE.
        IF (CSAVE .EQ.'LINE') THEN
C--INDEX IS RESET TO POINT TO THE FIRST OF THE SAMPLES
          INDEX = ITAB(3,J)
C--IN WILL POINT TO THE LOCATION OF THE SECOND LINE OF THE RECTANGLE
          IN=IM+3+2*NSAMP
          NSAMP = NSAMP-1
          M=BUF(IM)
          N=BUF(IN)
C--M AND N NOW HAVE THE LINES FOR THE RECTANGLE
          I = 0
C--BEGIN SAMPLE PROCESSING LOOP
          DO WHILE ((I.LT.NSAMP).AND.(ISAVE.LT.MAXRPAR))
            I = I+1
            ISAVE = ISAVE+1
            SAM = I_BUF(INDEX+1)-I_BUF(INDEX)
            ROW = N-M
            MLOC = IM+2*(I-1)+1
C--MLOC IS THE LOCATION IN THE BUFFER BUF OF THE DISPLACEMENTS FOR
C--THE FIRST LINE IN THE CURRENT RECTANGLE
            NLOC = IN+2*(I-1)+1
C--NLOC IS THE SAME FOR THE SECOND LINE
            INCREMENTS(1,ISAVE)=M
            INCREMENTS(2,ISAVE)=N
            INCREMENTS(3,ISAVE)=I_BUF(INDEX)
C--SAVE LINES AND SAMPLES WHICH DEFINE THIS RECTANGLE
            INCREMENTS(4,ISAVE)=I_BUF(INDEX+1)
            INCREMENTS(5,ISAVE)=BUF(MLOC)+I_BUF(INDEX)
C--SAVE THE HORIZONTAL AND VERTICAL DISPLACEMENTS FOR LINE 1
            VMA=BUF(MLOC+1)
            INCREMENTS(6,ISAVE)=VMA+M
            TEMP=BUF(MLOC+2)
            TEMPM=BUF(MLOC)
            INCREMENTS(7,ISAVE)=1.0+((TEMP-TEMPM)/SAM)
            TEMP2=BUF(NLOC)
            TEMP=1.+(BUF(NLOC+2)-TEMP2)/SAM
            INCREMENTS(8,ISAVE)=(TEMP-INCREMENTS(7,ISAVE))/ROW
            INCREMENTS(9,ISAVE)=(TEMP2-TEMPM)/ROW
            TEMP=BUF(NLOC+1)
            INCREMENTS(10,ISAVE)=1.0+(TEMP-VMA)/ROW
            TEMP2=BUF(MLOC+3)
            TEMP=1.+(BUF(NLOC+3)-TEMP2)/ROW
            INCREMENTS(11,ISAVE)=(TEMP-INCREMENTS(10,ISAVE))/SAM
            INCREMENTS(12,ISAVE)=(TEMP2-VMA)/SAM
C--WORD 7 HAS THE DELTA P FOR M (M BEING LINE 1)- STEP SIZE FOR LINE
C--WORD 8 HAS DELTA L -INCREMENT TO STEP SIZE BETWEEN LINES M AND N
C--WORD 9 HAS DELTA M - INCREMENT TO FIRST POINT BETWEEN LINES
C--WORD 10 HAS DELTA L FOR A - STEP SIZE ALONG SAMPLES FOR A
C--WORD 11 HAS DELTA P -INCREMENT TO STEP SIZE BETWEEN SAMPLES A
C--        AND B
C--WORD 12 HAS DELTA A -INCREMENT TO FIRST POINT BETWEEN SAMPLES A
C--        AND B
C
C--INCREMENT TO GET NEXT SAMPLE FOR THIS LINE
            INDEX=INDEX+1
C
C--END SAMPLE PROCESSING LOOP
          END DO
C
C--END "IF (BUF(...).EQ.LINE)" BLOCK
        END IF
C
C--END PARAMETER STORING LOOP
      END DO
C
C--CHECK FOR EXIT CAUSED BY TOO MANY RECTANGLES
      IF (ISAVE.GE.MAXRPAR) THEN
        ISAVE = MAXRPAR
        CALL XVMESSAGE(RECTAN,' ')
      END IF
C--MAKE SURE TEST FOR LAST RECTANGLE ON LINE WORKS
      INCREMENTS(2,ISAVE+1) = 0
      RETURN
      END
