	INCLUDE 'VICMAIN_FOR'
C------------------------------------------------------------------------------
C FRACGEN
C Revisions:
C       12 March 1990, Megan O'Shaughnessy
C          Changed directory in which the scratch file is created, from
C          the default directory to V2$SCRATCH:.  (The scratch file takes up
C          lots of space (~8200 blocks in my runs of FRACGEN,) and if the user
C          didn't have enough file quota the program would abend.)  Also, 
C          mention that the scratch file is created was added to the help file.
C 	2-AUG-1993 by G. A. Madrid Jr.
C	   Deleted call to OPENSCRATCH subroutine because a reference to a
C	   specific VMS filename was coded into the CALL statement, which is
C	   does not lead to very portable code.  Instead, a new parameter was
C	   made up which allows the user the option of specifying the name of
C	   scratch file to be used and its location, making it more convenient
C	   to use and more portable.  This new parameter is called IDSNAM.
C	   LGEOM has a parameter by that same name, and users can refer to LGEOM
C 	   to see what its functionality is.
C        5-MAY-1994 by C.R. Schenk (CRI)
C          Corrected logic for seed generation and replaced random number
C          generator code with a new FUNCTION RANGEN.
C          RANGEN is an optional random number generator which will
C          generate the same random number sequence regardless of the
C          host platform (when the same seed is used on both machines).
C          This is useful for performance verification of the "portable"
C          code.  
C------------------------------------------------------------------------------
	SUBROUTINE MAIN44

	IMPLICIT NONE
	INTEGER	UNIT, SCRUNIT, COUNT, DEF, STATUS, SCRNUM
	INTEGER	NL,NS, NLFFT,NSFFT, LINE, SAMP
	INTEGER	SIGN, LOG2
	INTEGER SEED, BUF

        REAL*4  RAND_NUM
	REAL	Y2,R2, FILTER, S, PH, AMP, MAX
	REAL	FRACDIM, BETA, POWER
	REAL	MINVAL,MAXVAL, MAXFORMAT, SLOPE,OFFSET, SCPOW
	REAL	RBUFFER(4096)

	COMPLEX	CBUFFER(4096)
	COMPLEX	COLBUF(4096)
	CHARACTER*8 FORMAT
	CHARACTER*256 IDSNAM

	CALL IFMESSAGE('FRACGEN  version 1-JULY-1994')
	CALL XVEACTION('SA',' ')


C		GET THE INPUT PARAMETERS
	CALL XVP ('NL', NL, COUNT)
	CALL XVP ('NS', NS, COUNT)
	NLFFT = 2**( LOG2(NL-1) + 1)
	NSFFT = 2**( LOG2(NS-1) + 1)

	CALL XVP ('FRACDIM', FRACDIM, COUNT)

	CALL XVPARM ('SEED', SEED, COUNT, DEF,1)
	IF (COUNT .EQ. 0) THEN
            CALL GET_SECONDS(BUF)
	    SEED = MOD(BUF,2**24)
        ENDIF

	CALL XVP ('POWER', SCPOW, COUNT)

	CALL XVP ('FORMAT', FORMAT, COUNT)
	IF (FORMAT(1:4) .EQ. 'HALF') THEN
	    MAXFORMAT = 32767.0
	ELSE IF (FORMAT(1:4) .EQ. 'REAL') THEN
	    MAXFORMAT = 1.0
	ELSE
	    MAXFORMAT = 255.0
	ENDIF


C		CREATE AND OPEN THE SCRATCH FILE
	SCRNUM = 1
C------------------------------------------------------------------------------
c Change made, 3-12-1990 by M. O'Shaughnessy
c 	Changed filename of scratch file from 'fracgen.scr' to
c 	'v2$scratch:fracgen.scr'
c Change made, 2-AUG-1993 by G. A. Madrid Jr.
c	Substituted the value of parameter IDSNAM for the specification
c	'v2$scratch:fracgen.scr' which would only work in VMS.
C------------------------------------------------------------------------------
	CALL XVPARM('IDSNAM',IDSNAM,COUNT,DEF,0)
	CALL XVUNIT(SCRUNIT,' ',SCRNUM,STATUS,'U_NAME',IDSNAM,' ')

	CALL XVOPEN(SCRUNIT,STATUS,'OP','WRITE','U_NL',NLFFT,
     +			'U_NS',NSFFT,'O_FORMAT','REAL',
     +                  'COND','LABELS',' ')
	CALL XVCLOSE(SCRUNIT,STATUS,' ')

	CALL XVUNIT(SCRUNIT,' ',SCRNUM,STATUS,'U_NAME',IDSNAM,' ')
	CALL XVOPEN(SCRUNIT,STATUS,'OP','UPDATE','U_NL',NLFFT,
     +			'U_NS',NSFFT,'I_FORMAT','REAL','U_FORMAT','REAL',
     +			'O_FORMAT','REAL','COND','LABELS',' ')

	BETA = 2*(3.0 - FRACDIM) + 1.0
	POWER = -(1.+BETA)/4.0

C		MAKE THE POWER LAW NOISE
	DO LINE = 1, NLFFT
	    SIGN = (-1)**LINE
	    Y2 = ( FLOAT(MIN(LINE,NLFFT+2-LINE) - 1) /NLFFT )**2
	    DO SAMP = 1,NSFFT/2
		SIGN = -SIGN
		R2 = ( FLOAT(SAMP - 1) /NSFFT )**2 + Y2
		IF (R2 .NE. 0.0) THEN
		    FILTER = R2**POWER
   		    CALL RANGEN(SEED,RAND_NUM)
		    S = RAND_NUM
		    IF (RAND_NUM.LT.1.0E-10) THEN
                        S = 1.0E-10
                    ENDIF
		    AMP = FILTER*SQRT(-LOG(S))
   		    CALL RANGEN(SEED,RAND_NUM)
		    PH = 2.*3.14159*RAND_NUM
		    IF (SIGN .LT. 0)  PH = -PH
		    CBUFFER(SAMP) = AMP*CEXP((0,1)*PH)
		ENDIF
	    ENDDO
	    CALL XVWRIT (SCRUNIT, CBUFFER, STATUS, 'LINE',LINE,' ')
	ENDDO


C		TRANSFORM THE NOISE
	CALL FFTVICARR (SCRUNIT, NLFFT, NSFFT, -1, COLBUF)


C		SCALE THE FRACTIONAL NOISE
	MINVAL = +1.0E20
	MAXVAL = -1.0E20
	DO LINE = 1,NL
	    CALL XVREAD (SCRUNIT, RBUFFER, STATUS, 'LINE',LINE,' ')
	    DO SAMP = 1,NS
		MINVAL = MIN( MINVAL, RBUFFER(SAMP) )
		MAXVAL = MAX( MAXVAL, RBUFFER(SAMP) )
	    ENDDO
	ENDDO



	CALL XVUNIT (UNIT, 'OUT',1, STATUS,' ')
	CALL XVOPEN (UNIT, STATUS, 
     +		'OP','WRITE',  'U_FORMAT','REAL', 'O_FORMAT',FORMAT,
     +		'U_NL',NL, 'U_NS',NS,' ')


	SLOPE = MAXFORMAT/(MAXVAL-MINVAL)
	OFFSET = -MINVAL*SLOPE
	IF (FORMAT(1:4) .NE. 'REAL')  OFFSET = OFFSET + 0.5
	DO LINE = 1,NL
	    CALL XVREAD (SCRUNIT, RBUFFER, STATUS, 'LINE',LINE,' ')
	    DO SAMP = 1,NS
		RBUFFER(SAMP) = SLOPE*RBUFFER(SAMP) + OFFSET
		RBUFFER(SAMP) = MAXFORMAT*(RBUFFER(SAMP)/MAXFORMAT)**SCPOW
	    ENDDO
	    CALL XVWRIT (UNIT, RBUFFER, STATUS,' ')
	ENDDO

	CALL XVCLOSE (UNIT, STATUS,' ')
	CALL XVCLOSE (SCRUNIT, STATUS, 'CLOS_ACT','DELETE',' ')

	RETURN
	END


	SUBROUTINE FFTVICARC (UNIT, NLFFT, NSFFT, FFTSIGN)
C
C
C	FFTVICARC IS A TWO DIMENSIONAL FAST FOURIER TRANSFORM ROUTINE.
C	    IT DOES AN IN PLACE COMPLEX TO COMPLEX TRANSFORM
C	    ON AN EXISTING VICAR IMAGE.  THE COMPLEX IMAGE MUST BE ALREADY 
C	    OPENED FOR UPDATE WITH XVOPEN AND HAVE SIZE NLFFT BY NSFFT 
C	    WHICH MUST BE POWERS OF TWO.  THE SIGN (+1 OR -1) OF THE 
C	    TRANSFORM IS PASSED IN FFTSIGN.  THE MAXIMUM SIZE IN EITHER 
C	    DIRECTION IS 32768.
C	THE TRANSFORM DOES NOT TRANSPOSE THE IMAGE AND THE ZERO-FREQUENCY
C	    PIXEL IS AT THE FIRST LINE AND SAMPLE.
C
C
	IMPLICIT NONE
	INTEGER	UNIT, NLFFT, NSFFT, FFTSIGN
	INTEGER	MAXN, LINE, STATUS, BUFPTR
	INTEGER*2 BITREV(65536)
	COMPLEX BUFFER(256*256), PHASE(65536)

	COMMON	/BITREV/ BITREV
	COMMON  /PHASE/  PHASE


	MAXN = MAX(NLFFT,NSFFT)
	CALL MAKEBITREV (BITREV, MAXN)
	CALL MAKEPHASE (PHASE, FFTSIGN, MAXN)


	IF (NLFFT*NSFFT .GT. 256*256) THEN

	    DO LINE = 1, NLFFT
	        CALL XVREAD (UNIT, BUFFER, STATUS, 'LINE',LINE,' ')
	        CALL FFTC1D (BUFFER, NSFFT)
	        CALL XVWRIT (UNIT, BUFFER, STATUS, 'LINE',LINE,' ')
	    ENDDO

	    CALL FFTC1VD (UNIT, NSFFT, NLFFT)

	ELSE

	    DO LINE = 1, NLFFT
		BUFPTR = NSFFT*(LINE-1)+1
		CALL XVREAD (UNIT, BUFFER(BUFPTR), STATUS, 
     +		'LINE',LINE,' ')
		CALL FFTC1D (BUFFER(BUFPTR), NSFFT)
	    ENDDO
	    CALL FFTCV (BUFFER, NSFFT, NLFFT)
	    DO LINE = 1, NLFFT
		BUFPTR = NSFFT*(LINE-1)+1
		CALL XVWRIT (UNIT, BUFFER(BUFPTR), STATUS, 
     +		'LINE', LINE,' ')
	    ENDDO

	ENDIF

	RETURN
	END





	SUBROUTINE FFTVICARR (UNIT, NLFFT, NSFFT, FFTSIGN, COLBUF)
C
C
C	FFTVICARR IS A TWO DIMENSIONAL FAST FOURIER TRANSFORM ROUTINE.
C	    IT DOES AN IN PLACE REAL TO COMPLEX CONJUGATE OR COMPLEX
C	    CONJUGATE TO REAL TRANSFORM ON AN EXISTING VICAR IMAGE.  
C	    THE IMAGE MUST BE ALREADY OPENED FOR UPDATE WITH XVOPEN,
C	    WITH REAL FORMATS, AND HAVE REAL SIZE NLFFT BY NSFFT
C	    WHICH MUST BE POWERS OF TWO.  
C	    THE SIGN (+1 OR -1) OF THE TRANSFORM IS PASSED IN FFTSIGN.
C	    IF FFTSIGN = +1 THEN THE TRANSFORM IS REAL TO COMPLEX CONJUGATE
C	    AND IF FFTSIGN = -1 THEN THEN TRANSFORM IS THE OTHER WAY.
C	    COLBUF IS A COMPLEX ARRAY OF LENGTH EQUAL TO THE NUMBER OF ROWS.
C	      IT CONTAINS THE 'EXTRA' COLUMN FOR THE COMPLEX CONJUGATE FORMAT.
C	    THE MAXIMUM SIZE IN EITHER DIRECTION IS 32768.
C	THE TRANSFORM DOES NOT TRANSPOSE THE IMAGE AND THE ZERO-FREQUENCY
C	    PIXEL IS AT THE FIRST LINE AND SAMPLE.
C
C
	IMPLICIT NONE
	INTEGER	UNIT, NLFFT, NSFFT, FFTSIGN
	INTEGER	MAXN, LINE, STATUS, BUFPTR
	COMPLEX COLBUF(1)
	INTEGER*2 BITREV(65536)
	COMPLEX BUFFER(256*128), PHASE(65536)

	COMMON	/BITREV/ BITREV
	COMMON  /PHASE/  PHASE


	MAXN = MAX(NLFFT,NSFFT)
	CALL MAKEBITREV (BITREV, MAXN)
	CALL MAKEPHASE (PHASE, FFTSIGN, MAXN)


	IF (NLFFT*NSFFT .GT. 256*256) THEN 

	IF (FFTSIGN .EQ. +1) THEN
	    DO LINE = 1, NLFFT
		CALL XVREAD (UNIT, BUFFER, STATUS, 'LINE',LINE,' ')
		CALL FFTC1D (BUFFER, NSFFT/2)
		CALL FIXREAL (BUFFER, COLBUF(LINE), NSFFT/2, +1)
		CALL XVWRIT (UNIT, BUFFER, STATUS, 'LINE',LINE,' ')
	    ENDDO
	    CALL FFTC1D (COLBUF, NLFFT)
	    CALL FFTC1VD (UNIT, NSFFT/2, NLFFT)
	ELSE
	    CALL FFTC1VD (UNIT, NSFFT/2, NLFFT)
	    CALL FFTC1D (COLBUF, NLFFT)
	    DO LINE = 1, NLFFT
		CALL XVREAD (UNIT, BUFFER, STATUS, 'LINE',LINE,' ')
		CALL FIXREAL (BUFFER, COLBUF(LINE), NSFFT/2, -1)
		CALL FFTC1D (BUFFER, NSFFT/2)
		CALL XVWRIT (UNIT, BUFFER, STATUS, 'LINE',LINE,' ')
	    ENDDO
	ENDIF

	ELSE

	IF (FFTSIGN .EQ. +1) THEN
	    DO LINE = 1, NLFFT
		BUFPTR = (NSFFT/2)*(LINE-1)+1
		CALL XVREAD (UNIT, BUFFER(BUFPTR), STATUS, 
     +		'LINE',LINE,' ')
		CALL FFTC1D (BUFFER(BUFPTR), NSFFT/2)
		CALL FIXREAL (BUFFER(BUFPTR), COLBUF(LINE), NSFFT/2,+1)
	    ENDDO
	    CALL FFTCV (BUFFER, NSFFT/2, NLFFT)
	    CALL FFTC1D (COLBUF, NLFFT)
	    DO LINE = 1, NLFFT
		BUFPTR = (NSFFT/2)*(LINE-1)+1
		CALL XVWRIT (UNIT, BUFFER(BUFPTR), STATUS, 
     +		'LINE',LINE,' ')
	    ENDDO
	ELSE
	    DO LINE = 1, NLFFT
		BUFPTR = (NSFFT/2)*(LINE-1)+1
		CALL XVREAD (UNIT, BUFFER(BUFPTR), STATUS, 
     +		'LINE',LINE,' ')
	    ENDDO
	    CALL FFTC1D (COLBUF, NLFFT)
	    CALL FFTCV (BUFFER, NSFFT/2, NLFFT)
	    DO LINE = 1, NLFFT
		BUFPTR = (NSFFT/2)*(LINE-1)+1
		CALL FIXREAL (BUFFER(BUFPTR), COLBUF(LINE), NSFFT/2, -1)
		CALL FFTC1D (BUFFER(BUFPTR), NSFFT/2)
		CALL XVWRIT (UNIT, BUFFER(BUFPTR), STATUS, 
     +		'LINE',LINE,' ')
	    ENDDO
	ENDIF

	ENDIF

	RETURN
	END





	SUBROUTINE MAKEBITREV(BITREV,NMAX)
	IMPLICIT NONE
	INTEGER	I,IREV,J,K,L,M,LMAX,NMAX
	INTEGER*2 BITREV(1)
	INTEGER LOG2

	LMAX=LOG2(NMAX)
	I=0
	DO L=0,LMAX
	    IREV=0
	    DO J=0,2**L-1
		I=I+1
		BITREV(I)=IREV
		DO K=1,L
		    M=2**(L-K)
		    IF (IREV.LT.M) GO TO 70
		    IREV=IREV-M
		END DO
70		IREV=IREV+M
	    END DO
	END DO

	RETURN
	END



	SUBROUTINE MAKEPHASE (PHASE, SIGN, NMAX)
	IMPLICIT NONE
	INTEGER	I,J,L,LMAX,NMAX,SIGN, LOG2
	COMPLEX	PHASE(1)

	LMAX=LOG2(NMAX)
	J=0
	DO L=0,LMAX
	    DO I=0,2**L-1
		J=J+1
		PHASE(J) = CEXP(SIGN*2*3.1415926535*(0,1)*FLOAT(I)/2**L)
	    END DO
	END DO

	RETURN
	END




	SUBROUTINE FFTC1D (DATA, N)
	IMPLICIT NONE
	INTEGER	I,J,K,N,LN,M0,M1,JMAX,OFF,IDXPH,POWER, LOG2
	INTEGER*2 BITREV(65536)
	COMPLEX	DATA(1),TMP,PHASE(65536)
	COMMON	/BITREV/ BITREV
	COMMON  /PHASE/  PHASE

	LN = LOG2(N)
	DO I = 0,N-1
	    J = BITREV(I+N)
	    IF (J .GT. I) THEN
		TMP = DATA(I+1)
		DATA(I+1) = DATA(J+1)
		DATA(J+1) = TMP
	    END IF
	END DO

	M0 = 1
	M1 = 2
	JMAX = N/2
	DO J = 1,JMAX
	    TMP = DATA(M1)
	    DATA(M1) = DATA(M0) - TMP
	    DATA(M0) = DATA(M0) + TMP
	    M0 = M0 + 2
	    M1 = M1 + 2
	END DO

	DO I = 1,LN-1
	    POWER = 2**I
	    OFF = 2*POWER
	    M0 = 0
	    M1 = POWER
	    JMAX = 2**(LN-I-1)
	    DO J = 1,JMAX
		IDXPH = OFF
		DO K = 0,POWER-1
		    M0 = M0 + 1
		    M1 = M1 + 1
		    TMP = PHASE(IDXPH)*DATA(M1)
		    IDXPH = IDXPH + 1
		    DATA(M1) = DATA(M0) - TMP
		    DATA(M0) = DATA(M0) + TMP
		END DO
		M0 = M0 + POWER
		M1 = M1 + POWER
	    END DO
	END DO

	RETURN
	END





	SUBROUTINE FIXREAL(DATA,COLBUF,N,DIR)
	IMPLICIT NONE
	INTEGER N,DIR,I,ICONJ,IDXPH
	REAL PHR(2),TMPR
	COMPLEX DATA(1),COLBUF, PHASE(65536), TMP0,TMP1, PH
	EQUIVALENCE (PHR(1),PH)
	COMMON  /PHASE/  PHASE

	IDXPH = 2*N+1
	ICONJ = N

	IF (DIR .EQ. +1) THEN
	    COLBUF = REAL(DATA(1))-AIMAG(DATA(1))
	    DATA(1) = REAL(DATA(1))+AIMAG(DATA(1))
	    DO I = 2,N/2+1
		PH = PHASE(IDXPH)
		IDXPH = IDXPH + 1
		TMPR = PHR(1)		! MULT BY i
		PHR(1) = -PHR(2)
		PHR(2) = TMPR
		TMP0 = DATA(I)+CONJG(DATA(ICONJ))
		TMP1 = PH*( DATA(I)-CONJG(DATA(ICONJ)) )
		DATA(I) = (TMP0-TMP1)/2
		DATA(ICONJ) = CONJG(TMP0+TMP1)/2
		ICONJ = ICONJ-1
	    ENDDO
	ELSE
	    DATA(1) = ( REAL(DATA(1)) + REAL(COLBUF) )
     +			+ (0,1)*( REAL(DATA(1)) - REAL(COLBUF) )
	    DO I = 2,N/2+1
		PH = PHASE(IDXPH)
		IDXPH = IDXPH + 1
		TMPR = PHR(1)		! MULT BY -i
		PHR(1) = PHR(2)
		PHR(2) = -TMPR
		TMP0 = DATA(I)+CONJG(DATA(ICONJ))
		TMP1 = PH*( DATA(I)-CONJG(DATA(ICONJ)) )
		DATA(I) = TMP0-TMP1
		DATA(ICONJ) = CONJG(TMP0+TMP1)
		ICONJ = ICONJ-1
	    ENDDO
	ENDIF

	RETURN
	END




	SUBROUTINE FFTC1VD (UNIT, NS, NL)
	IMPLICIT NONE
	INTEGER	I,J,K,C,NS,NL,LNL,ROW0,ROW1,JMAX,OFF
	INTEGER*2 BITREV(65536)
	COMPLEX	PHASE(65536)
	INTEGER	POWER,STAT, LOG2, UNIT
	COMPLEX	DATA0(32768),DATA1(32768),TMP0,TMP1,PH
	COMMON	/BITREV/ BITREV
	COMMON  /PHASE/  PHASE

	LNL=LOG2(NL)
	DO I=0,NL-1
	    J=BITREV(I+NL)
	    IF (J.GT.I) THEN
		CALL XVREAD(UNIT, DATA0, STAT, 'LINE',I+1,' ')
		CALL XVREAD(UNIT, DATA1, STAT, 'LINE',J+1,' ')
		CALL XVWRIT(UNIT, DATA0, STAT, 'LINE',J+1,' ')
		CALL XVWRIT(UNIT, DATA1, STAT, 'LINE',I+1,' ')
	    END IF
	END DO


	DO I=0,LNL-1
	    JMAX=2**(LNL-I-1)
	    POWER=2**I
	    OFF=2*POWER
	    DO J=0,JMAX-1
		ROW0=OFF*J
		ROW1=ROW0+POWER
		DO K=0,POWER-1
		    ROW0=ROW0+1
		    ROW1=ROW1+1
		    PH=PHASE(K+OFF)
		    CALL XVREAD(UNIT, DATA0, STAT, 'LINE',ROW0,' ')
		    CALL XVREAD(UNIT, DATA1, STAT, 'LINE',ROW1,' ')
		    DO C=1,NS
			TMP0=DATA0(C)
			TMP1=PH*DATA1(C)
			DATA0(C)=TMP0+TMP1
			DATA1(C)=TMP0-TMP1
		    END DO
		    CALL XVWRIT(UNIT, DATA0, STAT, 'LINE',ROW0,' ')
		    CALL XVWRIT(UNIT, DATA1, STAT, 'LINE',ROW1,' ')
		END DO
	    END DO
	END DO

	RETURN
	END




	SUBROUTINE FFTCV(DATA,NS,NL)
	IMPLICIT NONE
	INTEGER	I,J,K,C,NS,NL,LNL,M0,M1,JMAX,OFF, LOG2
	INTEGER POWER,IDXPH
	INTEGER*2 BITREV(65536)
	COMPLEX	DATA(1),TMP,PHASE(65536),PH
	COMMON	/BITREV/ BITREV
	COMMON  /PHASE/  PHASE

	LNL = LOG2(NL)
	DO I = 0,NL-1
	    J = BITREV(I+NL)
	    IF (J .GT. I) THEN
		M0 = NS*I
		M1 = NS*J
		DO C = 1,NS
		    M0 = M0 + 1
		    M1 = M1 + 1
		    TMP = DATA(M0)
		    DATA(M0) = DATA(M1)
		    DATA(M1) = TMP
		END DO
	    END IF
	END DO


	DO I = 0,LNL-1
	    JMAX = 2**(LNL-I-1)
	    POWER = 2**I
	    OFF = 2*POWER
	    M0 = 0
	    M1 = POWER*NS
	    DO J = 0,JMAX-1
		IDXPH = OFF
		DO K = 0,POWER-1
		    PH = PHASE(IDXPH)
		    IDXPH = IDXPH + 1
		    DO C = 1,NS
			M0 = M0 + 1
			M1 = M1 + 1
			TMP = PH*DATA(M1)
			DATA(M1) = DATA(M0) - TMP
			DATA(M0) = DATA(M0) + TMP
		    END DO
		END DO
		M0 = M0 + POWER*NS
		M1 = M1 + POWER*NS
	    END DO
	END DO

	RETURN
	END




	INTEGER FUNCTION LOG2(N)
	IMPLICIT NONE
	INTEGER	N
	LOG2 = 2
	DO WHILE (ISHFT(N,-LOG2) .GT. 0)
	    LOG2 = LOG2 + 1
	ENDDO
	LOG2 = LOG2 - 1
	RETURN
	END
