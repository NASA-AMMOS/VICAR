      INCLUDE 'VICMAIN_FOR'

      SUBROUTINE MAIN44
      EXTERNAL PLRECT
      EXTERNAL TEST
      INTEGER  IBLK, JBLK

      CALL IFMESSAGE('POLARECT version 27-Oct-2010')
      IBLK = 0
      JBLK = 0
c     CALL STACKA(7,TEST,4,10000,(IBLK+1)/2*2,(JBLK+1)/2*2,1000000,IGOT)
c     CALL STACKA(7,PLRECT,4,10000,(IBLK+1)/2*2,(JBLK+1)/2*2,IGOT,*900)
c (lwk:) above calls caused a crash on Sun-Solaris (AR-116326) -- but not
c when compiled with debug!  revised to:
      ii = (IBLK+1)/2*2
      jj = (JBLK+1)/2*2
c (note that both ii and jj are 0, but stacka changes this to 1)
c the call to subr.test seems completely pointless -- replacing it with
c 'igot=1000000-2048' gives the same result;  but it does no harm, so is
c retained ...
      CALL STACKA(7,TEST,4,10000,ii,jj,1000000,IGOT)
      CALL STACKA(7,PLRECT,4,10000,ii,jj,IGOT,*900)
  900 CONTINUE
      RETURN
      END
C*****************************************************************
      SUBROUTINE TEST(BUF1,I,BUF2,J,BUF3,K,BUF4,L,IGOT)
      IMPLICIT INTEGER(A-Z)
      INTEGER BUF1(I),BUF2(J),BUF3(K),BUF4(L)
      IGOT=L-2048
      RETURN
      END
C*****************************************************************
      SUBROUTINE PLRECT(OUT,KX,ABUF,IALT,BBUF,JALT,IN,IBFSIZ,*)
C
C----  VICAR PROGRAM POLARECT 
C
C     PURPOSE... COORDINATE TRANSFORMATION PROGRAM FROM RECTANGULAR TO
C        POLAR COORDINATES (DEFAULT) OR INVERSE.
C
C     PARAMETERS...INVERSE---TRANSFORMATION FROM POLAR TO RECTANGULAR
C                             COORDINATES IS TO BE PERFORMED.
C                  XCEN,X---SAMPLE COORDINATE FOR RECTANGULAR PICTURE
C                             ORIGIN (REAL).
C                  YCEN,Y---LINE COORDINATE FOR RECTANGULAR PICTURE
C                             ORIGIN (REAL).
C                  RANGE,A1,A2---MINIMUM A1 AND MAXIMUM A2 ANGLES TO BE
C                             INCLUDED IN COORDINATE TRANSFORMATION (REA
C                  RMIN,R1---MINIMUM RADIUS FROM RECTANGULAR ORIGIN TO
C                             BE INCLUDED (REAL).
C                  RMAX,R2---MAXIMUM RADIUS FROM RECTANGULAR ORIGIN TO
C                             BE INCLUDED (REAL)
C                  RESOLUTION,A3---ANGULAR RESOLUTION BETWEEN POLAR
C                             PICTURE LINES (REAL).
C                  RSCALE,S---RADIAL COMPRESSION PARAMETER
C                             RPOLAR=S*RRECT (REAL).
C                  BACK,I---BACKGROUND DN LEVEL WHERE INPUT PICTURE IS
C                             NON-EXISTENT FOR OUTPUT PICTURE(INTEGER).
C                  NOINTERP---NO INTERPOLATION IS TO BE PERFORMED, NEAREST
C                             INPUT PIXEL IS USED FOR OUTPUT.
C                  NOLABEL---FOR THE POLAR TO RECTANGULAR MODE, NO
C                             LABELS ARE TO BE WRITTEN ONTO THE OUTPUT
C                             DATA SET SPECIFYING THE TRANSFORMATION
C                             PARAMETERS.  FOR THE INVERSE MODE, THIS
C                             PARAMETER SPECIFIES THAT THERE IS NO
C                             LABEL ON THE INPUT DATA SET SPECIFYING
C                             THE TRANSFORMATION PARAMETERS.  DEFAULT
C                             IS THAT LABELS ARE ASSUMED TO BE WRITTEN
C                             AND THAT THEY EXIST FOR THE INVERSE MODE.
C
C***********************************************************************
C
C     VARIABLE MEANINGS...
C        SL,SS,NLO,NSO,NL,NS...SIZE FIELD PARAMETERS.
C        HALF...0 IF BYTE, 1 IF HALFWORD.
C        XCEN,YCEN...SPECIFIED RECTANGULAR ORIGIN OF COORDINATE TRANSFOR
C        RMIN,RMAX...MIN & MAX RADIUS FROM ORIGIN IN INPUT PICTURE.
C        PHIMIN,PHIMAX...MIN & MAX ANGLE IN POLAR PICTURE AS MEASURED
C              CLOCKWISE FROM +X-DIRECTION IN RECTANGULAR PICTURE.
C        RESO...ANGULAR RESOLUTION IN DEGREES/PIXEL (RADIANS/PIXEL).
C        SCALE...RPOLAR=SCALE*RRECT
C        INVER...0 FOR RECTANGULAR TO POLAR, 1 FOR INVERSE
C        IFLAG...INTERPOLATION FLAG. 0 FOR INTERPOLATION, 1 FOR NOINTERP.
C        NBL...NUMBER OF INPUT PICTURE LINES WHICH WILL FIT INTO CORE.
C
C***********************************************************************
C***********************************************************************
      INTEGER*4 XCENDF,YCENDF,RMAXDF,RMINDF,RESODF,RANGDF,RSCALEDF,
     *          BACKDF
      INTEGER SL,SS,NL,NS,NLO,NSO,HALF,BUFSIZ
      REAL XCEN,YCEN,RMIN,RMAX,RESO,PHIMIN,PHIMAX,TPI
C      BYTE IN(1)
      INTEGER*2 OUT(1)
      INTEGER*4 BACK,RANG(2)
      BYTE ABUF(1),BBUF(1),IN(1)
      INTEGER*4 STATUS
      CHARACTER*132 MG1
      CHARACTER*132 MG2
      CHARACTER*132 MG3
      CHARACTER*132 MG4
      CHARACTER*132 MG6
      CHARACTER*132 MG5
      CHARACTER*132 MCMPLT
      CHARACTER*132 MSIZE
      CHARACTER*4 FBYTE,FHALF,CSFORMAT

      LOGICAL INVERSE,NOINTERP,NOLABEL,AUTO,XVPTST

      COMMON /C1/ RUNIT,WUNIT,SL,SS,NL,NS,NLO,NSO,HALF,BACK
      COMMON /C2/ RESO,PHIMIN,PHIMAX,XCEN,YCEN,IFLAG,RMIN,RMAX,SCALE
      COMMON/DEFS/XCENDF,YCENDF,RMAXDF,RMINDF,RESODF,RANGDF,RSCALEDF,
     *          BACKDF
     

      DATA IAUTO,INVER,IFLAG,HALF,BACK/5*0/
      DATA RMIN,RMAX,RESO,PHIMIN,PHIMAX,SCALE,XCEN,YCEN/8*0./
      DATA LAB/1/
      DATA TPI/6.2831852/

C
C*** INITIALIZATION SECTION ***
C
      FHALF =  'HALF'
      FBYTE =  'BYTE'

      MG1(1:57) = '  INPUT IMAGE STATISTICS FOR XCEN=        , YCEN='
      MG2(1:24) = '   SIZE: NL=     NS=    '
      MG3(1:50) = '   ANGULAR RANGE: PHIMIN=        , PHIMAX='
      MG4(1:45) = '   RADIAL RANGE: RMIN=        , RMAX='
      MG5(1:56) = 
     + '   OPTIMAL ANGULAR RESOLUTION=         YIELDS      LINES'
      MG6(1:54) =
     + '   OPTIMAL RADIAL SCALE=   1.000 YIELDS       SAMPLES'
      MCMPLT(1:26) = '      INPUT LINES COMPLETE'
      WRITE (MSIZE,9900) IBFSIZ
9900  FORMAT (' WORK CORE AVAILABLE=',I7,' BYTES')
      CALL XVMESSAGE(MSIZE(2:34),' ')
      BUFSIZ=IBFSIZ
C
C     SET UP TRANSLATION BUFFER 
C


C
C*** PARAMETER PROCESSOR ***
C
      CALL XVPARM('XCEN',XCEN,NXCEN,XCENDF,1)
      CALL XVPARM('YCEN',YCEN,NYCEN,YCENDF,1)
      CALL XVPARM('RMAX',RMAX,NRMAX,RMAXDF,1)
      CALL XVPARM('RMIN',RMIN,NRMIN,RMINDF,1)
      CALL XVPARM('RESO',RESO,NRESO,RESODF,1)
      CALL XVPARM('RANGE',RANG,NRANG,RANGDF,1)
      CALL XVPARM('RSCALE',RSCALE,NRSCALE,RSCALEDF,1)
      CALL XVPARM('BACK',BACK,NBACK,BACKDF,1)
      NOINTERP=XVPTST('NOINTERP')
      INVERSE = XVPTST('INVERSE')
      NOLABEL = XVPTST('NOLABEL')
      AUTO = XVPTST('AUTO')
      RESO=RESO*TPI/360.
      PHIMIN=RANG(1)*TPI/360.
      PHIMAX=RANG(2)*TPI/360.
      IF(NOINTERP) IFLAG=1
      SCALE=RSCALE
      IF(INVERSE) INVER=1
      IF(NOLABEL) LAB=0
      IF(AUTO) IAUTO=1
C
C---- OPEN DATA SETS FOR PROCESSING
C
      CALL XVUNIT(RUNIT,'INP',1,STATUS,' ')
      CALL XVOPEN(RUNIT,STATUS,'OP','READ','OPEN_ACT','SA',' ')
      CALL XVSIZE(SL,SS,NLO,NSO,NL,NS)
      CALL XVGET(RUNIT,STATUS,'FORMAT',CSFORMAT,' ')
      IF(STATUS.NE.1) THEN
	CALL XVMESSAGE('TEST POINT: BAD STATUS FROM XVGET',' ')
        CALL ABEND
      ENDIF

      IF(CSFORMAT.EQ.FHALF) HALF=1
      IF(CSFORMAT.EQ.FBYTE) HALF=0

      NBYTES = (1+HALF)*NS
      SL = SL-1
      SS = SS-1
      NL = NL-SL
      NS = NS-SS
      CALL XVUNIT(WUNIT,'OUT',1,STATUS,' ')
      CALL XVOPEN(WUNIT,STATUS,'OP','WRITE','U_NL',NLO,'U_NS',NSO,
     * 'O_FORMAT',CSFORMAT,'U_FORMAT',FHALF,'OPEN_ACT','SA',' ')
C
C     WRITE BACKGROUND DN ONTO OUTPUT PICTURE.
C
      CALL MVE(-5-HALF,NSO,BACK,IN,0,1)
      DO 21 I=1,NLO
         CALL XVWRIT(WUNIT,IN,STATUS,' ')
   21 CONTINUE
      CALL XVCLOSE(WUNIT,STATUS,' ')
      CALL XVOPEN(WUNIT,STATUS,'OP','UPDATE',
     * 'O_FORMAT',CSFORMAT,'U_FORMAT',FHALF,'OPEN_ACT','SA',' ')
C
C---- BEGIN EXECUTION
C
      IF(INVER .EQ. 1) GO TO 200
C
C***** RECTANGULAR TO POLAR SECTION *****
C
C
C     SET PHIMIN,PHIMAX,RESO,RMIN,RMAX,SCALE IF PREVIOUSLY UNSPECIFIED.
C
      IF(XCENDF .EQ. 1) XCEN=NS/2.
      IF(YCENDF .EQ. 1) YCEN=NL/2.
      WRITE (MG1(35:42),'(F8.3)') XCEN
      WRITE (MG1(50:57),'(F8.3)') YCEN
      CALL XVMESSAGE(MG1(2:57),' ')
      WRITE (MG2(13:16),'(I4)') NL
      WRITE (MG2(21:24),'(I4)') NS
      CALL XVMESSAGE(MG2(2:24),' ')
      CALL LIMITS(A,B,XCEN,YCEN,NS,NL)
      WRITE (MG3(26:33),'(F8.4)') A*360./TPI
      WRITE (MG3(43:50),'(F8.4)') B*360./TPI
      CALL XVMESSAGE(MG3(2:50),' ')
      IF(RANGDF .EQ. 1) PHIMIN=A
      IF(RANGDF .EQ. 1) PHIMAX=B
      CALL MAXRAD(C,D,XCEN,YCEN,NS,NL)
      WRITE (MG4(23:30),'(F8.3)') D
      WRITE (MG4(38:45),'(F8.3)') C
      CALL XVMESSAGE(MG4(2:45),' ')
      IF(RMINDF .EQ. 1) RMIN=D
      IF(RMAXDF .EQ. 1) RMAX=C
      CALL RESCIR(E,C)
      WRITE (MG5(31:38),'(F8.5)') E*360./TPI
      WRITE (MG5(47:50),'(I4)') NINT((B-A)/E+1.)
      CALL XVMESSAGE(MG5(2:56),' ')
      IF(RESODF .EQ. 1) RESO=E
      WRITE (MG6(41:44),'(I4)') NINT(C-D+1.)
      CALL XVMESSAGE(MG6(2:52),' ')
      IF(RSCALEDF .EQ. 1) SCALE=1.
      IF(IAUTO .EQ. 0 .OR. NLO .EQ. 1 .OR. NSO .EQ. 1) GO TO 23
      RESO=(PHIMAX-PHIMIN)/(NLO-1.)
      SCALE=(RMAX-RMIN)/(NSO-1.)
23    IF((PHIMAX-PHIMIN)/RESO .GT. NLO-1.)
     *   PHIMAX=PHIMIN+RESO*(NLO-1.)
      IF((RMAX-RMIN)/SCALE .GT. NSO-1.)
     *   RMAX=RMIN+SCALE*(NSO-1.)
      MG1(2:7) = 'OUTPUT'
      CALL XVMESSAGE(MG1(2:24),' ')
      WRITE (MG2(13:16),'(I4)') NLO
      WRITE (MG2(21:24),'(I4)') NSO
      CALL XVMESSAGE(MG2(2:24),' ')
      WRITE (MG3(26:33),'(F8.4)') PHIMIN*360./TPI
      WRITE (MG3(43:50),'(F8.4)') PHIMAX*360./TPI
      CALL XVMESSAGE(MG3(2:50),' ')
      WRITE (MG4(23:30),'(F8.3)') RMIN
      WRITE (MG4(38:45),'(F8.3)') RMAX
      CALL XVMESSAGE(MG4(2:45),' ')
      MG5(1:10) = ' '
      WRITE (MG5(31:38),'(F8.5)') RESO*360./TPI
      CALL XVMESSAGE(MG5(2:38),' ')
      MG6(1:10) = ' '
      WRITE (MG6(25:32),'(F8.5)') SCALE
      CALL XVMESSAGE(MG6(2:32),' ')
C     CALL QPRINT(MG6(9),24)
C
C     PERFORM LABEL PROCESSING IF DESIRED.
C
      IF(LAB.EQ.1) CALL ALABEL(0)
C
C     FIND NUMBER OF LINES OF INPUT WHICH WILL FIT INTO CORE, DECREMENT
C     BY 1 FOR OVERLAP, AND CALL POLAR FOR EACH SECTION OF PICTURE.
C
      NBL=BUFSIZ/NBYTES
      N=NBL-1
      DO 100 I=1,NL,N
	 CALL POLAR(I,NBL,NBYTES,IN,OUT)
         WRITE (MCMPLT(2:5),'(I4)') MIN0(I+N-1,NL)
         CALL XVMESSAGE(MCMPLT(2:26),' ')
100   CONTINUE
      GO TO 300
C
C***** POLAR TO RECTANGULAR SECTION *****
C
200   CONTINUE
      CALL QPRINT(' INVERSE MODE SPECIFIED',23)
C
C     FIND NUMBER OF INPUT LINES WHICH WILL FIT INTO THE CORE BUFFER,
C     DECREMENT BY 1 FOR OVERLAP, AND CALL RECT FOR EACH SECTION OF
C     PICTURE.
C
      NBL=BUFSIZ/NBYTES
      N=NBL-1
C
C     PERFORM LABEL PROCESSING IF SPECIFIED (OBTAIN NECESSARY PARAMS
C     FROM INPUT PICTURE LABEL).
C
      IF(LAB.EQ.1) THEN
        CALL ALABEL(1)
      ELSE
C
C----    MAKE ANY NECESSARY DEFAULT VALUES
C
         IF(RANGDF.EQ. 1) PHIMIN=0.
         IF(RANGDF .EQ. 1) PHIMAX=TPI
         IF(RESODF .EQ. 1) RESO=(PHIMAX-PHIMIN)/(NL-1)
         IF(RMINDF .EQ. 1) RMIN=0.
         IF(RMAXDF .EQ. 1) RMAX=RMIN+NS-1.
         IF(RSCALEDF .EQ. 1) SCALE=(RMAX-RMIN)/(NS-1.)
         IF(XCENDF .EQ. 1) XCEN=NSO/2.
         IF(YCENDF .EQ. 1) YCEN=NLO/2.
      ENDIF
      DO 202 I=1,NL,N
         CALL RECT(I,NBL,NBYTES,IN,OUT)
         WRITE (MCMPLT(2:5),'(I4)') MIN0(I+N-1,NL)
         CALL XVMESSAGE(MCMPLT(2:26),' ')
202   CONTINUE
C
C---- CLOSE FILES AND EXIT.
C
300   CONTINUE
      CALL XVCLOSE(RUNIT,STATUS,' ')
      CALL XVCLOSE(WUNIT,STATUS,' ')
      RETURN
      END
C***********************************************************
      SUBROUTINE LIMITS(PHIMIN,PHIMAX,X,Y,NS,NL)
C
C        SUBROUTINE LIMITS FINDS THE MAXIMUM & MINIMUM ANGLES WHICH
C        CONTAIN THE INPUT PICTURE WITH RESPECT TO THE ORIGIN (X,Y)
C
      REAL PHIMIN,PHIMAX
      TPI=6.2831852
      A=NS
      B=NL
      IF(X .LT. 1) GO TO 1
      IF(X .GT. NS) GO TO 2
      IF(Y .LT. 1) GO TO 40
      IF(Y .GT. NL) GO TO 60
      IF(X .EQ. 1..AND. Y .EQ. 1.) GO TO 100
      IF(X .EQ. 1..AND. Y .EQ. NL) GO TO 101
      IF(X .EQ. NS .AND. Y .EQ. 1.) GO TO 102
      IF(X .EQ. NS .AND. Y .EQ. NL) GO TO 103
      GO TO 50
1     IF(Y .LT. 1.) GO TO 10
      IF(Y .GT. NL) GO TO 30
      GO TO 20
2     IF(Y .LT. 1.) GO TO 70
      IF(Y .GT. NL) GO TO 90
      GO TO 80
C
C     CASE 1... X .LT. 1, Y .LT. 1
C
10    PHIMIN=ATAN2(1.-Y,A-X)
      PHIMAX=ATAN2(B-Y,1.-X)
      GO TO 200
C
C     CASE 2... X .LT. 1, 1 .LE. Y .LE. NL
C
20    PHIMIN=ATAN2(1.-Y,1.-X)
      PHIMAX=ATAN2(B-Y,1.-X)
      GO TO 200
C
C     CASE 3... X .LT. 1, Y .GT. NL
C
30    PHIMIN=ATAN2(1.-Y,1.-X)+TPI
      PHIMAX=ATAN2(B-Y,A-X)+TPI
      GO TO 200
C
C     CASE 4... 1 .LE. X .LE. NS, Y .LT. 1
C
40    PHIMIN=ATAN2(1.-Y,A-X)
      PHIMAX=ATAN2(1.-Y,1.-X)
      GO TO 200
C
C     CASE 5... 1 .LE. X .LE. NS, 1 .LE. Y .LE. NL
C
50    PHIMIN=0.
      PHIMAX=TPI
      GO TO 200
C
C     CASE 6... 1 .LE. X .LE. NS, Y .GT. NL
C
60    PHIMIN=ATAN2(B-Y,1.-X)+TPI
      PHIMAX=ATAN2(B-Y,A-X)+TPI
      GO TO 200
C
C     CASE 7... X .GT. NS, Y .LT. 1
C
70    PHIMIN=ATAN2(B-Y,A-X)
      PHIMAX=ATAN2(1.-Y,1.-X)
      GO TO 200
C
C     CASE 8... X .GT. NS, 1 .LE. Y .LE. NL
C
80    PHIMIN=ATAN2(B-Y,A-X)
      PHIMAX=ATAN2(1.-Y,A-X)+TPI
      GO TO 200
C
C     CASE 9... X .GT. NS, Y .GT. NL
C
90    PHIMIN=ATAN2(B-Y,1.-X)+TPI
      PHIMAX=ATAN2(1.-Y,A-X)+TPI
      GO TO 200
C
C     CASE 10A... X .EQ. 1, Y .EQ. 1
C
100   PHIMIN=0.
      PHIMAX=TPI/4.
      GO TO 200
C
C     CASE10B... X .EQ. 1 Y .EQ. NL
C
101   PHIMIN=TPI*3./4.
      PHIMAX=TPI
      GO TO 200
C
C     CASE 10C... X .EQ. NS, Y .EQ. 1
C
102   PHIMIN=TPI/4.
      PHIMAX=TPI/2.
      GO TO 200
C
C     CASE 10D... X .EQ. NS, Y .EQ. NL
C
103   PHIMIN=TPI/2.
      PHIMAX=TPI*3./4.
      GO TO 200
C
C     RETURN ANSWERS...
C
200   CONTINUE
      RETURN
      END
C******************************************************************
      SUBROUTINE MAXRAD(RMAX,RMIN,X,Y,NS,NL)
C
C        SUBROUTINE MAXRAD FINDS THE MINIMUM & MAXIMUM RADII WHICH
C        CONTAINS THE INPUT PICTURE WITH RESPECT TO THE ORIGIN (X,Y).
C
      A=NS
      B=NL
      IF(X .LE. A/2.) GO TO 10
      IF(Y .LE. B/2.) GO TO 5
C
C     MAXIMUM DISTANCE IS TO (X,Y)=(1,1)
      C=1.-X
      D=1.-Y
      GO TO 100
C
C     MAXIMUM DISTANCE IS TO (X,Y)=(1,NL)
5     C=1.-X
      D=B-Y
      GO TO 100
10    IF(Y .LE. B/2.) GO TO 15
C
C     MAXIMUM DISTANCE IS TO (X,Y)=(NS,1)
      C=A-X
      D=1.-Y
      GO TO 100
C
C     MAXIMUM DISTANCE IS TO (X,Y)=(NS,NL)
15    C=A-X
      D=B-Y
      GO TO 100
C
C     CALCULATE MAXIMUM DISTANCE
C
100   RMAX=SQRT(C*C+D*D)
C     CALCULATE RMIN
      IF(X .LT. 1.) GO TO 20
      IF(X .GT. A) GO TO 35
      IF(Y .LT. 1.) GO TO 50
      IF(Y .GT. B) GO TO 55
      RMIN=0.
      GO TO 103
20    IF(Y .LT. 1.) GOTO 25
      IF(Y .GT. B) GO TO 30
C
C        MINIMUM DISTANCE IS TO COLUMN 1.
      RMIN=1.-X
      GO TO 103
C
C        MINIMUM DISTANCE IS TO (X,Y)=(1,1)
25    C=1.-X
      D=1.-Y
      GO TO 102
C
C        MINIMUM DISTANCE IS TO (X,Y)=(1,NL)
30    C=1.-X
      D=B-Y
      GO TO 102
35    IF(Y .LT. 1) GO TO 40
      IF(Y .GT. B) GO TO 45
C
C        MINIMUM DISTANCE IS TO COLUMN NS.
      RMIN=X-A
      GO TO 103
C
C        MINIMUM DISTANCE IS TO (X,Y)=(NS,1).
40    C=A-X
      D=1.-Y
      GO TO 102
C
C        MINIMUM DISTANCE IS TO (X,Y)=(NS,NL).
45    C=A-X
      D=B-Y
      GO TO 102
C
C        MINIMUM DISTANCE IS TO LINE 1.
50    RMIN=1.-Y
      GO TO 103
C
C        MINIMUM DISTANCE IS TO LINE NL.
55    RMIN=Y-B
      GO TO 103
C
C        CALCULATE MINIMUM DISTANCE
102   RMIN=SQRT(C*C+D*D)
103   CONTINUE
      RETURN
      END
C************************************************************
      SUBROUTINE RESCIR(RESO,RMAX)
C        SUBROUTINE RESCIR FINDS THE OPTIMUM ANGULAR RESOLUTION FOR A
C        POLAR COORDINATE PICTURE.
      REAL RESO,RMAX
      RESO=ATAN(1./RMAX)
      RETURN
      END
C************************************************************
      SUBROUTINE POLAR(LN,NBL,NBYTES,IN,OUT)
C        SUBROUTINE POLAR PERFORMS THE RECTANGULAR TO POLAR XFORM.
      INTEGER SL,SS,HALF,BACK
      INTEGER*2 OUT(1)
      BYTE IN(NBYTES,NBL)
      REAL RESO,PHIMIN,PHIMAX,XCEN,YCEN

      COMMON /C1/ RUNIT,WUNIT,SL,SS,NL,NS,NLO,NSO,HALF,BACK
      COMMON /C2/ RESO,PHIMIN,PHIMAX,XCEN,YCEN,IFLAG,RMIN,RMAX,SCALE

      LINE=LN-1+SL
      NLN=NBL
      IF(NLN+LN .GT. NL) THEN
	 NLN=NL-LN+1
      ENDIF
C
C        READ SECTION OF INPUT INTO CORE
      DO 1 I=1,NLN
         CALL XVREAD(RUNIT,IN(1,I),STATUS,'LINE',LINE+I,'SAMP',SS+1,
     *               'NSAMPS',NS,' ')
    1 CONTINUE
C
C        PROCESS EACH OUTPUT LINE FOR EACH SECTION OF INPUT
      DO 2 I=1,NLO
         CALL XVREAD(WUNIT,OUT,STATUS,'LINE',I,'NSAMPS',NSO,' ')
         PHI=PHIMIN+(I-1)*RESO
         IF(PHI .GT. PHIMAX) GO TO 2
         COSPHI=COS(PHI)
         SINPHI=SIN(PHI)
         CALL POLA(NLN,IN,OUT,LN,COSPHI,SINPHI)
C
C----    WRITE NEW OUTPUT LINE
C
         CALL XVWRIT(WUNIT,OUT,STATUS,'LINE',I,'NSAMPS',NSO,' ')

2     CONTINUE
      RETURN
      END
C************************************************************
      SUBROUTINE RECT(LN,NBL,NBYTES,IN,OUT)
C        SUBROUTINE RECT PERFORMS AN INVERSE POLAR TRANSFORMATION, I.E.,
C        IT TRANSFORMS A POLAR COORDINATE PICTURE TO A RECTANGULAR
C        COORDINATE PICTURE.
C
      INTEGER SL,SS,HALF,BACK
      INTEGER*2 OUT(1)
      BYTE IN(NBYTES,NBL)
      REAL RESO,PHIMIN,PHIMAX,XCEN,YCEN,RMIN,RMAX,SCALE

      COMMON /C1/ RUNIT,WUNIT,SL,SS,NL,NS,NLO,NSO,HALF,BACK
      COMMON /C2/ RESO,PHIMIN,PHIMAX,XCEN,YCEN,IFLAG,RMIN,RMAX,SCALE

      LINE=LN-1+SL
      NLN=NBL
      IF(NLN+LN .GT. NL) NLN=NL-LN+1
      DO 1 I=1,NLN
         CALL XVREAD(RUNIT,IN(1,I),STATUS,'LINE',LINE+I,'SAMP',SS+1,
     *               'NSAMPS',NS,' ')
    1 CONTINUE
      DO 2 I=1,NLO
         CALL XVREAD(WUNIT,OUT,STATUS,'LINE',I,'NSAMPS',NSO,' ')
         CALL RECTA(NLN,IN,OUT,LN,I)
         CALL XVWRIT(WUNIT,OUT,STATUS,'LINE',I,'NSAMPS',NSO,' ')
    2 CONTINUE
      RETURN
      END
C************************************************************
      SUBROUTINE ALABEL(IND)
C        SUBROUTINE ALABEL EITHER WRITES OUT THE TRANSFORMATION PARAMS
C        TO THE OUTPUT DATA SET, OR OBTAINS THEM FROM THE INPUT DATA
C        SET LABEL, DEPENDING ON THE MODE.
C
      INTEGER*4 XCENDF,YCENDF,RMAXDF,RMINDF,RESODF,RANGDF,RSCALEDF,
     *          BACKDF
      INTEGER*4 STATUS
      CHARACTER*80 MG1
      CHARACTER*80 MG3
      CHARACTER*80 MG2

      COMMON /C1/ RUNIT,WUNIT,SL,SS,NL,NS,NLO,NSO,HALF,BACK
      COMMON /C2/ RESO,PHIMIN,PHIMAX,XCEN,YCEN,IFLAG,RMIN,RMAX,SCALE
      COMMON/DEFS/XCENDF,YCENDF,RMAXDF,RMINDF,RESODF,RANGDF,RSCALEDF,
     *          BACKDF

      MG1= 
     + '         PHIMIN=           AT LINE 1, PHIMAX=           AT LINE'
      MG2=
     + '         RMIN=           AT SAMP 1, RMAX=           AT SAMP'
      MG3=
     + '         CENTER OF TRANSFORMATION XCEN=         , YCEN='

C      CHARACTER*72 M1
C      M1 =
C    + '         PHIMIN=XXXXXXXXXX AT LINE 1, PHIMAX=XXXXXXXXXX AT LINE'
C      CHARACTER*72 M2
C      M2 =
C    + '         RMIN=XXXXXXXXXX AT SAMP 1, RMAX=XXXXXXXXXX AT SAMP'
C      CHARACTER*72 M3
C      M3 =
C     + '         CENTER OF TRANSFORMATION XCEN=XXXXX.XXX, YCEN=XXXXX.'
      TPI=6.2831852 

      IF(IND.EQ.0) THEN
C
C---- WRITE LABEL (FORWARD TRANSFORM)
C
      CALL XLADD(WUNIT,'HISTORY','PHIMIN',PHIMIN,STATUS,'FORMAT',
     *       'REAL',' ')
      CALL XLADD(WUNIT,'HISTORY','PHIMAX',PHIMAX,STATUS,'FORMAT',
     *       'REAL',' ')
      CALL XLADD(WUNIT,'HISTORY','RMIN',RMIN,STATUS,'FORMAT','REAL',' ')
      CALL XLADD(WUNIT,'HISTORY','RMAX',RMAX,STATUS,'FORMAT','REAL',' ')
      CALL XLADD(WUNIT,'HISTORY','XCEN',XCEN,STATUS,'FORMAT','REAL',' ')
      CALL XLADD(WUNIT,'HISTORY','YCEN',YCEN,STATUS,'FORMAT','REAL',' ')
      CALL XLADD(WUNIT,'HISTORY','RESO',RESO,STATUS,'FORMAT','REAL',' ')
      CALL XLADD(WUNIT,'HISTORY','RSCALE',SCALE,STATUS,'FORMAT',
     *       'REAL',' ')
      CALL XVMESSAGE('VICAR HISTORY LABEL WRITTEN:',' ')
      WRITE (MG1(17:26),'(F10.5)') PHIMIN*360./TPI
      WRITE (MG1(46:55),'(F10.5)') PHIMAX*360./TPI
      WRITE (MG1(64:67),'(I4)') NINT((PHIMAX-PHIMIN)/RESO+1.)
C 9910  FORMAT ('                ',F10.5,'                   ',F10.5,
C     +'        ',I4,'     ')
      CALL XVMESSAGE(MG1,' ')
C      WRITE (MG2,9920) RMIN,RMAX,NINT((RMAX-RMIN)/SCALE+1.)
      WRITE (MG2(15:24),'(F10.5)') RMIN
      WRITE (MG2(42:51),'(F10.5)') RMAX
      WRITE (MG2(60:63),'(I4)') NINT((RMAX-RMIN)/SCALE+1.)
C 99920  FORMAT ('              ',F10.5,'                 ',F10.5,
C     +'        ',I4,'         ')
      CALL XVMESSAGE(MG2,' ')
      WRITE (MG3(40:48),'(F9.3)') XCEN
      WRITE (MG3(56:64),'(F9.3)') YCEN
C 9930  FORMAT ('                                       ',F9.3,'       ',
C     +F9.3,'        ')
      CALL XVMESSAGE(MG3,' ')
      ELSE
C
C---- READ LABEL (INVERSE TRANSFORM)
C
        CALL XVMESSAGE(' VICAR HISTORY LABEL READ:',' ')
      IF(RANGDF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','PHIMIN',PHIMIN,STATUS,
     *    'FORMAT','REAL',' ')
      MG1= ' PHIMIN = '
      WRITE(MG1(11:20),'(F10.5)') PHIMIN
      CALL XVMESSAGE(MG1,' ')
      ENDIF
      IF(RANGDF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','PHIMAX',PHIMAX,STATUS,
     *          'FORMAT','REAL','HIST','POLARECT',' ')
      MG2= ' PHIMAX = '
      WRITE(MG2(11:20),'(F10.5)') PHIMAX
      CALL XVMESSAGE(MG2,' ')
      ENDIF
      IF(RMINDF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','RMIN',RMIN,STATUS,
     *          'FORMAT','REAL','HIST','POLARECT',' ')
      MG3= ' RMIN = '
      WRITE(MG3(9:18),'(F10.5)') RMIN
      CALL XVMESSAGE(MG3,' ')
      ENDIF
      IF(RMAXDF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','RMAX',RMAX,STATUS,
     *          'FORMAT','REAL','HIST','POLARECT',' ')
      MG1= ' RMAX = '
      WRITE(MG1(9:18),'(F10.5)') RMAX
      CALL XVMESSAGE(MG1,' ')
      ENDIF
      IF(XCENDF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','XCEN',XCEN,STATUS,
     *          'FORMAT','REAL','HIST','POLARECT',' ')
      MG2= ' XCEN = '
      WRITE(MG2(9:18),'(F10.5)') XCEN
      CALL XVMESSAGE(MG2,' ')
      ENDIF
      IF(YCENDF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','YCEN',YCEN,STATUS,
     *          'FORMAT','REAL','HIST','POLARECT',' ')
      MG3= ' YCEN = '
      WRITE(MG3(9:18),'(F10.5)') YCEN
      CALL XVMESSAGE(MG3,' ')
      ENDIF
      IF(RESODF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','RESO',RESO,STATUS,
     *          'FORMAT','REAL','HIST','POLARECT',' ')
      MG1= ' RESO = '
      WRITE(MG1(9:18),'(F10.5)') RESO
      CALL XVMESSAGE(MG1,' ')
      ENDIF
      IF(RSCALEDF.EQ.1) THEN
        CALL XLGET(RUNIT,'HISTORY','RSCALE',SCALE,STATUS,
     *          'FORMAT','REAL','HIST','POLARECT',' ')
      MG2= ' SCALE = '
      WRITE(MG2(10:19),'(F10.5)') SCALE
      CALL XVMESSAGE(MG2,' ')
      ENDIF
      ENDIF
      RETURN
      END
c*******************************************************
	SUBROUTINE POLA(NLN,IN,OUT,LN,COSPHI,SINPHI)
      
	INTEGER*4 BACK
	INTEGER SL,SS,HALF
        INTEGER*2 OUT(1),IOUT
	BYTE IN(1)
	REAL RNS,RNLN,RLN

      COMMON /C1/ RUNIT,WUNIT,SL,SS,NL,NS,NLO,NSO,HALF,BACK
      COMMON /C2/ RESO,PHIMIN,PHIMAX,XCEN,YCEN,IFLAG,RMIN,RMAX,SCALE

        RNS=NS
        RNLN=NLN
 	RLN=LN
	ISTOP=0
	R=RMIN
	I=1

	DO 100 J=1,NSO
C
C   GET NEXT VALUE FROM OUTPUT AREA AND CHECK BACKGROUND
C        I.E. IS THIS IN THE AREA OF INTEREST
C
	IOUT=OUT(I)
	IF (IOUT.NE.BACK) GO TO 400
	IF (R.GT.RMAX) RETURN
	X=R*COSPHI+XCEN
	IF (X.LT.1..OR. X.GT.RNS) GO TO 300
	Y=R*SINPHI+YCEN+1.-RLN
	IF (Y.LT.1..OR.Y.GT.RNLN) GO TO 300
	RAD=R
	OUT(I)=IFP(X,Y,NS,NLN,IN,IFLAG,HALF)

	ISTOP=1
	R=RAD
	GO TO 400
300	CONTINUE
	IF (ISTOP.NE.0) RETURN
400	CONTINUE
	I=I+1
	R=R+SCALE
100	CONTINUE

	RETURN
	END
C********************************************************
	SUBROUTINE RECTA(NLN,IN,OUT,LN,LINE)

	INTEGER*4 BACK
	INTEGER SL,SS,HALF
        INTEGER*2 OUT(1),IOUT
	BYTE IN(1)
	REAL RLINE,RNS,RNLN,RLN

      COMMON /C1/ RUNIT,WUNIT,SL,SS,NL,NS,NLO,NSO,HALF,BACK
      COMMON /C2/ RESO,PHIMIN,PHIMAX,XCEN,YCEN,IFLAG,RMIN,RMAX,SCALE

	RLINE=LINE
 	Y=RLINE-YCEN
	Y2=Y*Y
	X=1.-XCEN

	TWOPI=2.*4.*ATAN(1.)
	RNS=NS
	RNLN=NLN
	RLN=LN
	I=1
	DO 100 J=1,NSO
C
C   GET NEXT VALUE FROM OUTPUT AREA AND CHECK BACKGROUND
C        I.E. IS THIS IN THE AREA OF INTEREST
C
	IOUT=OUT(I)
	IF (IOUT.NE.BACK) GO TO 400
	R=X*X+Y2
	E0=SQRT(R)-RMIN
	IF(E0.LT.0.) GO TO 400
	R=E0/SCALE+1.
	IF(R.GT.RNS) GO TO 400
	IF (X.NE.0.) THEN
            PHI=ATAN2(Y,X)
          ELSEIF (Y.LT.0.) THEN
            PHI=TWOPI*.75
          ELSEIF (Y.EQ.0.) THEN
            PHI=PHIMIN
          ELSEIF (Y.GT.0.) THEN
            PHI=TWOPI*.25
        ENDIF
	IF (PHI.LT.PHIMIN) PHI=PHI+TWOPI
        IF (PHI.GT.PHIMAX) PHI=PHI-TWOPI
        IF (PHI-PHIMIN.LT.0.) GO TO 400
	PHI=(PHI-PHIMIN)/RESO-RLN+2.
	IF (PHI.LT.1. .OR. PHI.GT.RNLN) GO TO 400
	OUT(I)=IFP(R,PHI,NS,NLN,IN,IFLAG,HALF)

400	CONTINUE
	I=I+1
	X=X+1.
100	CONTINUE

	RETURN
	END
