      INCLUDE 'VICMAIN_FOR'
      SUBROUTINE MAIN44
C---- VICAR PROGRAM "RAPIDMOS.
C     PURPOSE: TAKES MULTIPLE IMAGES AND MOSAICS THEM
C              INTO ONE OUTPUT DATA SET.THE OPERATION IS
C              SIMILAR TO THAT OF "FASTMOS", BUT WITH
C              REDUCED EXECUTION TIME AND MANY NOT WIDELY
C              USED FUNCTIONS REMOVED.
C
C     PROGRAMMER: BORIS GOKHMAN, APRIL 1981.
C
C	EXTENSIVELY MODIFIED BY  K.F. EVANS  APRIL 1986
C
C       PORTED TO UNIX BY C.R SCHENK (CRI) MAY 1995
C       MSTP S/W CONVERSION (VICAR PORTING)

	IMPLICIT NONE
	BYTE	OUTBUFFER(50000), BUFFER(50000)
	INTEGER MAXINP
	PARAMETER (MAXINP=40)
	INTEGER RUNIT(MAXINP), OFFL(MAXINP), OFFS(MAXINP), NS(MAXINP)
	LOGICAL LFLAG(MAXINP), RFLAG(MAXINP)

	INTEGER	OFFSETS(2*MAXINP)
	INTEGER	FIRSTPIX(MAXINP), LASTPIX(MAXINP)
	INTEGER	NL(MAXINP)

	INTEGER	I, IX, IX1, IX2, INP
	INTEGER	WUNIT, STATUS, NINP
	INTEGER NOFF, OFFDEF, NPIX
	INTEGER	SLOUT, SSOUT, NLOUT, NSOUT
	INTEGER	NLMIN, NLMAX, LINE, NLI, NSI
	CHARACTER*72 INPFILES(MAXINP)

	COMMON /RAPIDCOM/ RUNIT, OFFL, OFFS, NS, LFLAG, RFLAG

C
C---- READ PARAMETERS, OPEN FILES, PROCESS LABELS.
C
C
        CALL IFMESSAGE('RAPIDMOS verion 08-May-1995')
	CALL XVP ('INP', INPFILES, NINP)
	DO I = 1,NINP
	    CALL XVUNIT (RUNIT(I), 'INP', I, STATUS,' ')
	    CALL XVOPEN (RUNIT(I), STATUS,  
     *			'OPEN_ACT','SA', 'IO_ACT','SA',' ')
	    CALL XVGET (RUNIT(I), STATUS, 'NL',NL(I), 'NS',NS(I),' ')
	ENDDO
	CALL XVPARM ('OFFSETS', OFFSETS, NOFF, OFFDEF,80)
	CALL XVSIZE (SLOUT,SSOUT, NLOUT,NSOUT,NLI,NSI)

	CALL XVUNIT (WUNIT,'OUT',1,STATUS,' ')
	CALL XVOPEN (WUNIT, STATUS, 'OP','WRITE',
     *            'U_NL',NLOUT, 'U_NS',NSOUT,
     *            'OPEN_ACT','SA', 'IO_ACT','SA',' ')

	DO I = 1, NINP
	    OFFL(I) = 1
	    OFFS(I) = 1
	    LFLAG(I) = .FALSE.
	    RFLAG(I) = .FALSE.
	ENDDO
	IF (OFFDEF.EQ.0) THEN
	    DO I=1,NOFF/2
		OFFL(I) = OFFSETS(2*I-1)
		OFFS(I) = OFFSETS(2*I)
	    ENDDO
	ENDIF

	NLMIN = 1000000
	NLMAX = 0
	DO I = 1,NINP
	    NLMIN = MIN0(NLMIN,OFFL(I))
	    NLMAX = MAX0(NLMAX,OFFL(I)+NL(I)-1)
	ENDDO



C---- BEGIN LINE BY LINE PROCESSING.


	DO LINE = 1, NLOUT
	    DO I = 1, NSOUT
		OUTBUFFER(I) = 0
	    ENDDO

C		FILL TOP AND BOTTOM WITH ZEROES.
         IF (LINE.LT.NLMIN .OR. LINE.GT.NLMAX) GO TO 2300

C		DO MOSAIC
	    DO INP = NINP, 1, -1
		IF (LINE .LT. OFFL(INP) .OR.
     *			 LINE .GT. OFFL(INP)+NL(INP)-1) GO TO 2200
		CALL FINDEDGES (INP, LINE, FIRSTPIX,LASTPIX, NPIX, BUFFER)
		IF (NPIX .EQ. 0) GO TO 2200
		IX1 = FIRSTPIX(INP) + OFFS(INP) - 1
		IX2 = LASTPIX(INP) + OFFS(INP) - 1
		IF (IX2 .GE. 1 .AND. IX1 .LE. NSOUT) THEN
		    IX1 = MAX (IX1,1)
		    IX2 = MIN (IX2,NSOUT)
		    I = IX1 - (OFFS(INP) - 1)
		    DO IX = IX1, IX2
			OUTBUFFER(IX) = BUFFER(I)
			I = I + 1
		    ENDDO
		ENDIF
 2200		CONTINUE
	    ENDDO
 2300       CONTINUE
	    CALL XVWRIT (WUNIT,OUTBUFFER, STATUS, 'LINE',LINE,' ')
	ENDDO

	CALL XVCLOSE (WUNIT, STATUS,' ')

	RETURN
	END




	SUBROUTINE FINDEDGES (INP, LINE, FIRSTPIX,LASTPIX, NPIX, BUFFER)
C		FINDEDGES reads in a line of pixels from the INP'th 
C		image into BUFFER  and using the old FIRSTPIX and LASTPIX 
C		values finds the new first and last non-zero pixel in 
C		the line.  NPIX is set to zero if the whole line is blank.
	IMPLICIT NONE
	INTEGER	INP, LINE, NPIX
	INTEGER	FIRSTPIX(1),LASTPIX(1)
	BYTE	BUFFER(1)
	INTEGER	I, J, STATUS, NSAMP

	INTEGER MAXINP
	PARAMETER (MAXINP=40)
	INTEGER RUNIT(MAXINP), OFFL(MAXINP), OFFS(MAXINP), NS(MAXINP)
	LOGICAL LFLAG(MAXINP), RFLAG(MAXINP)
	COMMON /RAPIDCOM/ RUNIT, OFFL, OFFS, NS, LFLAG, RFLAG


	NSAMP = NS(INP)
	CALL XVREAD (RUNIT(INP), BUFFER,STATUS, 'LINE',
     +               LINE-OFFL(INP)+1,' ')

	IF (LFLAG(INP) .AND. RFLAG(INP)) GO TO 20

C		SET INITIAL LEFT AND RIGHT EDGES.
5	CONTINUE
	LFLAG(INP) = .FALSE.
	DO I = 1, NSAMP
	    IF (BUFFER(I) .NE. 0) THEN
		LFLAG(INP) = .TRUE.
		FIRSTPIX(INP) = I
		GOTO 10
	    ENDIF
	ENDDO
10	CONTINUE

	RFLAG(INP) = .FALSE.
	DO I = NSAMP, 1, -1
	    IF (BUFFER(I) .NE. 0) THEN
		RFLAG(INP) = .TRUE.
		LASTPIX(INP) = I
		GOTO 15
	    ENDIF
	ENDDO
15	CONTINUE
	GO TO 100



C		FIND LEFT EDGE

20	CONTINUE
	J = FIRSTPIX(INP)
	IF (BUFFER(J) .NE. 0) THEN
C			GO TO THE LEFT
	    DO I = J, 1, -1
		IF (BUFFER(I) .EQ. 0) THEN
		    FIRSTPIX(INP) = I+1
		    GO TO 60
		ENDIF
	    ENDDO
	    FIRSTPIX(INP) = 1
	    GO TO 60
	ELSE
C			GO TO THE RIGHT
	    DO I = J, NSAMP
		IF (BUFFER(I) .NE. 0) THEN
		    FIRSTPIX(INP) = I
		    GO TO 60
		ENDIF
	    ENDDO
	    LFLAG(INP) = .FALSE.
	    RFLAG(INP) = .FALSE.
	    GO TO 100
	ENDIF




C		FIND RIGHT EDGE

60	CONTINUE

	J = LASTPIX(INP)
	IF (BUFFER(J) .EQ. 0) THEN
C			GO TO THE LEFT
	    DO I = J, 1, -1
		IF (BUFFER(I) .NE. 0) THEN
		    LASTPIX(INP) = I
		    GO TO 100
		ENDIF
	    ENDDO
	    LFLAG(INP) = .FALSE.
	    RFLAG(INP) = .FALSE.
	    GO TO 100
	ELSE
C			GO TO THE RIGHT
	    DO I = J, NSAMP
		IF (BUFFER(I) .EQ. 0) THEN
		    LASTPIX(INP) = I-1
		    GO TO 100
		ENDIF
	    ENDDO
	    LASTPIX(INP) = NSAMP
	ENDIF


  100 CONTINUE
	NPIX = LASTPIX(INP) - FIRSTPIX(INP) + 1
	IF (.NOT. LFLAG(INP)) THEN
	    NPIX=0
	ELSE   ! If first and last got screwed up then scan the whole line
	    IF (NPIX .LE. 0) GO TO 5  
	ENDIF

	RETURN
	END
