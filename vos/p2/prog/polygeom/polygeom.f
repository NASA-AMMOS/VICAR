      INCLUDE 'VICMAIN_FOR'
      SUBROUTINE MAIN44

C  IBIS ROUTINE POLYGEOM
C
C  POLYGEOM PERFORMS GEOMETRIC TRANSFORMATIONS TO CORRECT FOR DISTORTION
C  INCREASE OR DECREASE THE SIZE OF A POINT POLYGON DATA SET.  THE
C  TRANSFORMATION IS SPECIFIED BY CONTROL POINTS WHICH ARE GIVEN IN LINE
C  SAMPLE COORDINATES IN THE INPUT AND OUTPUT PICTURE.   THE OPERATION A
C  COMPUTATIONS OF POLYGEOM ARE SIMILAR TO GEOMA EXCEPT THAT POLYGON DAT
C  CAN BE TRANSFORMED MUCH MORE RAPIDLY THAN IMAGES.
C
C  USER PARAMETERS:
C
C  NAH,NH -  NUMBER OF AREAS HORIZONTALLY.
C  NAV,NV -  NUMBER OF AREAS VERTICALLY.
C  TIEPOINTS,NL1,NS1,OL1,OS1,... - THIS KEYWORD AND ASSOCIATED NUMBERS S
C            THE MAPPING OF CONTROL POINTS BETWEEN OUTPUT AND INPUT PICT
C            ONE MULTIPLE OF FOUR INTEGERS IS GIVEN FOR EACH TIEPOINT.
C            THE ORDERING OF TIEPOINTS IS TOP ROW FIRST, AND LEFT TO RIG
C            WITHIN EACH ROW.
C  INVERSE - THIS KEYWORD CALLS A REVERSE TRANSFORMATION PROCEDURE TO
C            CALCULATE POINTS IN THE ORIGINAL IMAGE BASED ON THE OUTPUT
C  IGNORE,X,Y - THIS CAUSES ALL OCCURRENCES OF THE POINT (X,Y) TO BE LEF
C            AS IS.  THE DEFAULT IS TO IGNORE THE POINT (0.,0.).
C
	IMPLICIT INTEGER(A-Z)
	REAL*8	TAB(8), WORK(64), XX,YY, FX,FY
	REAL	X,Y, MDIST,DIST, MAG
	REAL	XL,XU,YL,YU
        REAL	TIEPOINT(8400)
	REAL	QX(4,2100), QY(4,2100), COEFF(9,2100)
        COMMON	/COM2/ NAH,NAV, QX,QY, COEFF
        INTEGER	PPTR(4)
        integer status,rdgr,wrgr,getgr,putgr,clgr
	REAL	IGNORE(2), XIGNOR,YIGNOR
	REAL	EXTRA(40), COORD1, COORD2
	LOGICAL INVERS,INSECT, NOPRINT, EOF, ZERO, XVPTST
	CHARACTER*60 STRING

      call ifmessage('POLYGEOM version 06-MAR-95')

C---- GET PARAMETERS

        CALL XVP ('TIEPOINT', TIEPOINT, NTIEPP)
        CALL XVP ('NAH', NAH, DUMMY)
        CALL XVP ('NAV', NAV, DUMMY)
	IF (NTIEPP .NE. 4*(NAH+1)*(NAV+1) ) THEN
	    CALL XVMESSAGE ('NUMBER OF TIEPOINTS DOES NOT ' //
     + 'MATCH NAH AND NAV',' ')
	    CALL ABEND
	ENDIF
        CALL XVP ('IGNORE', IGNORE, DUMMY)
        XIGNOR = IGNORE(1)
        YIGNOR = IGNORE(2)
        CALL XVP ('SKIP', SKIP, DUMMY)
        INSECT = XVPTST ('INSECT')
        INVERS = XVPTST ('INVERSE')
        NOPRINT = XVPTST ('NOPRINT')

C---- OPEN INPUT AND OUTPUT FILES.

	STATUS = RDGR (1, 1, 2+SKIP)
        IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)

	STATUS = WRGR (1, 2, 2+SKIP)
        IF (STATUS.NE.1) CALL SIGNALGR(2,STATUS,1)



        PPM = 0
        REC1 = 0
        REC2 = 0
C
C  SET UP GRID AREAS FOR SOLUTION BY SOLVE ROUTINE.  SOLUTIONS ARE
C  SAVED IN COEFF.
      XL = 1.E35
      YL = 1.E35
      XU = -1.E35
      YU = -1.E35
      DO 20 IX=1,NAH
      DO 20 JX=1,NAV
      NSEQ = IX+(JX-1)*NAH
      PPTR(1) = ((IX-1)+(JX-1)*(NAH+1))*4+PPM+1
      PPTR(4) = PPTR(1)+(NAH+1)*4
      PPTR(2) = PPTR(1)+4
      PPTR(3) = PPTR(4)+4
      DO 12 I=1,4
      P = PPTR(I)
      IF (.NOT.INVERS) P = P+2
      IF (IX.EQ.1) XL = AMIN1(XL,TIEPOINT(P))
      IF (JX.EQ.1) YL = AMIN1(YL,TIEPOINT(P+1))
      IF (IX.EQ.NAH) XU = AMAX1(XU,TIEPOINT(P))
      IF (JX.EQ.NAV) YU = AMAX1(YU,TIEPOINT(P+1))
      QX(I,NSEQ) = TIEPOINT(P)
 12   QY(I,NSEQ) = TIEPOINT(P+1)
      NRANK = 8
      DELPT = 0
      DO 15 I=1,64
 15   WORK(I) = 0.D+0
      IF (QX(1,NSEQ).EQ.QX(2,NSEQ).AND.QY(1,NSEQ).EQ.QY(2,NSEQ)) DELPT=1
      IF (QX(3,NSEQ).EQ.QX(4,NSEQ).AND.QY(3,NSEQ).EQ.QY(4,NSEQ)) DELPT=3
      IF (DELPT.NE.0) NRANK = 6
      NHALF = NRANK/2
      NONES = NRANK*6-24
      BLOCK = NRANK*NHALF+NHALF
      PTR = 1
      DO 16 I=1,4
      P = PPTR(I)
      TAB(PTR) = TIEPOINT(P)
      TAB(PTR+NHALF) = TIEPOINT(P+1)
      WORK(PTR) = TIEPOINT(P+2)
      WORK(PTR+NRANK) = TIEPOINT(P+3)
      IF (NRANK.EQ.8) WORK(PTR+16) = TIEPOINT(P+2)*TIEPOINT(P+3)
      WORK(PTR+NONES) = 1.D+0
      IF (DELPT.NE.I) PTR = PTR+1
 16   CONTINUE
      DO 17 I=1,NHALF
      DO 17 J=1,NHALF
      I1 = I+(J-1)*NRANK
 17   WORK(I1+BLOCK) = WORK(I1)
      CALL SOLVE(TAB,WORK,NRANK,1,1.E-14,IER)
      IF (IER.NE.0) CALL MABEND(2)
      PTR = 1
      DO 18 I=1,4
      COEFF(I,NSEQ) = TAB(PTR)
      COEFF(I+4,NSEQ) = TAB(PTR+NHALF)
      IF (I.NE.NHALF) PTR = PTR+1
 18   CONTINUE
      COEFF(9,NSEQ) = 1./(COEFF(1,NSEQ)*COEFF(6,NSEQ)-COEFF(2,NSEQ)*
     .COEFF(5,NSEQ))
      IF (NRANK.EQ.8) GO TO 20
      COEFF(3,NSEQ) = 0.
      COEFF(7,NSEQ) = 0.
 20   CONTINUE




C  TRANSLATE THE POINTS BY THE CORRESPONDING SOLVE SOLUTION.

	PRINTCOUNT = 0
	IF (.NOT. NOPRINT) THEN
	    WRITE (STRING, '(A)' ) 
     *	'        INPUT COORDINATES           OUTPUT COORDINATES'
	    CALL XVMESSAGE (STRING,' ')
	ENDIF

	IQ = 1
	JQ = 1
	QQ = 1

	DO WHILE (.TRUE.)
	    STATUS = GETGR (1, ZERO, EOF, COORD1, COORD2, EXTRA)
            IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	    IF (EOF) GOTO 890
	    X = COORD1
	    Y = COORD2
	    IF (ABS(X-XIGNOR)+ABS(Y-YIGNOR) .GT. 1.0E-6) THEN
		IF (INSECT) THEN
		    IF (X.LT.XL.OR.X.GT.XU) GO TO 100
		    IF (Y.LT.YL.OR.Y.GT.YU) GO TO 100
		ENDIF
		MDIST = 2.E20
		IQNAH = IQ+NAH-1
		JQNAV = JQ+NAV-1
C		  FIND GRID AREA CONTAINING POINT.  SEARCH IN 'NEAREST' ORDER.
		DO I = 1, NAH
		    IS = (2*MOD(I,2)-1)*(I/2)
		    IT = MOD(IQNAH+IS,NAH)+1
		    DO J = 1, NAV
			JS = (2*MOD(J,2)-1)*(J/2)
			JT = MOD(JQNAV+JS,NAV)+1
			QT = IT+(JT-1)*NAH
			CALL INSIDE(X,Y,IT,JT,QT,DIST)
			IF (DIST.LE.0.) GO TO 150
			IF (DIST-MDIST) 139,138,140
 138			IF (QT.GE.MQT) GO TO 140
 139			MDIST = DIST
			MIT = IT
			MJT = JT
			MQT = QT
 140			CONTINUE
		    ENDDO
		ENDDO
		IT = MIT
		JT = MJT
		QT = MQT
 150		IQ = IT
		JQ = JT
		QQ = QT
		IF (.NOT. INVERS) THEN
		    XX = COEFF(1,QQ)*X+COEFF(2,QQ)*Y+
     *				COEFF(3,QQ)*X*Y+COEFF(4,QQ)
		    YY = COEFF(5,QQ)*X+COEFF(6,QQ)*Y+
     *				COEFF(7,QQ)*X*Y+COEFF(8,QQ)
		ELSE
 		    MAG = X*X+Y*Y+1.E-5
		    XX = X-COEFF(4,QQ)
		    YY = Y-COEFF(8,QQ)
		    DO I = 1, 10
			FX = COEFF(1,QQ)*XX+COEFF(2,QQ)*YY+
     *				COEFF(3,QQ)*XX*YY+COEFF(4,QQ)-X
			FY = COEFF(5,QQ)*XX+COEFF(6,QQ)*YY+
     *				COEFF(7,QQ)*XX*YY+COEFF(8,QQ)-Y
			XX = XX-(COEFF(6,QQ)*FX-COEFF(2,QQ)*FY)*COEFF(9,QQ)
			YY = YY-(COEFF(1,QQ)*FY-COEFF(5,QQ)*FX)*COEFF(9,QQ)
			IF ((FX*FX+FY*FY)/MAG .LT. 1.0D-10) GO TO 160
		    ENDDO
		    CALL XVMESSAGE ('INVERSE DID NOT CONVERGE',' ')
		    CALL ABEND
		ENDIF

 160		CONTINUE
		COORD1 = SNGL(XX)
		COORD2 = SNGL(YY)
 100		CONTINUE

	    ENDIF
	    STATUS = PUTGR (2, COORD1, COORD2, EXTRA)
            IF (STATUS.NE.1) CALL SIGNALGR(2,STATUS,1)

	    IF (.NOT. NOPRINT .AND. PRINTCOUNT .LT. 5) THEN
		WRITE (STRING, '(F12.3,1X,F12.3,4X,F12.3,1X,F12.3)' )
     *				 X,Y, COORD1, COORD2
		CALL XVMESSAGE (STRING,' ')
		PRINTCOUNT = PRINTCOUNT + 1
	    ENDIF
	ENDDO

890	CONTINUE
	STATUS = CLGR (1)
        IF (STATUS.NE.1) CALL SIGNALGR(1,STATUS,1)
	STATUS = CLGR (2)
        IF (STATUS.NE.1) CALL SIGNALGR(2,STATUS,1)

	RETURN
	END



C*****************************************************************
      SUBROUTINE INSIDE(X,Y,IQ,JQ,QQ,DIST)
C
C  USES DOT PRODUCTS FOR POINT IN POLYGON SOLUTION.  BEST METHOD FOR CON
C  POLYGONS.
C
      IMPLICIT INTEGER(A-Z)
      REAL X,Y,DOT,QX,QY,COEFF,DIST,DX,DY
      COMMON /COM2/NAH,NAV,QX(4,2100),QY(4,2100),COEFF(9,2100)
C
      DIST = -1.
      DO 10 I=1,4
      IU = MOD(I,4)+1
      GO TO (1,2,3,4),I
 1    IF (JQ.EQ.1) GO TO 7
      GO TO 5
 2    IF (IQ.EQ.NAH) GO TO 7
      GO TO 5
 3    IF (JQ.EQ.NAV) GO TO 7
      GO TO 5
 4    IF (IQ.EQ.1) GO TO 7
 5    DOT = (X-QX(I,QQ))*(QY(IU,QQ)-QY(I,QQ))
     .     -(Y-QY(I,QQ))*(QX(IU,QQ)-QX(I,QQ))
      IF (DOT+.01) 99,99,10
 7    DX = X-(QX(I,QQ)+QX(IU,QQ))/2.
      DY = Y-(QY(I,QQ)+QY(IU,QQ))/2.
      DIST = DX*DX+DY*DY
 10   CONTINUE
      RETURN
 99   DIST = 1.E20
      RETURN
      END



      SUBROUTINE SOLVE(R,A,M,N,EPS,IER)
C
      DIMENSION A(1),R(1)
      DOUBLE PRECISION R,A,PIV,TB,TOL,PIVI
      IF(M)23,23,1
C
C     SEARCH FOR GREATEST ELEMENT IN MATRIX A
    1 IER=0
      PIV=0.D0
      MM=M*M
      NM=N*M
      DO 3 L=1,MM
      TB=DABS(A(L))
      IF(TB-PIV)3,3,2
    2 PIV=TB
      I=L
    3 CONTINUE
      TOL=EPS*PIV
C     A(I) IS PIVOT ELEMENT. PIV CONTAINS THE ABSOLUTE VALUE OF A(I).
C
C
C     START ELIMINATION LOOP
      LST=1
      DO 17 K=1,M
C
C     TEST ON SINGULARITY
      IF(PIV)23,23,4
    4 IF(IER)7,5,7
    5 IF(PIV-TOL)6,6,7
    6 IER=K-1
    7 PIVI=1.D0/A(I)
      J=(I-1)/M
      I=I-J*M-K
      J=J+1-K
C     I+K IS ROW-INDEX, J+K COLUMN-INDEX OF PIVOT ELEMENT
C
C     PIVOT ROW REDUCTION AND ROW INTERCHANGE IN RIGHT HAND SIDE R
      DO 8 L=K,NM,M
      LL=L+I
      TB=PIVI*R(LL)
      R(LL)=R(L)
    8 R(L)=TB
C
C     IS ELIMINATION TERMINATED
      IF(K-M)9,18,18
C
C     COLUMN INTERCHANGE IN MATRIX A
    9 LEND=LST+M-K
      IF(J)12,12,10
   10 II=J*M
      DO 11 L=LST,LEND
      TB=A(L)
      LL=L+II
      A(L)=A(LL)
   11 A(LL)=TB
C
C     ROW INTERCHANGE AND PIVOT ROW REDUCTION IN MATRIX A
   12 DO 13 L=LST,MM,M
      LL=L+I
      TB=PIVI*A(LL)
      A(LL)=A(L)
   13 A(L)=TB
C
C     SAVE COLUMN INTERCHANGE INFORMATION
      A(LST)=J
C
C     ELEMENT REDUCTION AND NEXT PIVOT SEARCH
      PIV=0.D0
      LST=LST+1
      J=0
      DO 16 II=LST,LEND
      PIVI=-A(II)
      IST=II+M
      J=J+1
      DO 15 L=IST,MM,M
      LL=L-J
      A(L)=A(L)+PIVI*A(LL)
      TB=DABS(A(L))
      IF(TB-PIV)15,15,14
   14 PIV=TB
      I=L
   15 CONTINUE
      DO 16 L=K,NM,M
      LL=L+J
   16 R(LL)=R(LL)+PIVI*R(L)
   17 LST=LST+M
C     END OF ELIMINATION LOOP
C
C
C     BACK SUBSTITUTION AND BACK INTERCHANGE
   18 IF(M-1)23,22,19
   19 IST=MM+M
      LST=M+1
      DO 21 I=2,M
      II=LST-I
      IST=IST-LST
      L=IST-M
      L=A(L)+.5D0
      DO 21 J=II,NM,M
      TB=R(J)
      LL=J
      DO 20 K=IST,MM,M
      LL=LL+1
   20 TB=TB-A(K)*R(LL)
      K=J+L
      R(J)=R(K)
   21 R(K)=TB
   22 RETURN
C
C
C     ERROR RETURN
   23 IER=-1
      RETURN
      END
