      INCLUDE 'VICMAIN_FOR'
C     VICAR PROGRAM ZFILL      S.Z. FRIEDMAN    MARCH 1983
C     MODIFIED FOR VAX CONVERSION BY ASM, 6 SEPT 1983
C     MODIFIED TO VICAR2 AND SPARSE/DENSE ALGORITHMS ADDED BY REA, 20 MAY 1986
C     MODIFIED to UNIX/VICAR BY REA, 3 SEPTEMBER 1991
C     CHANGE 'MAIN' SUBROUTINE NAME TO 'WORK' - REA, 6 APR 2001
C**********************************************************************
      SUBROUTINE MAIN44
C
C  PROGRAM ZFILL USES A WINDOW OF NLW LINES BY NSW SAMPLES TO
C  FILL IN VOID AREAS OF AN IMAGE.  VOID AREAS ARE ASSUMED
C  TO BE ZERO DN, BUT CAN BE RESPECIFIED BY PARAMETER.  VOIDS ARE
C  FILLED WITH THE MEAN VALUE OF ALL 'NON-VOID DN' PIXELS IN
C  THE WINDOW.  A MASK SHOWING FILLED PIXELS CAN BE
C  GENERATED UPON REQUEST
C
C
C  TAE STATEMENT FORM:
C     ZFILL IN OUT SIZE=(SL,SS,NL,NS) PARAMETERS       OR
C     ZFILL IN (OUT,MASK) SIZE=(SL,SS,NL,NS) PARAMETERS
C
C  PARAMETERS:
C
C     NLW=n            NUMBER OF LINES IN WINDOW (DEFAULT=3)
C
C     NSW=m            NUMBER OF SAMPLES IN WINDOW (DEFAULT=3)
C
C     REPLACE=n        DEFINES DN(N) TO BE THE 'VOID' DN.  ALL PIXELS
C                      OF VALUE N WILL BE REPLACED BY THE MEAN OF ALL
C                      'NON-N' VALUES IN THE WINDOW.  (DEFAULT=0)
C
C     EXCLUDE=n        DN N WILL NOT BE USED IN THE INTERPOLATION
C                      OF VALUE FOR REPLACEMENT DN.  ITS FUNCTION
C                      IS SIMILAR TO AN AREA MASK OR BARRIER.
C                      (NO DEFAULT)
C
C     DENSE	       INVOKES THE ALGORITHM FOR USE WHEN THE INPUT
C		       IS MOSTLY FULL.
C
	EXTERNAL WORK
	LOGICAL XVPTST,QDENSE/.FALSE./,QMASK/.FALSE./
	COMMON /QQ/ ISL,ISS,NL,NS,NLIN,NSIN,NLW,NSW,IREPLACE,IEXCLUDE,
     +		    INUNIT,IOUTUNIT,MASKUNIT,QDENSE,QMASK 
C
	CALL XVMESSAGE('ZFILL Version 6-April-2001',' ')
C							 call for parameters
	CALL XVPARM('NLW',NLW,ICNT,IDEF,0)
	CALL XVPARM('NSW',NSW,ICNT,IDEF,0)
	CALL XVPARM('REPLACE',IREPLACE,ICNT,IDEF,0)
	CALL XVPARM('EXCLUDE',IEXCLUDE,ICNT,IDEF,0)
	QDENSE = XVPTST('DENSE')
C								open datasets
	CALL XVUNIT(INUNIT,'INP',1,ISTAT,' ')
	CALL XVOPEN(INUNIT,ISTAT,'OPEN_ACT','SA','IO_ACT','SA',
     +		    'U_FORMAT','HALF',' ')
	CALL XVUNIT(IOUTUNIT,'OUT',1,ISTAT,' ')
	CALL XVOPEN(IOUTUNIT,ISTAT,'OPEN_ACT','SA','IO_ACT','SA',
     +		    'U_FORMAT','HALF','OP','WRITE',' ')
	CALL XVPCNT('OUT',NOUT)
	IF (NOUT.EQ.2) THEN
	    QMASK = .TRUE.
	    CALL XVUNIT(MASKUNIT,'OUT',2,ISTAT,' ')
	    CALL XVOPEN(MASKUNIT,ISTAT,'OPEN_ACT','SA','IO_ACT','SA',
     +		  'U_FORMAT','BYTE','O_FORMAT','BYTE','OP','WRITE',' ')
	END IF
C					     check parameters, adjust if needed
	CALL XVSIZE(ISL,ISS,NL,NS,NLIN,NSIN)
	IF (ISL+NL-1 .GT. NLIN) NL=NLIN-ISL+1
	IF (ISS+NS-1 .GT. NSIN) NS=NSIN-ISS+1
	IF (NL.LE.0 .OR. NS.LE.0) THEN
	    CALL XVMESSAGE(' Size field error',' ')
	    CALL ABEND
	ENDIF
	NLW = 2*(NLW/2) + 1
	NSW = 2*(NSW/2) + 1
C		           determine buffer sizes and call work through stacka
	N1 = NS+NSW-1
	N2 = NLW
	INSIZE = 2*N1*N2
	IOUTSIZE = 2*NS
	IF (QMASK) THEN
	    MSIZE = NS
	ELSE
	    MSIZE = 4
	END IF
	CALL STACKA(7,WORK,3,MSIZE,INSIZE,IOUTSIZE,N1,N2)
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE WORK(MBUF,MSIZE,INBUF,INSIZE,OUTBUF,IOUTSIZE,N1,N2)
C
C  VICAR PROGRAM ZFILL      S.Z. FRIEDMAN    MARCH 1983
C
C  SUBROUTINE WORK HANDLES ALL I/O, CALLS MEAN ANALYSIS ROUTINE
C
C
C     MBUF    OPTIONAL ARRAY FOR MASK OUTPUT DS FOR LINE N
C     INBUF   INPUT BUFFER
C     OUTBUF  OUTPUT ARRAY FOR LINE N
C
	CHARACTER*80 PRT
	INTEGER*2 INBUF(N1,N2),OUTBUF(NS)
	BYTE MBUF(MSIZE)
	LOGICAL QDENSE,QMASK
	COMMON /QQ/ ISL,ISS,NL,NS,NLIN,NSIN,NLW,NSW,IREPLACE,IEXCLUDE,
     +		    INUNIT,IOUTUNIT,MASKUNIT,QDENSE,QMASK
C
C							label processing
C
	IF (IEXCLUDE.NE.-32768) THEN
	    WRITE(PRT,10) NLW,NSW,IREPLACE,IEXCLUDE
   10	    FORMAT(' ZFILL:  NLW =',I3,', NSW =',I3,', REPLACE =',I5,
     +		   ', EXCLUDE =',I6)
	ELSE
	    WRITE(PRT,20) NLW,NSW,IREPLACE
   20	    FORMAT(' ZFILL:  NLW =',I3,', NSW =',I3,', REPLACE =',I5)
	END IF
	CALL XLADD(IOUTUNIT,'HISTORY','PARMS',PRT,ISTAT,'FORMAT',
     +		   'STRING',' ')
	CALL XVMESSAGE(PRT,' ')
C
	IF(QMASK) THEN
	    CALL XLADD(MASKUNIT,'HISTORY','PARMS',PRT,ISTAT,'FORMAT',
     +		       'STRING',' ')
	    CALL XLADD(MASKUNIT,'HISTORY','MASK',
     +		       ' 0=CHANGED   255=NO CHANGE',ISTAT,'FORMAT',
     +		       'STRING',' ')
	END IF
C
C					Read in initial lines; set pointers
C
	NLW2 = NLW/2
	NSW2 = NSW/2
	LINE1 = MAX(1,ISL-NLW2)				! First line to be read
	LINEN = MIN(NLIN,ISL+NLW2)			! Last line to be read
	ISAMP1 = MAX(1,ISS-NSW2)			! First sample read
	ISAMPN = MIN(NSIN,ISS+NS-1+NSW2)		! Last sample read
	NSAMPS = ISAMPN-ISAMP1+1			! Number of samps read
	LOCL = MAX(1,NLW2-ISL+2)		! Loc of 1st line in INBUF
	LOCS = MAX(1,NSW2-ISS+2)		! Loc of 1st samp in INBUF
C
C					Initialize all values in INBUF to the
C					excluded value
	DO I=1,N2
	    DO J=1,N1
		INBUF(J,I) = IEXCLUDE
	    END DO
	END DO
C						Read input to fill INBUF
C
	DO I=LINE1,LINEN
	    CALL XVREAD(INUNIT,INBUF(LOCS,LOCL),ISTAT,'LINE',I,
     +			'SAMP',ISAMP1,'NSAMPS',NSAMPS,' ')
	    LOCL = LOCL+1
	END DO
	LINELOC = NLW2
	LINEN = LINEN+1
	LOCL = 1
	IF (QDENSE) THEN
C
C **********************************************************    DENSE ALGORITHM
C
	    DO I=1,NL
		IF (QMASK) CALL ITLA(255,MBUF,NS)
		LINELOC = LINELOC+1
		IF (LINELOC.GT.NLW) LINELOC=1
	    	ISAMPLOC = NSW2
C							      check each sample
	    	DO J=1,NS
		    ISAMPLOC = ISAMPLOC+1
		    IF (INBUF(ISAMPLOC,LINELOC).EQ.IREPLACE) THEN
C
C						      compute replacement value
		        ISUM = 0
		        NPTS = 0
		        DO K=1,NLW
			    DO L=ISAMPLOC-NSW2,ISAMPLOC+NSW2
			    	IF(INBUF(L,K).NE.IREPLACE .AND.
     +			       	   INBUF(L,K).NE.IEXCLUDE)      THEN
				    ISUM = ISUM+INBUF(L,K)
				    NPTS = NPTS+1
			    	END IF
			    END DO
		    	END DO
		    	IF (NPTS.NE.0) THEN
			    OUTBUF(J) = FLOAT(ISUM)/FLOAT(NPTS)+0.5
			    IF (QMASK) MBUF(J) = 0
		    	ELSE					! nothing in
			    OUTBUF(J) = IREPLACE		! window, leave
		    	END IF					! as is
		    ELSE
		    	OUTBUF(J) = INBUF(ISAMPLOC,LINELOC)	! replacement
		    END IF					! not needed
	    	END DO
	    	CALL XVWRIT(IOUTUNIT,OUTBUF,ISTAT,' ')		!write out line
	    	IF (QMASK) CALL XVWRIT(MASKUNIT,MBUF,ISTAT,' ')
C								! read new line
	    	IF (LINEN.LE.NLIN) THEN
		    CALL XVREAD(INUNIT,INBUF(LOCS,LOCL),ISTAT,'LINE',
     +				LINEN,'SAMP',ISAMP1,'NSAMPS',NSAMPS,' ')
	        ELSE
		    DO J=1,N1
		    	INBUF(J,LOCL) = IEXCLUDE
		    END DO
	    	END IF
	    	LINEN = LINEN+1
	    	LOCL = LOCL+1
	    	IF (LOCL.GT.NLW) LOCL=1
	    END DO
	ELSE
C
C*********************************************************** SPARSE ALGORITHM
C
	    DO II=1,NL
C						    initialize ISUM and NPTS
		ISUM = 0
		NPTS = 0
		DO I=1,NLW
		    DO J=1,NSW
		        IF (INBUF(J,I).NE.IREPLACE .AND.
     +			    INBUF(J,I).NE.IEXCLUDE)		THEN
			    ISUM = ISUM+INBUF(J,I)
			    NPTS = NPTS+1
			END IF
		    END DO
		END DO
		ISAMPL = 1
		ISAMPR = NSW+1
C							set pointers
		IF (QMASK) CALL ITLA(255,MBUF,NS)
		LINELOC = LINELOC+1
		IF (LINELOC.GT.NLW) LINELOC=1
	    	ISAMPLOC = NSW2
C							check each sample
	    	DO J=1,NS
		    ISAMPLOC = ISAMPLOC+1
		    IF (INBUF(ISAMPLOC,LINELOC).EQ.IREPLACE) THEN
		    	IF (NPTS.NE.0) THEN		   ! compute new value
			    OUTBUF(J) = FLOAT(ISUM)/FLOAT(NPTS)+0.5
			    IF (QMASK) MBUF(J) = 0
		    	ELSE
			    OUTBUF(J) = IREPLACE	   ! nothing in window;
		    	END IF				   ! leave as is
		    ELSE
		    	OUTBUF(J) = INBUF(ISAMPLOC,LINELOC)	! don't replace
		    END IF
C							update ISUM and NPTS
		    IF (J.NE.NS) THEN
			DO K=1,NLW
			    IF(INBUF(ISAMPL,K).NE.IREPLACE .AND.
     +			       INBUF(ISAMPL,K).NE.IEXCLUDE)	THEN
				ISUM = ISUM-INBUF(ISAMPL,K)
				NPTS = NPTS-1
			    END IF
			    IF(INBUF(ISAMPR,K).NE.IREPLACE .AND.
     +			       INBUF(ISAMPR,K).NE.IEXCLUDE)	THEN
				ISUM = ISUM+INBUF(ISAMPR,K)
				NPTS = NPTS+1
			    END IF
			END DO
			ISAMPL = ISAMPL+1
			ISAMPR = ISAMPR+1
		    END IF
	    	END DO
C							     write out results
	    	CALL XVWRIT(IOUTUNIT,OUTBUF,ISTAT,' ')
	    	IF (QMASK) CALL XVWRIT(MASKUNIT,MBUF,ISTAT,' ')
C							     read new line into
C							     INBUF
	    	IF (LINEN.LE.NLIN) THEN
		    CALL XVREAD(INUNIT,INBUF(LOCS,LOCL),ISTAT,'LINE',
     +				LINEN,'SAMP',ISAMP1,'NSAMPS',NSAMPS,' ')
	        ELSE
		    DO J=1,N1
		    	INBUF(J,LOCL) = IEXCLUDE
		    END DO
	    	END IF
	    	LINEN = LINEN+1
	    	LOCL = LOCL+1
	    	IF (LOCL.GT.NLW) LOCL=1
	    END DO
	END IF
	RETURN
	END
