      INCLUDE 'VICMAIN_FOR'
      SUBROUTINE MAIN44
C------------------------------------------------------------------------------
C	SHADY2.F	This program shades a VICAR image as though the
C			objects in the image were illuminated by a source
C			at a given azimuth and elevation.
C
C     MODIFIED FOR VAX CONVERSION BY ASM, 9 AUG 1983
C     JHR: CONVERTED TO VICAR2 1 JULY 1985
C     REA: CONVERTED TO UNIX/VICAR 6 MAY 1991
C     REA: MADE BYTE OUTPUT THE DEFAULT; HALFWORD OUTPUT OPTIONAL
C------------------------------------------------------------------------------
      EXTERNAL ISHADE
      COMMON /QQ/ SL,SS,NLO,NSO,FORMAT,LSCALE,SSCALE,ZSCALE,SCALE,
     &            ILVEC,IUNIT,OUNIT,MAXDN,QHALF
C
      REAL*4 LSCALE,ILVEC(3)
      INTEGER*4 OUNIT,STAT,SL,SS
      CHARACTER*8 FORMAT
      LOGICAL XVPTST,QHALF
C------------------------------------------------------------------------------
C PARAMETERS:
C
C AZ,R		THE AZIMUTH OF THE SOURCE, MEASURED FROM UP, PROCEEDING 
C		CLOCKWISE IN DEGREES.
C
C EL,R          SOURCE ELEVATION MEASURED FROM THE IMAGE PLANE WHERE VERTICAL 
C		IS 90. IN DEGREES.
C
C SSCALE,R      THE SCALE IN THE SAMPLE DIRECTION. DEFAULTS TO 208. FT/PIXEL 
C		WHICH IS DMA RESOLUTION.
C
C LSCALE,R      LINE SCALE. DEFAULTS TO 208 FT/PIXEL.
C
C ZSCALE,R      ALTITUDE SCALE. DEFAULTS TO 1 FT/DN, THE DMA RESOLUTION.
C
C SCALE,R       THE DN/COS(THETA) IN THE OUTBUF IMAGE, WHERE THETA IS THE ANGLE
C	 	BETWEEN THE SURFACE NORMAL AND THE ILLUMINATION DIRECTION.
C
C OFORMAT,STR   OUTPUT DATA FORMAT; EITHER BYTE (DEFAULT) OR HALF.
C------------------------------------------------------------------------------
C OPEN INPUT DATA SET
      CALL XVUNIT(IUNIT,'INP',1,STAT,' ')
      CALL XVOPEN(IUNIT,STAT,'U_FORMAT','HALF','IO_ACT','SA',
     +		  'OPEN_ACT','SA',' ')
C
C GET DATA FORMAT AND CHECK
      QHALF = XVPTST('HALF')
      CALL XVGET(IUNIT,STAT,'FORMAT',FORMAT,' ')
      IF(FORMAT.NE.'BYTE'.AND.FORMAT.NE.'HALF') THEN
	 CALL XVMESSAGE(' SHADY2 ACCEPTS BYTE OR HALFWORD DATA ONLY',' ')
	 CALL ABEND
      ENDIF
C
C GET SIZE INFORMATION AND CHECK
      CALL XVSIZE(SL,SS,NLO,NSO,NLI,NSI)
      IF(SL+NLO-1 .GT. NLI) THEN
	 CALL XVMESSAGE(' NUMBER OF LINES REQUESTED EXCEEDS INPUT SIZE',
     +				' ')
	 CALL ABEND
      ENDIF
      IF(SS+NSO-1 .GT. NSI) THEN
	 CALL XVMESSAGE(
     +		      ' NUMBER OF SAMPLES REQUESTED EXCEEDS INPUT SIZE',
     +				' ')
	 CALL ABEND
      ENDIF
C
C OPEN OUTPUT DATA SET
      CALL XVUNIT(OUNIT,'OUT',1,STAT,' ')
      IF (QHALF) THEN
          MAXDN = 32767
          CALL XVOPEN(OUNIT,STAT,'OP','WRITE','U_FORMAT','HALF',
     +                'O_FORMAT','HALF','U_NL',NLO,'U_NS',NSO,
     +                'OPEN_ACT','SA','IO_ACT','SA',' ')
      ELSE
          MAXDN = 255
          CALL XVOPEN(OUNIT,STAT,'OP','WRITE','U_FORMAT','HALF',
     +                'O_FORMAT','BYTE','U_NL',NLO,'U_NS',NSO,
     +                'OPEN_ACT','SA','IO_ACT','SA',' ')
      END IF
C
C PROCESS PARAMETERS
      CALL PARPRO
C
C DETERMINE CORE SIZE NEEDED
      NBYTES=2*NSO
C
C CALL SUBROUTINE ISHADE VIA STACKA   (ALLOC 4 HALFWORD BUFFERS)
      CALL STACKA(6,ISHADE,4,NBYTES,NBYTES,NBYTES,NBYTES)
C
C CLOSE DATA SETS
      CALL XVCLOSE(IUNIT,STAT,' ')
      CALL XVCLOSE(OUNIT,STAT,' ')
C
      RETURN
      END
C
C**********************************************************************
      SUBROUTINE PARPRO
C
      COMMON /QQ/ SL,SS,NLO,NSO,FORMAT,LSCALE,SSCALE,ZSCALE,SCALE,
     &            ILVEC,IUNIT,OUNIT,MAXDN,QHALF
C
      REAL*4 AZ,EL,LSCALE,SSCALE,ZSCALE,SCALE,ILVEC(3)
      REAL*4 PI/3.141592/
      INTEGER*4 OUNIT,SL,SS
      CHARACTER*8 FORMAT
      LOGICAL QHALF
C
C Read in parameter values from the process:
C
      CALL XVPARM('AZIMUTH',AZ,ICOUNT,IDEF,1)
      CALL XVPARM('ELEV',EL,ICOUNT,IDEF,1)
      CALL XVPARM('SSCALE',SSCALE,ICOUNT,IDEF,1)
      CALL XVPARM('LSCALE',LSCALE,ICOUNT,IDEF,1)
      CALL XVPARM('ZSCALE',ZSCALE,ICOUNT,IDEF,1)
      CALL XVPARM('SCALE',SCALE,ICOUNT,IDEF,1)
C
C Convert degrees to radians
C
      AZ=180.0-AZ
      IF(AZ.LT.0.0) AZ=AZ+360.0
      REL = (EL/360.)*2*PI
      RAZ = (AZ/360.)*2*PI
      CALL SPHREC(ILVEC,1.0,REL,RAZ)
C
C ILVEC IS THE UNIT VECTOR IN THE DIRECTION OF ILLUMINATION
C
      IF(SCALE.EQ.0.0.AND.FORMAT.EQ.'HALF') SCALE=32767.
      IF(SCALE.EQ.0.0.AND.FORMAT.EQ.'BYTE') SCALE=255.
C
      RETURN
      END
C
C**********************************************************************
      SUBROUTINE ISHADE(INBUF1,NB1,INBUF2,NB2,INBUF3,NB3,OUTBUF,NB4)
C
      COMMON /QQ/ SL,SS,NLO,NSO,FORMAT,LSCALE,SSCALE,ZSCALE,SCALE,
     &            ILVEC,IUNIT,OUNIT,MAXDN,QHALF
C
      REAL*4 S(3),L(3),Z(3),R1,R2,ILVEC(3),LSCALE
      INTEGER*4 LINE,SAMP,EL,ES,SL,SS,OUNIT,STAT
      INTEGER*2 INBUF1(*),INBUF2(*),INBUF3(*),OUTBUF(*)
      CHARACTER*8 FORMAT
      LOGICAL QHALF
C
      EL=NLO-1
      ES=NSO-1
      NBYTES=2*NSO
      IREC=SL
      CALL XVREAD(IUNIT,INBUF1,STAT,'LINE',IREC,
     &                              'SAMP',SS,'NSAMPS',NSO,' ')
      CALL XVREAD(IUNIT,INBUF2,STAT,'LINE',IREC+1,
     &                              'SAMP',SS,'NSAMPS',NSO,' ')
      CALL XVREAD(IUNIT,INBUF3,STAT,'LINE',IREC+2,
     &                              'SAMP',SS,'NSAMPS',NSO,' ')
C
C SET CONSTANT VECTOR COMPONENTS
      L(1)=LSCALE
      L(2)=0.0
      S(1)=0.0
      S(2)=SSCALE
      Z(3)=L(1)*S(2)
C COMPUTE INTERMEDIATE RESULTS TO SAVE CPU TIME
      A3=L(1)*S(2)*ILVEC(3)
      A4=Z(3)*Z(3)
C
C        *** FIRST LINE ***
C
C UPPER LEFT CORNER
C
      S(3) = (INBUF1(2)-INBUF1(1))*ZSCALE
      S(1) = 0
      S(2) = SSCALE
      L(2) = 0
      L(3) = (INBUF2(1)-INBUF1(1))*ZSCALE
      L(1) = LSCALE
      CALL CROSS(L,S,Z)
      CALL DOT(Z,ILVEC,R1)
      CALL MAG(Z,R2)
      OUTBUF(1)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
C
C CENTER SAMPLES
C
      DO 100 SAMP=2,ES
      S(3)=(INBUF1(SAMP+1)-INBUF1(SAMP-1))*ZSCALE
      L(3)=(INBUF2(SAMP)-INBUF1(SAMP))*ZSCALE
      Z(1)=L(3)*S(2)
      Z(2)=L(1)*S(3)
      R1=A3-Z(1)*ILVEC(1)-Z(2)*ILVEC(2)
      R2=SQRT(Z(1)*Z(1)+Z(2)*Z(2)+A4)
      OUTBUF(SAMP)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
  100 CONTINUE
C
C UPPER RIGHT CORNER
C
      S(3)=(INBUF1(NSO)-INBUF1(NSO-1))*ZSCALE
      L(3)=(INBUF2(NSO)-INBUF1(NSO))*ZSCALE
      CALL CROSS(L,S,Z)
      CALL DOT(Z,ILVEC,R1)
      CALL MAG(Z,R2)
      OUTBUF(NSO)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
C
      CALL XVWRIT(OUNIT,OUTBUF,STAT,'NSAMPS',NSO,' ')
C
C        *** MIDDLE LINES ***
C
      DO 250 LINE=2,EL
C
C LEFT SAMPLE
C
      S(3)=(INBUF2(2)-INBUF2(1))*ZSCALE
      L(3)=(INBUF3(2)-INBUF1(2))*ZSCALE
      Z(1)=L(3)*S(2)
      Z(2)=L(1)*S(3)
      R1=A3-Z(1)*ILVEC(1)-Z(2)*ILVEC(2)
      R2=SQRT(Z(1)*Z(1)+Z(2)*Z(2)+A4)
      OUTBUF(1)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
C
C CENTER SAMPLES
C
      DO 240 SAMP=2,ES
      S(3)=(INBUF2(SAMP+1)-INBUF2(SAMP-1))*ZSCALE
      L(3)=(INBUF3(SAMP)-INBUF1(SAMP))*ZSCALE
      Z(1)=L(3)*S(2)
      Z(2)=L(1)*S(3)
      R1=A3-Z(1)*ILVEC(1)-Z(2)*ILVEC(2)
      R2=SQRT(Z(1)*Z(1)+Z(2)*Z(2)+A4)
      OUTBUF(SAMP)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
  240 CONTINUE
C
C RIGHT SAMPLE
C
      S(3)=(INBUF2(NSO)-INBUF2(NSO-1))*ZSCALE
      L(3)=(INBUF3(NSO)-INBUF1(NSO))*ZSCALE
      Z(1)=L(3)*S(2)
      Z(2)=L(1)*S(3)
      R1=A3-Z(1)*ILVEC(1)-Z(2)*ILVEC(2)
      R2=SQRT(Z(1)*Z(1)+Z(2)*Z(2)+A4)
      OUTBUF(NSO)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
C
      CALL XVWRIT(OUNIT,OUTBUF,STAT,'NSAMPS',NSO,' ')
C
C AFTER NEXT TO LAST LINE DON'T READ ANYMORE
C
      IF(LINE.EQ.EL) GO TO 250
      CALL MVL(INBUF2,INBUF1,NBYTES)
      CALL MVL(INBUF3,INBUF2,NBYTES)
      IREC=SL+LINE+1
      CALL XVREAD(IUNIT,INBUF3,STAT,'LINE',IREC,'SAMP',SS,
     +		  'NSAMPS',NSO,' ')
  250 CONTINUE
C
C        *** LAST LINE ***
C
C LOWER LEFT CORNER
C
      S(3)=(INBUF3(2)-INBUF3(1))*ZSCALE
      L(3)=(INBUF3(1)-INBUF2(1))*ZSCALE
      CALL CROSS(L,S,Z)
      CALL DOT(Z,ILVEC,R1)
      CALL MAG(Z,R2)
      OUTBUF(1)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
C
C CENTER SAMPLES
C
      DO 300 SAMP=2,ES
      S(3)=(INBUF3(SAMP+1)-INBUF3(SAMP-1))*ZSCALE
      L(3)=(INBUF3(SAMP)-INBUF2(SAMP))*ZSCALE
      Z(1)=L(3)*S(2)
      Z(2)=L(1)*S(3)
      R1=A3-Z(1)*ILVEC(1)-Z(2)*ILVEC(2)
      R2=SQRT(Z(1)*Z(1)+Z(2)*Z(2)+A4)
      OUTBUF(SAMP)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
  300 CONTINUE
C
C LOWER RIGHT CORNER
C
      S(3)=(INBUF3(NSO)-INBUF3(NSO-1))*ZSCALE
      L(3)=(INBUF3(NSO)-INBUF2(NSO))*ZSCALE
      CALL CROSS(L,S,Z)
      CALL DOT(Z,ILVEC,R1)
      CALL MAG(Z,R2)
      OUTBUF(NSO)=MIN(MAXDN,MAX1(R1/R2*SCALE,0.0))
C
      CALL XVWRIT(OUNIT,OUTBUF,STAT,'NSAMPS',NSO,' ')
C
      RETURN
      END
C
C**********************************************************************
      SUBROUTINE VECTOR
C
      REAL R(3),RMAG,LAT,LONG
      REAL A(3),B(3),C(3)
C
      ENTRY SPHREC(R,RMAG,LAT,LONG)
C CONVERT SPHERCAL COORDINATES TO RECTANGULAR VECTOR
      R(1)=RMAG*COS(LAT)*COS(LONG)
      R(2)=RMAG*COS(LAT)*SIN(LONG)
      R(3)=RMAG*SIN(LAT)
      RETURN
C
      ENTRY RECSPH(R,RMAG,LAT,LONG)
C CONVERT RECTANGULAR VECTOR COMPONENTS TO SPHERICAL
      RMAG=SQRT(R(1)*R(1)+R(2)*R(2)+R(3)*R(3))
      LAT=ATAN2(R(3),SQRT(R(1)**2+R(2)**2))
      LONG=ATAN2(R(2),R(1) )
      RETURN
C
      ENTRY UNIT(R)
C MAKE R A UNIT VECTOR IN SAME DIRECTION
      X=SQRT(R(1)*R(1)+R(2)*R(2)+R(3)*R(3))
      DO 10 J=1,3
10    R(J)=R(J)/X
      RETURN
C
      ENTRY MAG(A,RMAG)
C MAGNITUDE OF VECTOR
      RMAG=SQRT(A(1)*A(1)+A(2)*A(2)+A(3)*A(3))
      RETURN
C
      ENTRY DOT (A,B,PROD)
C VECTOR DOT PRODUCT
      PROD=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
      RETURN
C
      ENTRY CROSS(A,B,C)
C VECTOR CROSS PRODUCT C = A X B
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
      RETURN
      END
