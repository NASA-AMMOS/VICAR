/* 
		JFrameJade
		A basic implementation of the JFrame class.
		A simple windiow to display an image
*/
 
package jpl.mipl.io;

import javax.swing.*;
import java.awt.*;

/**/
// import com.sun.media.jai.*;
import java.awt.image.*;
// import java.awt.color.*;
import java.awt.event.*;
import java.text.*;
import javax.swing.event.*;
import com.sun.media.jai.codec.*;
import jpl.mipl.io.codec.*;
import jpl.mipl.jade.*;
import jpl.mipl.util.*;
import java.io.*;
import java.util.*;
import javax.media.jai.*;
import javax.imageio.*;
import javax.imageio.spi.*;
import javax.imageio.event.*;
import javax.imageio.stream.*;
import java.awt.RenderingHints;
import java.awt.image.renderable.ParameterBlock;
/***/

public class JFrameJade extends javax.swing.JFrame implements java.awt.event.ActionListener
{
	public JFrameJade()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setJMenuBar(JMenuBar1);
		getContentPane().setLayout(new CardLayout(0,0));
		setSize(400,400);
		setVisible(false);
		JPanelMain.setLayout(new BorderLayout(0,0));
		getContentPane().add("card1",JPanelMain);
		JPanelMain.setBounds(0,0,400,400);
		//$$ JMenuBar1.move(0,306);
		JMenuFile.setText("File");
		JMenuFile.setActionCommand("jmenu");
		JMenuBar1.add(JMenuFile);
		JMenuItemOpen.setText("Open");
		JMenuItemOpen.setActionCommand("Open");
		JMenuFile.add(JMenuItemOpen);
		JMenuItemOpenRendered.setText("Open As RenderedImage");
		JMenuItemOpenRendered.setActionCommand("OpenRendered");
		JMenuFile.add(JMenuItemOpenRendered);
		JMenuItemSaveAs.setText("Save As");
		JMenuItemSaveAs.setActionCommand("SaveAs");
		JMenuFile.add(JMenuItemSaveAs);
		JMenuItemSave.setText("Save");
		JMenuItemSave.setActionCommand("Save");
		JMenuFile.add(JMenuItemSave);
		JMenuFile.add(JSeparator1);
		
		openLutItem.setText("Open LUT");
		openLutItem.setActionCommand("OpenLUT");
		JMenuFile.add(openLutItem);
		saveLutItem.setText("Save LUT");
		saveLutItem.setActionCommand("SaveLUT");
		JMenuFile.add(saveLutItem);
		JMenuFile.add(JSeparator2);
		quitItem.setText("Quit");
		quitItem.setActionCommand("Quit");
		JMenuFile.add(quitItem);
		
		JMenuFormat.setText("Misc");
		
		reformatToByteItem.setText("reformat To BYTE");
		reformatToByteItem.setSelected(reformatToByte);
		JMenuFormat.add(reformatToByteItem);
		
		saveFormatItem.setText("Save Format");
		
		// saveFormatItem = addFormatMenuItems(saveFormatItem);
		writerFormatNames = ImageIO.getWriterFormatNames();
		int ct = writerFormatNames.length;
        if (debug) System.out.println("registered writer plugin format names "+ct+" **********");
        
        formatItems = new javax.swing.JRadioButtonMenuItem[ct];
        String format;
        JRadioButtonMenuItem formatItem;
        for (int i=0 ; i< ct ; i++) {
        	format = writerFormatNames[i];
        	formatItem = new javax.swing.JRadioButtonMenuItem();
        	formatItem.setText(format);
			formatItem.setActionCommand(format);
			formatItem.setToolTipText("Set Save Format type");
			if (i==0) {
				formatItem.setSelected(true);
			}
			else {
				formatItem.setSelected(false);
			}
			JMenuFormatSubMenu.add(formatItem);
			saveFormatButtonGroup.add(formatItem);
			formatItems[i] = formatItem;
			// add to the button group too
			if (debug) {
            	System.out.println((i+1) +") "+format );
            	System.out.println("  "+formatItem );
			}
        }
        // saveFormatButtonGroup.setSelected()
        ButtonModel bm = saveFormatButtonGroup.getSelection();
        if (debug) {
        	System.out.println("bm "+bm);
        
        	System.out.println("bm "+bm.getActionCommand());
        
        
			System.out.println("formatItems.length "+formatItems.length );
        }
		// JMenuFormat.add(saveFormatItem);
		JMenuFormatSubMenu.setText("Save Format");
		JMenuFormat.add(JMenuFormatSubMenu);
		JMenuBar1.add(JMenuFormat);
		
		//}}

		//{{INIT_MENUS
		//}}
		
		//{{REGISTER_LISTENERS
		/**
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
		SymAction lSymAction = new SymAction();
		quitItem.addActionListener(lSymAction);	
		saveLutItem.addActionListener(lSymAction);	
		openLutItem.addActionListener(lSymAction);	
		**/
		//}}
		quitItem.addActionListener(this);	
		saveLutItem.addActionListener(this);	
		openLutItem.addActionListener(this);
		JMenuItemOpen.addActionListener(this);	
		JMenuItemOpenRendered.addActionListener(this);		
		
		openFileDialog.setMode(FileDialog.LOAD);
		openFileDialog.setTitle("Open");
	}

	public JFrameJade(String sTitle)
	{
		this();
		setTitle(sTitle);
	}

	public void setVisible(boolean b)
	{
		if (b)
			setLocation(50, 50);
		super.setVisible(b);
	}


	public String getSelectedSaveFormat() {
		ButtonModel bm = saveFormatButtonGroup.getSelection();
		return bm.getActionCommand();
		
	}
	
	public void setSelectedSaveFormat(String in) {
		Enumeration e = saveFormatButtonGroup.getElements();
		
		ButtonModel bm = saveFormatButtonGroup.getSelection();
		String f = bm.getActionCommand();
		System.out.println("selected: "+f+"  set to:"+in);
		boolean formatFound = false;
		
		if (f.equals(in)) return;
		
		// go thru twice, first see if the input format is in the list
		// if it is go thru, deselect and set the one requested
		while (e.hasMoreElements()) {
			JRadioButtonMenuItem menuItem = (JRadioButtonMenuItem) e.nextElement();
			String ss = menuItem.getActionCommand();
			if (ss.equals(in)) {
				formatFound = true;
				System.out.println("FOUND !!! "+in+"  "+ss+"  "+menuItem.isSelected());
			}
			
			System.out.println("selected "+f+"  "+ss+"  "+menuItem.isSelected());
		}
		
		if (formatFound == true) {
			e = saveFormatButtonGroup.getElements();
			// get it again to reset the Enumneration
			while (e.hasMoreElements()) {
				JRadioButtonMenuItem menuItem = (JRadioButtonMenuItem) e.nextElement();
				String ss = menuItem.getActionCommand();
				if (ss.equals(in)) {
					menuItem.setSelected(true);
					System.out.println("selected "+in+"  "+ss+"  "+menuItem.isSelected());
				}
				else {
					menuItem.setSelected(false);
				}
			
			System.out.println("selected "+f+"  "+ss+"  "+menuItem.isSelected());
			// jadeDisplay.
			// if (jPanelBands != null) {
			// 	jPanelBands.setOutputFormat(in);
			//   }
			}
		}
		
	}
	
	private JMenuItem addFormatMenuItems(JMenuItem menu) {
		
		
		
		// get a ;list of formats
		// walk thru the list adding new items
		String[] writerFormatNames = ImageIO.getWriterFormatNames();
		int ct = writerFormatNames.length;
		if (debug) {
        	System.out.println("registered writer plugin format names "+ct+" **********");
        	System.out.println("menu: "+menu );
		}
        formatItems = new javax.swing.JRadioButtonMenuItem[ct];
        String format;
        JRadioButtonMenuItem formatItem;
        for (int i=0 ; i< ct ; i++) {
        	format = writerFormatNames[i];
        	formatItem = new javax.swing.JRadioButtonMenuItem();
        	formatItem.setText(format);
			formatItem.setActionCommand(format);
			formatItem.setToolTipText("Set Save Format type");
			menu.add(formatItem);
			saveFormatButtonGroup.add(formatItem);
			formatItems[i] = formatItem;
			// add to the button group too
			if (debug) {
            System.out.println((i+1) +") "+format );
            System.out.println("  "+formatItem );
			}
        }
		
	return menu;	
	}
/**
	public void setTitle(String sTitle)
	{
		
		setTitle(sTitle);
	}
	**/
	static public void main(String args[])
	{
		(new JFrameJade()).setVisible(true);
	}

	
	
    // public void setImage(PlanarImage im, int i, int j) {
    public void setImage(RenderedImage im) {
     
    // System.out.println("setImage "+i+" "+j);
    // use Jade createDisplay which gets everything
    
    /**
    JadeDisplay jd  = new JadeDisplay(im);
    jd.setRepaintPolicy(JadeDisplay.REPAINT_CACHE);
	JScrollPane sp = new JScrollPane(jd);
	
    sp.setViewport(new JViewportImage());
    sp.setViewportView(jd);
	new MouseScroller(sp.getViewport());
    SwingUtilities.invokeLater(new Runnable() { public void run() {
        RepaintManager.currentManager(null).setDoubleBufferingEnabled(false);
        }});
	sp.setPreferredSize(new Dimension(300,300));
	**/
    inputImage = im;
    
    if (jadeDisplay != null) {
    	System.out.println("setImage *******************************");
    	jadeDisplay.setImage(im);
    	jadeDisplay.invalidate();
    }
    else {
    
    
    	int width = 200;
    	int height = 400;
    	boolean mouseScroller = true;
    	// should get dimensions from the image, 
    
    	// JScrollPane sp = JadeDisplay.createDisplay(im, width, height, mouseScroller);
     
    	scrollPane = JadeDisplay.createDisplay(im, width, height, true);
    	jadeDisplay = (JadeDisplay) scrollPane.getViewport().getView();
    	jadeDisplay.setRepaintPolicy(JadeDisplay.REPAINT_CACHE);
    	// jPanelCenter.add(scrollPane,"scrollPane");
    	JPanelMain.add(scrollPane); 
    } 
    
    }
    
    
    public void setImage(RenderedImage im, int[] bandList) {
    	inputImage = im;
    
    	// jPanelBands = new JPanelBands(im, bandList); // this gets a JadeDisplay and adds some controls
    	// jPanelBands.setOutputFormat(getSelectedSaveFormat());
		// JPanelMain.add(jPanelBands);  
        
    }
    
	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();

		super.addNotify();

		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;

		// Adjust size of frame according to the insets and menu bar
		Insets insets = getInsets();
		javax.swing.JMenuBar menuBar = getRootPane().getJMenuBar();
		int menuBarHeight = 0;
		if (menuBar != null)
			menuBarHeight = menuBar.getPreferredSize().height;
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height + menuBarHeight);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	javax.swing.JPanel JPanelMain = new javax.swing.JPanel();
	javax.swing.JMenuBar JMenuBar1 = new javax.swing.JMenuBar();
	javax.swing.JMenu JMenuFile = new javax.swing.JMenu();
	javax.swing.JMenuItem JMenuItemOpen = new javax.swing.JMenuItem();
	javax.swing.JMenuItem JMenuItemOpenRendered = new javax.swing.JMenuItem();
	javax.swing.JMenuItem JMenuItemSaveAs = new javax.swing.JMenuItem();
	javax.swing.JMenuItem JMenuItemSave = new javax.swing.JMenuItem();
	javax.swing.JSeparator JSeparator1 = new javax.swing.JSeparator();
	javax.swing.JMenuItem JMenuItemOpenLUT = new javax.swing.JMenuItem();
	javax.swing.JMenuItem JMenuItemSaveLUT = new javax.swing.JMenuItem();
	javax.swing.JSeparator JSeparator2 = new javax.swing.JSeparator();
	javax.swing.JMenuItem quitItem = new javax.swing.JMenuItem();
	javax.swing.JMenuItem openLutItem = new javax.swing.JMenuItem();
	javax.swing.JMenuItem saveLutItem = new javax.swing.JMenuItem();
	
	javax.swing.JMenu JMenuFormat = new javax.swing.JMenu();
	javax.swing.JMenu JMenuFormatSubMenu = new javax.swing.JMenu();
	
	javax.swing.JMenuItem reformatToByteItem = new javax.swing.JCheckBoxMenuItem();
	javax.swing.JMenuItem saveFormatItem = new javax.swing.JMenuItem();
	
	javax.swing.JRadioButtonMenuItem[] formatItems ;
	ButtonGroup saveFormatButtonGroup = new ButtonGroup();
	
	String[] writerFormatNames ;
	JFileChooser jFileChooser1 = new JFileChooser();
	
	boolean debug = false; // true; // false;
	
	boolean reformatToByte = true; // set by a menu item
	//}}

	//{{DECLARE_MENUS
	//}}

	JadeDisplay jadeDisplay = null;
	JScrollPane scrollPane = null;
	RenderedImage inputImage = null;
	BufferedImage newImage = null;
	
	// JPanelBands jPanelBands = null;
	int[] bandList = null;
	
	//Create a file chooser
	final JFileChooser fc = new JFileChooser();

    FileDialog saveFileDialog = new java.awt.FileDialog(this);
	FileDialog openFileDialog = new java.awt.FileDialog(this);
	
	
    //-----
    class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			// System.out.println("closing -- "+object);
			// if (object == JFrameImageBob.this)
			if (object == this)
				windowClosing(event);
		}
	}

	public void setDebug(boolean d) {
		debug = d;
	}
	
	void windowClosing(java.awt.event.WindowEvent event)
	{
		// to do: code goes here.
		// System.out.println("closing the window and the application");
		try {
			this.setVisible(false);    // hide the Frame
		    this.dispose();            // free the system resources
		    System.exit(0);            // close the application this.exitApplication();
		} catch (Exception e) {
		}
	}

	
	public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			String action = event.getActionCommand();
			// if (object == quitItem)
			// 	quitItem_actionPerformed(event);
			if (action.equalsIgnoreCase("Quit")) {
				quitItem_actionPerformed(event);
			}
			else if (action.equalsIgnoreCase("Open")) {
				openItem_actionPerformed(event);
			}
			else if (action.equalsIgnoreCase("OpenRendered")) {
				openRenderedItem_actionPerformed(event);
			}
			else if (action.equalsIgnoreCase("OpenLUT")) {
				openLutItem_actionPerformed(event);
			}
			if (action.equalsIgnoreCase("SaveLUT")) {
				saveLutItem_actionPerformed(event);
			}
			
		}



/**
 * Get the image as a RenderedImage. It may not have a ColorModel.
 * The user should check and add one for display purposes. The image 
 * may not be displayable because it is TYPE SHORT or has too many bands.
 * Run image OPS to get it to a displayable form. Then get a ColorModel and
 * create a PlanarImage to display */

public RenderedImage readAsRenderedImage(File file) {
	RenderedImage ri = null;
	String readerClassName, readerFormat;
	ImageReader reader = null ;
	
	try {
		// new File(fileName)
            ImageInputStream iis = ImageIO.createImageInputStream(file);
        

            if (iis == null) {
                System.out.println("Unable to get a stream!");
                // System.exit(0);
                return null;
            }

            Iterator iter = ImageIO.getImageReaders(iis);
            
            while (iter.hasNext()) {
                reader = (ImageReader)iter.next();
                
                readerClassName = reader.getClass().getName() ;
                // get the format we are reading
                readerFormat = reader.getFormatName();
                if (debug) System.out.println("Using " +
                               reader.getClass().getName() +
                               " to read."+readerFormat);
                break; // just get the first one 
            }

            if (reader == null) {
                System.err.println("Unable to find a reader!");
                // System.exit(0);
                return null;
            }

        
            reader.setInput(iis, true);
      
        } catch (IOException ioe) {
            System.out.println("I/O exception");
            System.exit(0);
        }
        
 		
		try {
				ImageReadParam param = reader.getDefaultReadParam();
				// add something to it
     			ri = reader.readAsRenderedImage(0, param);
         } catch (IOException ioe) {
                System.out.println("I/O exception !");
                System.exit(0);
         }	
	
	return ri;
}
	
/*************************************************
* Does a simple ImageIO read, only gets the RenderedImage. <br>
* No Metadata is returned <br>
* @param String - the name of the file to read
* * the returned image is really a BufferedImage
**************************************************/
public RenderedImage simpleRead(File file) {
    RenderedImage image = null;
    
    try {
	  image = ImageIO.read(file);
	  } catch (Exception exc) {
            System.out.println("\nError: " + file +
                               " - exception during read!");
            exc.printStackTrace();
            System.out.println();
      }
   return image;
}



void openRenderedItem_actionPerformed(java.awt.event.ActionEvent event)
	{
 
      System.out.println("OpenRendered file");
      PlanarImage pi = null;
      RenderedImageAdapter ria = null;
      BufferedImage bi = null;
      // open a file
      
      // save last selection, set Dialog to that dir
      // jFileChooser1.setCurrentDirectory();
      	int returnVal = jFileChooser1.showOpenDialog(this);
      	if (returnVal == JFileChooser.APPROVE_OPTION) {
        	File f = jFileChooser1.getSelectedFile();
			// String inputFileName = f.getAbsoluteFile();
			// RenderedImage sourceImage = simpleRead(f);
			RenderedImage sourceImage = readAsRenderedImage(f);
			
			// add a ColorModel
			ColorModel cm = sourceImage.getColorModel();
			SampleModel sm = sourceImage.getSampleModel();
			int w = sourceImage.getWidth();
			int h = sourceImage.getHeight();
			System.out.println("OpenRendered file "+f);
			System.out.println("width ="+w+"  height = "+h);
			System.out.println("SampleModel "+sm);
			System.out.println("ColorModel "+cm);
			
			/***
			// add any processing we might need
			if (cm == null) {
				cm = PlanarImage.createColorModel(sm);
				if (cm == null) {
					System.out.println("Unable to create a ColorModel");
					return;
				}
				else {
					// add operators, create a PlanarImage
					// how do I ad the ColorModel if it doen't have one ???
					ria = new RenderedImageAdapter(sourceImage);
					// WriteableRaster ra = sourceImage.getData();
					// bi = new BufferedImage(cm, );
					
// BufferedImage(ColorModel cm, WritableRaster raster, boolean isRasterPremultiplied, Hashtable properties) 

					// or do I create a BufferedImage ??
					
				}
			}
			***/
			/** this may be required to write an image out properly to another format
			 * otherwise there may be errors getting the data during output
			 * may set this if an image is to be written out
			 * like in the save handler
			 * 
			 * if (renderedImage instanceof VicarRenderedImage ) {
     				VicarRenderedImage vri = (VicarRenderedImage) renderedImage;
     				vri.setTileWidth(vri.getWidth());
     			}			 */
			
			String name = f.getName();
			
			// RenderedImage cim = conditionImage(sourceImage ) ;
			// get selected format set in a menu item
			// reformat data a BYTE so it can be viewed
			reformatToByte = reformatToByteItem.isSelected();
			RenderedImage cim = sourceImage;
			if (reformatToByte) {
			 	cim = processFormat(sourceImage, DataBuffer.TYPE_BYTE ) ;
			}
			 
			
			if (cim != null) {
				setImage(cim);
				
				// check if this is a multiband image, for testing
				// public void setImage(RenderedImage im, int[] bandList) {
        		// setImage(sourceImage);
        		setTitle(name);
			} else {
				System.out.println("ERROR reading file: "+f);
			}
      }

    } 
 // convert the input image to a different DataType
    public RenderedImage processFormat(RenderedImage image, int newDataType) {
        
        // DataBuffer.TYPE_BYTE
        RenderedImage sourceImage = image;
        
        ComponentSampleModel sampleModel = (ComponentSampleModel) image.getSampleModel();
        int oldDataType = sampleModel.getDataType();
        
        if (oldDataType == DataBuffer.TYPE_BYTE) return image;
        
        int numbands = sampleModel.getNumBands();
        
        
        // check if (oldDataType == newDataType) return image;
        if (debug) System.out.println("processFormat "+numbands+" bands   "+oldDataType+ " -> "+newDataType);
        
		   // make a new  SampleModel for the new image data type
		   // get all the stuff we need to know from the old sampleModel
		  int pStride =  sampleModel.getPixelStride();
		  int slStride = sampleModel.getScanlineStride();
		  int[] bandOffsets = sampleModel.getBandOffsets();
		  if (debug) System.out.println(" *** pStride="+pStride+"  slStride="+slStride+"  bandOffsets="+bandOffsets );
           //  int w = sampleModel.getWidth();
           // int h = sampleModel.getHeight();
         // ---------------------------------------------------------
         // rescale the pixel values of the image based on the image extrema
    //      RenderedImage temp = image;
	ParameterBlock PB=new ParameterBlock();
	PB.addSource(image).add(null).add(10).add(10);
	RenderedImage extrema=JAI.create("extrema",PB);

	// scale all pixels by:   v1= m * v0 +b    (assuming one band per pixel)
	double scale[][]=(double[][])extrema.getProperty("extrema");
	// double ceiling=Byte.MAX_VALUE*2; // treat as unsigned
	double ceiling = getMaxForDataType(newDataType) ;
	
	
	
	// double ceiling=Short.MAX_VALUE*2;
	double max=1,min=ceiling;
	for(int i=0;i<scale[0].length;i++){
	    max=Math.max(max,scale[1][i]);
	    min=Math.min(min,scale[0][i]);
	}
	if (debug) System.out.println("processFormat extrema ceiling="+ceiling+"  min="+min+"  max="+max);
	// round max up to the nearest power of 2. 
	// max=Math.pow(2.0,Math.round(Math.log(max)/Math.log(2)));
	// min=0;
	
	
	// this will be for BYTE output
	double constant[] = new double[]{1.0};
	double offset[] = new double[]{0.0};
	
	
	
	constant[0] = ceiling /(max-min);
	offset[0] = min * constant[0] * -1.0; // offset is added only for unsigned ??
	
	if (debug) {
		System.out.println("processFormat constant="+constant[0]+"  offset="+offset[0]);
	
	
		double min1 = (min * constant[0]) + offset[0];
		double max1 = (max * constant[0]) + offset[0];
		System.out.println("processFormat  min="+min+"  min1="+min1+"  max="+max+"  max1="+max1);
	}
	
	PB=new ParameterBlock();
	// PB.addSource(temp).add(new double[]{ceiling/(max-min)}).add(new double[]{ceiling*min/(min-max)});
	PB.addSource(image).add(constant).add(offset);
	RenderedImage temp=JAI.create("rescale",PB);


	if (debug) {
		// do extrema again after the rescale
	
	
		PB=new ParameterBlock();
		PB.addSource(temp).add(null).add(10).add(10);
		extrema=JAI.create("extrema",PB);

		// scale all pixels by:   v1= m * v0 +b    (assuming one band per pixel)
		scale =(double[][])extrema.getProperty("extrema");
		ceiling=Short.MAX_VALUE*2;
		max=1;
		min=ceiling;
		for(int i=0;i<scale[0].length;i++){
	    	max=Math.max(max,scale[1][i]);
	    	min=Math.min(min,scale[0][i]);
		}
		System.out.println("processFormat new extrema  min="+min+"  max="+max);
	}
    
    image = temp;    
        // ---------------------------------------------------------
        // rendering hint with a ImageLayout
        
       
        // use tileWidth of input image
        // ComponentSampleModel  newSampleModel = new ComponentSampleModel(DataBuffer.TYPE_BYTE,
        ComponentSampleModel  newSampleModel = new ComponentSampleModel( newDataType,
                              image.getTileWidth(),image.getTileHeight(),pStride,slStride,bandOffsets);
                              //  tileWidth,tileHeight,pStride,slStride,bandOffsets);
                                  // width, height, // OR ?? tileWidth, tileHeight,
                                  // pixelStride, scanlineStride, // tileScanlineStride bandOffsets);
                                  
        // ComponentColorModel    newColorModel = ImageCodec.createComponentColorModel(newSampleModel); // newSampleModel
        ColorModel    newColorModel = ImageCodec.createComponentColorModel(newSampleModel); // newSampleModel
        
        // System.out.println("sampleModel="+sampleModel);
        // System.out.println("newSampleModel="+newSampleModel);
         
        ImageLayout layout; 
        layout = new ImageLayout(0,0, image.getTileWidth(),image.getTileHeight(), newSampleModel, newColorModel);
        // layout = new ImageLayout(0,0, tileWidth, tileHeight, newSampleModel, newColorModel);
        // System.out.println("ImageLayout: "+layout);
        /**
        public ImageLayout(int tileGridXOffset,
                   int tileGridYOffset,
                   int tileWidth,
                   int tileHeight,
                   java.awt.image.SampleModel sampleModel,
                   java.awt.image.ColorModel colorModel)

     Constructs an ImageLayout with its tile grid layout, SampleModel, and ColorModel parameters set. The
     sampleModel and colorModel parameters may be set to null, but are nonetheless considered 'set' in the sense
     that they will override the corresponding parameter in any RenderedImage.
     Parameters:
          tileGridXOffset - the X coordinate of tile (0, 0).
          tileGridYOffset - the Y coordinate of tile (0, 0).
          tileWidth - the width of a tile.
          tileHeight - the height of a tile.
          sampleModel - the image's SampleModel.
          colorModel - the image's ColorModel.
            ***/
        
        
         
        RenderingHints hints = new RenderingHints(JAI.KEY_IMAGE_LAYOUT,layout);
		ParameterBlock pb = new ParameterBlock();
		pb.addSource(image);
		pb.add(newDataType);
				
		RenderedImage  formatedImage = JAI.create("format", pb, hints);
		
		return (formatedImage);    
    }
    
    /**
     * convenience for using format/rescale operators
     * @param dataType
     * @return double
     */
    public double getMaxForDataType(int dataType) {
    	
    	double max = 0.0;
    	if (dataType == DataBuffer.TYPE_BYTE) {
    		max = Byte.MAX_VALUE * 2;//used as unsigned
	        }
	    else if (dataType == DataBuffer.TYPE_SHORT) {
	    	max = Short.MAX_VALUE;
	        }	    
	    else if (dataType == DataBuffer.TYPE_USHORT) {	    	
	    	max = Short.MAX_VALUE * 2;
	        }
	    else if (dataType == DataBuffer.TYPE_INT) {
	    	max = Integer.MAX_VALUE; // or 0.0 ?? // assume unsigned ???
	        }	    
	    else if (dataType == DataBuffer.TYPE_FLOAT) {
	    	max = Float.MAX_VALUE; 
	        }
	    else if (dataType == DataBuffer.TYPE_DOUBLE) {
	    	max = Double.MAX_VALUE; 
	        }
	    
	    return max;
	 }
    
    
 /**
    * converts an image which is not displayable to one that is
    * from mica
    * This needs to be put in a central library with other useful
    * imageOps.
    **/
    private RenderedImage conditionImage(RenderedImage imageOp_base ) {

	boolean saveDebug = debug;
	debug = false;
	ParameterBlock PB;
	RenderedImage temp=imageOp_base;
	 SampleModel sm = temp.getSampleModel();
	 int type = sm.getDataType();
	 if (debug) System.out.println("DataType = "+type);
	 if (type == DataBuffer.TYPE_USHORT || type == DataBuffer.TYPE_BYTE) {
	 	if (debug) System.out.println("conditionImage  Image is BYTE or USHORT, no conditioning needed");
	 	// return temp;
	 	return imageOp_base;
	 } else {
	 	if (debug) System.out.println("conditionImage  Performing image conversions...");
	 }

	// convert the image to TYPE_USHORT & fix the null color model
	PB=new ParameterBlock();
	PB.addSource(temp).add(java.awt.image.DataBuffer.TYPE_USHORT);
	// PB.addSource(temp).add(java.awt.image.DataBuffer.TYPE_BYTE);
	temp=JAI.create("Format",PB);

	// rescale the pixel values of the image based on the image extrema
	PB=new ParameterBlock();
	PB.addSource(temp).add(null).add(10).add(10);
	RenderedImage extrema=JAI.create("extrema",PB);

	// scale all pixels by:   v1= m * v0 +b    (assuming one band per pixel)
	double scale[][]=(double[][])extrema.getProperty("extrema");
	double ceiling=Short.MAX_VALUE*2;
	double max=1,min=ceiling;
	for(int i=0;i<scale[0].length;i++){
	    max=Math.max(max,scale[1][i]);
	    min=Math.min(min,scale[0][i]);
	}
	// round max up to the nearest power of 2. 
	max=Math.pow(2.0,Math.round(Math.log(max)/Math.log(2)));
	min=0;
	PB=new ParameterBlock();
	PB.addSource(temp).add(new double[]{ceiling/(max-min)}).add(new double[]{ceiling*min/(min-max)});
	temp=JAI.create("rescale",PB);

	imageOp_base=temp;
	if (debug) System.out.println("Conversions complete.");
	
	debug = saveDebug;
	return  imageOp_base ;
    }

 
 
 void openItem_actionPerformed(java.awt.event.ActionEvent event)
	{
 
      System.out.println("Open file");
      // open a file
      
      // save last selection, set Dialog to that dir
      // jFileChooser1.setCurrentDirectory();
      	int returnVal = jFileChooser1.showOpenDialog(this);
      	if (returnVal == JFileChooser.APPROVE_OPTION) {
        	File f = jFileChooser1.getSelectedFile();
			// String inputFileName = f.getAbsoluteFile();
			RenderedImage sourceImage = simpleRead(f);
			RenderedImage cim = sourceImage;
			// check a flag to see if we reformat to byte and auto stretch
			reformatToByte = reformatToByteItem.isSelected();
			if (reformatToByte) {
			 cim = processFormat(sourceImage, DataBuffer.TYPE_BYTE ) ;
			}
			System.out.println("Open file "+f);
			String name = f.getName();
			if (cim != null) {
        		setImage(cim);
        		setTitle(name);
			} else {
				System.out.println("ERROR reading file: "+f);
			}
      }

    }
	void quitItem_actionPerformed(java.awt.event.ActionEvent event)
	{
		// to do: code goes here.
			 
	
        // to do: code goes here.
        
		try {
			this.setVisible(false);    // hide the Frame
		    this.dispose();            // free the system resources
		    System.exit(0);            // close the application
		} catch (Exception e) {
		}
	}
	
	void openLutItem_actionPerformed(java.awt.event.ActionEvent event)
	{
	
	/**
    int returnVal = fc.showOpenDialog(this); // Open
    
    int returnVal = fc.showSaveDialog(this);  // Save



    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file = fc.getSelectedFile();
        //this is where a real application would open the file.
        log.append("Opening: " + file.getName() + "." + newline);
    } else {
        log.append("Open command cancelled by user." + newline);
    }
	*****/


        
        try {
			
			openFileDialog.setVisible(true);
			String dirname = openFileDialog.getDirectory();
			String filename = openFileDialog.getFile();
			System.out.println("open text file "+dirname+filename);
			
			
			
		} catch (java.lang.Exception e) {
		}
        
		
	}
	
	void saveLutItem_actionPerformed(java.awt.event.ActionEvent event)
	{
	
        System.out.println(" ---------------- "+getSelectedSaveFormat() );
        setSelectedSaveFormat("png") ;
        System.out.println(" ---------------- "+getSelectedSaveFormat() );
	
	}
}
