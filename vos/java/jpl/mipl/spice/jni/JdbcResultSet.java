/*
 * ResultSet.java
 *
 * Created on August 18, 2000, 9:40 AM
 */

package jpl.mipl.spice.jni;

import jpl.mipl.spice.jni.KernelPool;

import java.io.Reader;
import java.sql.NClob;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLXML;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

/** A ResultSet provides access to a table of data. 
 *  A ResultSet object is usually generated by executing a
 *  Statement.
 *
 *  Warning:  If a cell of a variable-length array has only one element,
 *            getObject will return a Double, Int, or String rather than an array.
 * @author Michael Brady
 */
public class JdbcResultSet extends Object implements java.sql.ResultSet
{

    private KernelPool m_pool = null;
    private String m_query = null;
    private jpl.mipl.spice.jni.JdbcResultSetMetaData m_metaData = null;
    private int m_cursor = -1;
    private int m_numRecords = 0;
    
    /** Creates new ResultSet
     * @param query the query which created this result set
     * @param numRecords The number of records available for the user to read.
     */
    JdbcResultSet(KernelPool pool,String query,int numRecords)
    {
      m_pool = pool;
      m_query = query;
      m_numRecords = numRecords;
    }

    /**
     *  True if the specified column is an array.
     *
     *  Don't call this before getMetaData(), or an infinte loop will occur.
     */
    private boolean isArray(int columnIndex)
      throws java.sql.SQLException     
    {
      int arrayLength;
      try
      {
        arrayLength = m_pool.
                        getTable(m_metaData.getTableName(columnIndex)).
                        getColumn(m_metaData.getColumnName(columnIndex)).
                        getArrayLength();
      }
      catch (SpiceException e)
      {
        throw new java.sql.SQLException("SpiceException:  " + 
                                            e.getMessage());
      }
      
      return (arrayLength > 1) || (arrayLength == -1);
    }
    
    /**
     *  Returns the metadata for this result set.
     */
    public java.sql.ResultSetMetaData getMetaData() 
      throws java.sql.SQLException
    {
      if (m_metaData == null)
      {
        try
        {
          m_metaData = SpiceLib.psel(m_query);
          int numColumns = m_metaData.getColumnCount(); 
          boolean[] isArray = new boolean[numColumns];
          for (int i = 0; i < numColumns; ++i)
          {
            isArray[i] = isArray(i);
          }
          m_metaData.setArray(isArray);
        }
        catch (SpiceException e)
        {
          throw new java.sql.SQLException("SpiceException:  " + 
                                              e.getMessage());
        }
      }
      return m_metaData;
    }
    
    
    /** Advances the cursor to the next record.
     * @return null if there are no more records in this set.
     */
    public boolean next() 
      throws java.sql.SQLException
    {
      ++m_cursor;
      return (m_cursor < m_numRecords);
    }
    
    /** Returns true if the last value read was null
     * @return true if the last value read was null
     */
    public boolean wasNull() 
      throws java.sql.SQLException
    {
      return SpiceLib.wasNull();
    }
    
    /** Returns the value in the current row at the specified column as in int.
     * @param columnIndex The zero-based index of which column entry to return.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException If no such value was found.
     * @return the requested data item
     */
    public int getInt(int columnIndex) 
      throws java.sql.SQLException
    {
      return getInt(columnIndex, 0);
    }

    /** Returns the value in the current row at the specified column as in int.
     * @param columnIndex The zero-based index of which column entry to return.
     * @param arrayElement The zero-based index of which array element to
     *                     return.  Should be zero for a scalar column.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException If no such value was found.
     * @return the requested data item
     */    
    public int getInt(int columnIndex, int arrayElement) 
      throws java.sql.SQLException    
    {
      try
      {
        return SpiceLib.ekgi(columnIndex, m_cursor, arrayElement);
      }
      catch (SpiceException e)
      {
        throw new java.sql.SQLException("SpiceException: " + e.getMessage());
      }
      catch (ResultNotFoundException e)
      {
        throw new java.sql.SQLException("ResultNotFoundException:  " + 
                                            e.getMessage());
      }          
    }
    
    /** Returns the value in the current row at the specified column as a double.
     * @param columnIndex The zero-based index of which column entry to return.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if no such value was found
     * @return the requested data item
     */
    public double getDouble(int columnIndex) 
      throws java.sql.SQLException    
    {
      return getDouble(columnIndex, 0);
    }

    /** Returns the value in the current row at the specified column as a double.
     * @param columnIndex The zero-based index of which column entry to return.
     * @param arrayElement The zero-based index of which array element to
     *                     return.  Should be zero for a scalar column.    
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if no such value was found
     * @return the requested data item
     */    
    public double getDouble(int columnIndex, int arrayElement) 
      throws java.sql.SQLException   
    {
      try
      {
        return SpiceLib.ekgd(columnIndex, m_cursor, arrayElement);   
      }
      catch (SpiceException e)
      {
        throw new java.sql.SQLException(e.getMessage());
      }      
      catch (ResultNotFoundException e)
      {
        throw new java.sql.SQLException("ResultNotFoundException:  " + 
                                            e.getMessage());
      }           
    }

    
    
    
    
    
    
    
    
    
    /** Returns the value in the current row at the specified column as a SPICE Time object.
     * @param columnIndex The zero-based index of which column entry to return.
     * @throws SQLException if there is an error in the SPICE toolkit.
     * @return the requested data item
     */
    public Time getSpiceTime(int columnIndex) 
      throws java.sql.SQLException    
    {
      return new Time(getDouble(columnIndex));
    }

    /** Returns the value in the current row at the specified column as a SPICE Time object.
     * @param columnIndex The zero-based index of which column entry to return.
     * @param arrayElement The zero-based index of which array element to
     *                     return.  Should be zero for a scalar column.    
     * @throws SQLException if an error was detected in the SPICE toolkit
     * @return the requested data item
     */    
    public Time getSpiceTime(int columnIndex, int arrayElement) 
      throws java.sql.SQLException   
    {    
        return new Time(getDouble(columnIndex, arrayElement));
    }
    


    
    /** Returns the value from the specified column.
     * @param columnIndex The zero-based index of which column entry to return.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if no such value was found
     * @return the requested data item
     */    
    public java.lang.String getString(int columnIndex) 
      throws java.sql.SQLException    
    {   
      return getString(columnIndex, 0);
    }

    /** Returns the value from the specified column.
     * @param columnIndex The zero-based index of which column entry to return.
     * @param arrayElement The zero-based index of which array element to
     *                     return.  Should be zero for a scalar column.    
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if no such value was found
     * @return the requested data item
     */    
    public java.lang.String getString(int columnIndex, int arrayElement) 
      throws java.sql.SQLException    
    {         
      try
      {
        return SpiceLib.ekgc_variableLength(columnIndex,
                                                 m_cursor,
                                                 arrayElement);
      }
      catch (SpiceException e)
      {
        throw new java.sql.SQLException(e.getMessage());
      }      
      catch (ResultNotFoundException e)
      {
        throw new java.sql.SQLException("ResultNotFoundException:  " + 
                                            e.getMessage());
      }       
    }    
    
    /** Returns the value from the specified column.
     * @param columnIndex The zero-based index of which column entry to return.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if no such value was found
     * @return the requested data item
     */
    public java.sql.Array getArray(int columnIndex) 
      throws java.sql.SQLException
    {
      return new JdbcArray(this, columnIndex, 
        ((JdbcResultSetMetaData)getMetaData()).getColumnBaseType(columnIndex));
    }

    /**
     *  Creates an array of the contents of a cell.
     *  @param columnIndex the index of the column which contains the cell.
     */
    Object getObjectArray(int columnIndex)
      throws java.sql.SQLException
    {
      int numElements;
      try
      {
        numElements = SpiceLib.eknelt(columnIndex, m_cursor);
      }
      catch (SpiceException e)
      {
        throw new java.sql.SQLException("SpiceException:  " + 
                                           e.getMessage());
      }
      return getObjectArray(columnIndex, 0, numElements);
    }
    
    /**
     *  Creates an array of the contents of a cell.
     *  @param column the index of the column which contains the cell.
     *  @param beginIndex the index of the first array element desired.
     *  @param count the number of elements desired from the array
     */
    Object getObjectArray(int column, int beginIndex, int count)
      throws java.sql.SQLException
    {
      Object[] ret = new Object[count];
      for (int i = beginIndex; i < (beginIndex + count); ++i)
      {
        ret[i] = getObject(column, i);
      }
      return ret;    
    }
    
    /** Returns the value from the specified column.
     * @param columnIndex The zero-based index of which column entry to return.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if no such value was found
     * @return the requested data item
     */
    public java.lang.Object getObject(int columnIndex) 
      throws java.sql.SQLException
    {
      int numElements;
      try
      {
        numElements = SpiceLib.eknelt(columnIndex, m_cursor);
      }
      catch (SpiceException e)
      {
        throw new java.sql.SQLException("SpiceException:  " + 
                                           e.getMessage());
      }      
      // If it's scalar...
      
      if (numElements == 1)  
      {
        return getObject(columnIndex, 0);
      }
      
      // If it's an array....
      
      else
      {
        return getObjectArray(columnIndex, 0, numElements);
      }
    }
    
    /** Returns the value from the specified column.
     * @param columnIndex The zero-based index of which column entry to return.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if no such value was found
     * @return the requested data item
     */
    public java.lang.Object getObject(int columnIndex, int arrayElement) 
      throws java.sql.SQLException
    {      
      int type = ((JdbcResultSetMetaData)getMetaData()).getColumnBaseType(columnIndex); 
      switch (type)
      {
        case java.sql.Types.INTEGER: 
          return new Integer(getInt(columnIndex, arrayElement));
        
        case java.sql.Types.DOUBLE:
          return new Double(getDouble(columnIndex, arrayElement));

        //  A TIME is an ephemeris time in double form.
        //  If possible, we'll convert it to a string.
        //  Otherwise, we'll just show it as a double.
        case java.sql.Types.TIME:
          Time time = new Time(getDouble(columnIndex, arrayElement));
          try
          {
            return time.asString();
          }
          catch (SpiceException e)
          {
            return new Double(time.asDouble());
          }

        
        case java.sql.Types.VARCHAR:
          return getString(columnIndex, arrayElement);
          
        default:
          throw new java.security.InvalidParameterException(
            "ResultSet.getValue:  Unknown column data type " +
            String.valueOf(type));
      }
    }    
    
    
    /**
     * Converts this table to a list of lists of objects.
     * Returns a List of Lists of Objects.  Each list of objects is a
     * column of this result set.
     * Consumes this ResultSet.
     * @param table The specification of the table from which this result set came.
     * @throws SpiceException if an error was detected in the SPICE toolkit
     * @throws ResultNotFoundException if a data item is not found
     * @return a list of lists of column data entries.
     */
    public java.util.List toList()
      throws java.sql.SQLException
    {
      ArrayList ret = new ArrayList();
      for (int i=0; i < getMetaData().getColumnCount(); ++i)
      {
        ret.add(new ArrayList());
      }
      while (this.next())
      {
        for(int index=0; index < getMetaData().getColumnCount(); ++index)
        {
          List l = (List)ret.get(index);
          l.add(getObject(index));
        }
      }
      return ret;
    }
    
    
    
  /**
   * Converts the specified rows of this table to a list of lists of objects.
   * Returns a List of Lists of Objects.  Each list of objects is a
   * column of this result set.
   * Consumes this ResultSet.
   * @param table The specification of the table from which this result set came.
   * @param beginRow The index of the first row to include in the list.
   *                  This should be between 0 and the number of rows - 1,
   *                  inclusive.
   *                  If beginRow < 0, it is treated as 0.
   *                  If beginRow > number of rows - 1, 
   *                   a list of zero-length lists will be returned.
   * @param numRows The maximum number of rows to return.  If there
   *                 are not enough rows in the table to return this number,
   *                 then as many rows as possible will be returned.
   * @throws SpiceException if an error was detected in the SPICE toolkit
   * @throws ResultNotFoundException if a data item is not found
   * @return a list of lists of column data entries.
   */
  public java.util.List toList(int beginRow, int numRows)
    throws java.sql.SQLException
  {
    ArrayList ret = new ArrayList();
    for (int i=0; i < getMetaData().getColumnCount(); ++i)
    {
      ret.add(new ArrayList());
    }
    
    // Advance past the rows in which we're not interested.
    
    for (int i = 0; i < beginRow && this.next(); ++i)
    {
    }
    
    // Copy the rows in which we are interested.
    
    for (int i = 0; i < numRows && this.next(); ++i)
    {
      for (int columnIndex=0; 
           columnIndex < getMetaData().getColumnCount(); 
          ++columnIndex)
      {
        List l = (List)ret.get(columnIndex);
        l.add(getObject(columnIndex));
      }
    }
    
    // Consume the remaining rows, as per the specification.
    
    while (this.next())
    {
    }
    
    return ret;
  }    
  public java.sql.Ref getRef(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Date getDate(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public int getFetchSize() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public byte getByte(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.math.BigDecimal getBigDecimal(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public short getShort(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateObject(int p1,final java.lang.Object p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Date getDate(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBigDecimal(java.lang.String p1,final java.math.BigDecimal p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Time getTime(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.math.BigDecimal getBigDecimal(int p1,int p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public double getDouble(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateObject(java.lang.String p1,final java.lang.Object p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean first() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Timestamp getTimestamp(int p1,final java.util.Calendar p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.InputStream getAsciiStream(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.InputStream getBinaryStream(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Statement getStatement() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public float getFloat(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.Reader getCharacterStream(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public int getInt(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateFloat(int p1,float p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBinaryStream(int p1,final java.io.InputStream p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBinaryStream(int p1,final java.io.InputStream p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBinaryStream(int p1,final java.io.InputStream p2,long p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBinaryStream(java.lang.String p1,final java.io.InputStream p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBinaryStream(java.lang.String p1,final java.io.InputStream p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBinaryStream(java.lang.String p1,final java.io.InputStream p2,long p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void clearWarnings() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.Reader getCharacterStream(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean isFirst() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateShort(int p1,short p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBigDecimal(int p1,final java.math.BigDecimal p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void cancelRowUpdates() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public int findColumn(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Time getTime(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.InputStream getUnicodeStream(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.lang.String getString(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public byte[] getBytes(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void beforeFirst() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateString(int p1,java.lang.String p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateByte(java.lang.String p1,byte p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.lang.String getCursorName() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean rowDeleted() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public int getFetchDirection() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateInt(int p1,int p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public long getLong(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBoolean(java.lang.String p1,boolean p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateTime(java.lang.String p1,final java.sql.Time p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean getBoolean(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void afterLast() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Date getDate(int p1,final java.util.Calendar p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean last() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public int getType() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Array getArray(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void close() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public int getRow() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void deleteRow() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateLong(int p1,long p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateInt(java.lang.String p1,int p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public long getLong(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBytes(int p1,byte[] p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Timestamp getTimestamp(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Ref getRef(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Timestamp getTimestamp(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.math.BigDecimal getBigDecimal(java.lang.String p1,int p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateDouble(java.lang.String p1,double p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean rowUpdated() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Blob getBlob(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean getBoolean(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateObject(java.lang.String p1,final java.lang.Object p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.SQLWarning getWarnings() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean relative(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public byte[] getBytes(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.math.BigDecimal getBigDecimal(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateObject(int p1,final java.lang.Object p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNull(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateTimestamp(int p1,final java.sql.Timestamp p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void setFetchSize(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateDate(int p1,final java.sql.Date p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Clob getClob(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNull(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Clob getClob(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.lang.Object getObject(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateAsciiStream(int p1,final java.io.InputStream p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateAsciiStream(int p1,final java.io.InputStream p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateAsciiStream(int p1,final java.io.InputStream p2,long p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateAsciiStream(java.lang.String p1,final java.io.InputStream p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateAsciiStream(java.lang.String p1,final java.io.InputStream p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateAsciiStream(java.lang.String p1,final java.io.InputStream p2,long p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean isLast() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public float getFloat(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean isBeforeFirst() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateLong(java.lang.String p1,long p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBoolean(int p1,boolean p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Date getDate(java.lang.String p1,final java.util.Calendar p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public int getConcurrency() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Time getTime(int p1,final java.util.Calendar p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBytes(java.lang.String p1,byte[] p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Blob getBlob(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateShort(java.lang.String p1,short p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.InputStream getAsciiStream(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void setFetchDirection(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void moveToCurrentRow() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateTime(int p1,final java.sql.Time p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateCharacterStream(int p1,final java.io.Reader p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateCharacterStream(int p1,final java.io.Reader p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateCharacterStream(int p1,final java.io.Reader p2,long p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateCharacterStream(java.lang.String p1,final java.io.Reader p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateCharacterStream(java.lang.String p1,final java.io.Reader p2,int p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateCharacterStream(java.lang.String p1,final java.io.Reader p2,long p3) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.InputStream getUnicodeStream(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateRow() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public byte getByte(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateString(java.lang.String p1,java.lang.String p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean rowInserted() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateFloat(java.lang.String p1,float p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void insertRow() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.io.InputStream getBinaryStream(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateDouble(int p1,double p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void moveToInsertRow() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Timestamp getTimestamp(java.lang.String p1,final java.util.Calendar p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public short getShort(java.lang.String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.sql.Time getTime(java.lang.String p1,final java.util.Calendar p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean absolute(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateDate(java.lang.String p1,final java.sql.Date p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean previous() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void refreshRow() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateTimestamp(java.lang.String p1,final java.sql.Timestamp p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateByte(int p1,byte p2) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public boolean isAfterLast() throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public java.net.URL getURL(int p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }  
  public java.net.URL getURL(String p1) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateArray(int columnIndex, java.sql.Array x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateArray(String columnName, java.sql.Array x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBlob(int columnIndex, java.sql.Blob x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBlob(int columnIndex, java.io.InputStream inputStream) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBlob(int columnIndex, java.io.InputStream inputStream, long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBlob(String columnName, java.sql.Blob x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBlob(String columnName, java.io.InputStream inputStream) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateBlob(String columnName, java.io.InputStream inputStream, long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateClob(int columnIndex, java.sql.Clob x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateClob(String columnName, java.sql.Clob x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateClob(int columnIndex, java.io.Reader reader) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateClob(int columnIndex, java.io.Reader reader, long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateClob(String columnName, java.io.Reader reader) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateClob(String columnName, java.io.Reader reader, long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateRef(int columnIndex, java.sql.Ref x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateRef(String columnName, java.sql.Ref x) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNClob(int columnIndex, java.sql.NClob nclob) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNClob(int columnIndex, java.io.Reader reader) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNClob(int columnIndex, java.io.Reader reader,long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNClob(String columnLabel, java.sql.NClob nclob) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNClob(String columnLabel, java.io.Reader reader) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNClob(String columnLabel, java.io.Reader reader, long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNCharacterStream(int columnIndex, java.io.Reader reader) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNCharacterStream(int columnIndex, java.io.Reader reader,long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNCharacterStream(String columnLabel, java.io.Reader reader) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }
  public void updateNCharacterStream(String columnLabel, java.io.Reader reader, long length) throws java.sql.SQLException {
    throw new java.sql.SQLFeatureNotSupportedException();
  }

	@Override
	public int getHoldability() throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public Reader getNCharacterStream(int arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public Reader getNCharacterStream(String arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public NClob getNClob(int arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public NClob getNClob(String arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public String getNString(int arg0) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}
	
	@Override
	public String getNString(String arg0) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}
	
	@Override
	public Object getObject(int arg0, Map<String, Class<?>> arg1)
			throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public Object getObject(String arg0, Map<String, Class<?>> arg1)
			throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public RowId getRowId(int arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public RowId getRowId(String arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public SQLXML getSQLXML(int arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public SQLXML getSQLXML(String arg0) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public boolean isClosed() throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public void updateNString(int arg0, String arg1) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
		
	}
	
	@Override
	public void updateNString(String arg0, String arg1) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
		
	}
	
	@Override
	public void updateRowId(int arg0, RowId arg1) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
		
	}
	
	@Override
	public void updateRowId(String arg0, RowId arg1) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
		
	}
	
	@Override
	public void updateSQLXML(int arg0, SQLXML arg1) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public void updateSQLXML(String arg0, SQLXML arg1) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
		
	}
	
	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}
	
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		throw new java.sql.SQLFeatureNotSupportedException();
	}


    public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
        throw new java.sql.SQLFeatureNotSupportedException();
    }

    public <T> T getObject(String columnLabel, Class<T> type)
            throws SQLException {
        throw new java.sql.SQLFeatureNotSupportedException();
    }
  
}
