/*****************************************************************************
 * Copyright (C) 2006, Jon Meyer, Ben Bederson and Jean-Daniel Fekete        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the BSD Software License    *
 * a copy of which has been included with this distribution in the           *
 * license-agile2d.txt file.                                                 *
 *****************************************************************************/
package jpl.mipl.jade.jadis.agile2d;


import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.color.ColorSpace;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferInt;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.util.Hashtable;

import javax.media.opengl.GL;

import jpl.mipl.jade.jadis.agile2d.AgileState;
import jpl.mipl.jade.jadis.agile2d.ImageUtils;
/**
 * Instances of Texture correspond to an OpenGL Texture image.
 */
final class Texture {
    private GL  gl; // Context the texture belongs to
    private AgileState glState;
    private int     id; // ID generated by glGenTextures
    private int     pixelFormat; // Layout of pixel data
    private int     internalFormat; // Representation of data in texture memory
    private int     textureWidth; // Width of the texture
    private int     textureHeight; // Height of the texture
    private int     numComponents; // Number of components for each pixel
    private boolean updateNeeded; // Set true if Java-side pixels have changed
    private byte[]  bytePixels; // For Byte-organized pixels
    private int[]   intPixels; // For Int-organized pixels
    private float   s2 = 1; // Painted portion of texture
    private float   t2 = 1; // Painted portion of texture
    private boolean smooth = true;

    Texture(GL gl) {
        this.gl = gl;
        pixelFormat = GL.GL_RGBA;
        internalFormat = 4;
        numComponents = 4;
        textureWidth = 256;
        glState = AgileState.get(gl);
    }


    Texture(GL gl, int components, int size, boolean smooth) {
        this(gl, components, size, size, smooth);
    }
    
    Texture(GL gl, int components, int width, int height, boolean smooth) {
        this.gl = gl;
        this.smooth = smooth;
        textureWidth = ImageUtils.nextPowerOf2(width);
        textureHeight = ImageUtils.nextPowerOf2(height);
        internalFormat = components;
        numComponents = components;
        glState = AgileState.get(gl);
        
        switch (numComponents) {
        case 1:
            pixelFormat = GL.GL_ALPHA;
            internalFormat = GL.GL_ALPHA;
            break;
        case 2:
            pixelFormat = GL.GL_LUMINANCE_ALPHA;
            break;
        case 3:
            pixelFormat = GL.GL_RGB;
            break;
        case 4:
            pixelFormat = GL.GL_RGBA;
            break;
        }
    }
    
    Texture(GL gl, int components, int size) {
        this(gl, components, size, true);
    }


	static ColorModel glAlphaColorModel, glColorModel;
	
	static {
		glAlphaColorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB),
			new int[] {8,8,8,8},
			true,
			false,
			ComponentColorModel.TRANSLUCENT,
			DataBuffer.TYPE_BYTE);
                                            
		glColorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB),
			new int[] {8,8,8,0},
			false,
			false,
			ComponentColorModel.OPAQUE,
			DataBuffer.TYPE_BYTE);
	}

	// From http://wiki.java.net/bin/view/Games/TextureLoadingExample
	//
	static private ByteBuffer convertImageData(BufferedImage bufferedImage, int texWidth, int texHeight) throws java.io.IOException { 
		ByteBuffer imageBuffer = null; 
		WritableRaster raster;
		BufferedImage texImage;
        
		if (bufferedImage.getColorModel().hasAlpha()) {
			raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, texWidth, texHeight, 4, null);
			texImage = new BufferedImage(glAlphaColorModel, raster, false, new Hashtable());
		} else {
			raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE, texWidth, texHeight, 3, null);
			texImage = new BufferedImage(glColorModel, raster, false, new Hashtable());
		}
        
		Graphics g = texImage.getGraphics();
		g.drawImage(bufferedImage, 0, 0, null);
        g.dispose();

		byte[] data = ((DataBufferByte) texImage.getRaster().getDataBuffer()).getData(); 

		imageBuffer = ByteBuffer.allocateDirect(data.length); 
		imageBuffer.order(ByteOrder.nativeOrder()); 
		imageBuffer.put(data, 0, data.length); 

		return imageBuffer; 
	} 

		
	public boolean isNormalized() {
        return (s2 == 1) && (t2 == 1); 
    }

    public Object getPixels() {
        return (bytePixels != null) ? (Object)bytePixels : (Object)intPixels;
    }

    public void setPixels(byte[] bytePixels) {
        // Ensures that the array is long enough
        if (bytePixels.length != textureWidth * textureHeight * numComponents) {
            throw new IllegalArgumentException("Too few pixels in array");
        }
        this.bytePixels = bytePixels;
        this.intPixels = null;
        updateNeeded = true;
    }

    public void setPixels(int[] intPixels) {
        if (intPixels.length != textureWidth * textureHeight) {
            throw new IllegalArgumentException("Too few pixels in array");
        }
        if (pixelFormat != GL.GL_RGBA|| numComponents != 4) { // for Ints this must be GL.GL_RGBA
            throw new IllegalArgumentException("Cannot use int-typed pixels with this texture");
        }
        this.intPixels = intPixels;
        this.bytePixels = null;
        updateNeeded = true;
    }

    /**
     * Sets the pixels in the texture to the contents of the buffered image.
     * Note that the buffered image must be in TYPE_INT_ARGB format. The
     * image must be the same size or larger than the texture size. (Pixels
     * outside texture are ignored). The paintRect parameter lets you
     * specify  a portion of the image for use by the paint() method. NB.
     * After calling this method, the contents of the pixels in the buffered
     * image are undefined. This method converts the pixels image in the
     * buffered  image into a format suitable for GL, and then copies the
     * pixels into texture memory.
     *
     * @param image DOCUMENT ME!
     * @param paintRect DOCUMENT ME!
     *
     * @throws IllegalArgumentException DOCUMENT ME!
     */
    void loadPixels(BufferedImage image, Rectangle paintRect) {
        if (image.getType() != BufferedImage.TYPE_INT_ARGB &&
            image.getType() != BufferedImage.TYPE_INT_RGB) {
            throw new IllegalArgumentException("setPixels: Expected TYPE_INT_[A]RGB Image, got: " +
                                               image);
        }

        if (pixelFormat != GL.GL_RGBA|| numComponents != 4) {
            throw new IllegalArgumentException("setPixels: Cannot use BufferedImage to set this texture");
        }

        // Modify paintRect so that it is entirely within the image.
        if (paintRect.x < 0) {
            paintRect.width += paintRect.x;
            paintRect.x = 0;
        }
        if (paintRect.y < 0) {
            paintRect.height += paintRect.y;
            paintRect.y = 0;
        }
        if (paintRect.width > textureWidth) {
            paintRect.width = textureWidth;
        }
        if (paintRect.height > textureHeight) {
            paintRect.height = textureHeight;
        }
        if (paintRect.width < 0) {
            throw new IllegalArgumentException("setPixels: paintRect has negative width");
        }
        if (paintRect.height < 0) {
            throw new IllegalArgumentException("setPixels: paintRect has negative height");
        }

        int[] data = ((DataBufferInt)(image.getRaster().getDataBuffer())).getData();
        IntBuffer buffer = IntBuffer.wrap(data);

        // Compute the region of the texture to use
        float sscale = 1.0f / textureWidth;
        s2 = paintRect.width * sscale;
        float tscale = 1.0f / textureHeight;
        t2 = paintRect.height * tscale;

        // We grab the pixel data now and then release it
//        bytePixels = null;
//        intPixels = data;
//        updateNeeded = true;
        create();
        bind();
        gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT, 4);
        gl.glPixelStorei(GL.GL_UNPACK_ROW_LENGTH, image.getWidth());
        if (paintRect.x != 0)
            gl.glPixelStorei(GL.GL_UNPACK_SKIP_PIXELS, paintRect.x);
        if (paintRect.y != 0)
            gl.glPixelStorei(GL.GL_UNPACK_SKIP_ROWS, paintRect.y);

        if (image.getType() == BufferedImage.TYPE_INT_ARGB) {
//            ImageUtils.convertARGBtoRGBA(data, image.getWidth(),
//                                         paintRect.x, paintRect.y,
//                                         paintRect.width, paintRect.height,
//                                         data, image.getWidth());

            gl.glTexSubImage2D(GL.GL_TEXTURE_2D, 0, 0, 0,
                               paintRect.width, paintRect.height, GL.GL_BGRA,
                               GL.GL_UNSIGNED_BYTE, buffer);
        }
        else { // TYPE_INT_RGB
            gl.glPixelTransferf(GL.GL_ALPHA_BIAS, 1.0f);
            gl.glTexSubImage2D(GL.GL_TEXTURE_2D, 0, 0, 0,
                               paintRect.width, paintRect.height, GL.GL_BGRA,
                               GL.GL_UNSIGNED_BYTE, buffer);
            gl.glPixelTransferf(GL.GL_ALPHA_BIAS, 0);                               
        }
        gl.glPixelStorei(GL.GL_UNPACK_ROW_LENGTH, 0);
        if (paintRect.x != 0)
            gl.glPixelStorei(GL.GL_UNPACK_SKIP_PIXELS, 0);
        if (paintRect.y != 0)
            gl.glPixelStorei(GL.GL_UNPACK_SKIP_ROWS, 0);
        glState.bindTexture2D(0); // force rebind of texture
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public int getNumComponents() {
        return numComponents;
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public int getFormat() {
        return pixelFormat;
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public int getInternalFormat() {
        return internalFormat;
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public int getWidth() {
        return textureWidth;
    }
    
    public int getHeight() {
        return textureHeight;
    }

    public synchronized void update() {
        if (!updateNeeded) {
            return;
        }
        create();
        bind();
        int width = (int)(s2*textureWidth);
        int height = (int)(t2*textureHeight);
        gl.glPixelStorei(GL.GL_UNPACK_ROW_LENGTH, textureWidth);
        if (pixelFormat == GL.GL_RGBA) {
            gl.glPixelStorei(GL.GL_UNPACK_SWAP_BYTES, 1);
            gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT, 4);
        }
        else {
            gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT, 1);
        }

        if (bytePixels != null) {
            ByteBuffer buffer = ByteBuffer.wrap(bytePixels);
            gl.glTexSubImage2D(GL.GL_TEXTURE_2D, 0, 0, 0,
                               width, height, pixelFormat,
                               GL.GL_UNSIGNED_BYTE, buffer);
        } else if (intPixels != null) {
            IntBuffer buffer = IntBuffer.wrap(intPixels);
            gl.glTexSubImage2D(GL.GL_TEXTURE_2D, 0, 0, 0,
                               width, height, pixelFormat,
                               GL.GL_UNSIGNED_BYTE, buffer);
        }
        if (pixelFormat == GL.GL_RGBA) {
            gl.glPixelStorei(GL.GL_UNPACK_SWAP_BYTES, 0);
        }
        else {
            gl.glPixelStorei(GL.GL_UNPACK_ROW_LENGTH, 0);
        }
        updateNeeded = false;
    }

    private void create() {
        if (id != 0)
            return;
        int[] idRef = new int[1];
        gl.glGenTextures(1, idRef, 0);
        id = idRef[0];

        glState.bindTexture2D(id);
        gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, internalFormat, textureWidth,
                        textureHeight, 0, pixelFormat, GL.GL_UNSIGNED_BYTE,
                        null);

        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP);
        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP);
        if (smooth) {
            gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
            gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);
        }
        else {
            gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_NEAREST);
            gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_NEAREST);
        }                        
    }

    private void bind() {
        glState.bindTexture2D(id);
    }

    private static final class DeleteEntry {
        GL gl;
        int    id;

        DeleteEntry(GL gl, int id) {
            this.gl = gl;
            this.id = id;
        }
    }

    void enable() {
        glState.glEnable(GL.GL_TEXTURE_2D);
        create(); // Creates texture object if needed
        update(); // Updates pixels if they have been changed
        bind(); // Ensures texture is bound to GL.GL_TEXTURE_2D target
    }

    void disable() {
        glState.glDisable(GL.GL_TEXTURE_2D);
    }

    /**
     * DOCUMENT ME!
     *
     * @param x1 DOCUMENT ME!
     * @param y1 DOCUMENT ME!
     * @param w DOCUMENT ME!
     * @param h DOCUMENT ME!
     */
    public synchronized void paint(double x1, double y1, double x2, double y2) {
        enable();
        if (glState.setState(GL.GL_TEXTURE_ENV_MODE, GL.GL_MODULATE)) {
            gl.glTexEnvf(GL.GL_TEXTURE_ENV, GL.GL_TEXTURE_ENV_MODE, GL.GL_MODULATE);
        }
        if (pixelFormat == GL.GL_RGBA || pixelFormat == GL.GL_LUMINANCE_ALPHA) {
            glState.glEnable(GL.GL_BLEND);
        }

        gl.glBegin(GL.GL_QUADS);
        gl.glTexCoord2f(0, 0);
        gl.glVertex2d(x1, y1);
        gl.glTexCoord2f(0, t2);
        gl.glVertex2d(x1, y2);
        gl.glTexCoord2f(s2, t2);
        gl.glVertex2d(x2, y2);
        gl.glTexCoord2f(s2, 0);
        gl.glVertex2d(x2, y1);
        gl.glEnd();

        disable();
    }
    
    double[] xequal= new double[4];
    double[] yequal= new double[4];
    
    void begin(Rectangle2D anchorRect) {
        enable();

        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT);
        gl.glTexParameterf(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT);
        xequal[0] = 1/anchorRect.getWidth();
        xequal[1] = 0; 
        xequal[2] = 0; 
        xequal[3] = -anchorRect.getX() / anchorRect.getWidth();
        gl.glTexGeni(GL.GL_S, GL.GL_TEXTURE_GEN_MODE, GL.GL_OBJECT_LINEAR);
        gl.glTexGendv(GL.GL_S, GL.GL_OBJECT_PLANE, xequal, 0);
        glState.glEnable(GL.GL_TEXTURE_GEN_S);
        
        yequal[0] = 0; 
        yequal[1] = 1/anchorRect.getHeight();
        yequal[2] = 0; 
        yequal[3] = -anchorRect.getY() / anchorRect.getHeight();
        gl.glTexGeni(GL.GL_T, GL.GL_TEXTURE_GEN_MODE, GL.GL_OBJECT_LINEAR);
        gl.glTexGendv(GL.GL_T, GL.GL_OBJECT_PLANE, yequal, 0);
        glState.glEnable(GL.GL_TEXTURE_GEN_T);
        if (pixelFormat == GL.GL_RGBA || pixelFormat == GL.GL_LUMINANCE_ALPHA) {
            glState.glEnable(GL.GL_BLEND);
        }

    }
    
    void end(){
        glState.glDisable(GL.GL_TEXTURE_GEN_S);
        glState.glDisable(GL.GL_TEXTURE_GEN_T);
        disable();
    }

    /**
     * Calling this releases any GL texture memory used by this object. Note
     * that this must be called in a valid painting context.
     */
    public synchronized void dispose() {
        if (id != 0) {
            glState.bindTexture2D(0);
            gl.glDeleteTextures(1, new int[] { id }, 0);
            id = 0;
            updateNeeded = false;
        }
    }
}
