/****************************************************************************
 *      Copyright (c) 1993, 1994
 *      Century Computing, Inc.
 *      ALL RIGHTS RESERVED
 *
 *      The software (programs, data bases and/or documentation) on or in
 *      any media can not be reproduced, disclosed, or used except under
 *      the terms of the TAE Plus Software License Agreement.
 *
 ***************************************************************************/



/* >>UNIX<<	*/
/*
 *	CHANGE LOG:
 *
 *	05-dec-83	Change file spec to lower case before open,
 *			fix for blowing up at file close time...dm
 *			Also substitute for $name before file open...dm
 *	16-dec-83	Rename function subst to f_subst and move to
 *			a separate source module. Fix bug in f_type...dm
 *	16-jan-84	Change chkopen bit check to sentinel ckeck...dm
 *	19-jan-84	Check for file open before any i/o operation...dm
 *	23-jan-84	Don't terminate copy_alpha on '$'...dm
 *	11-apr-84	Declare size as COUNT for 68000 conversion error...dm
 *	18-may-84	Check for fileopen in f_setpos function too...dm
 *	19-jun-85	Update for TAE-V1.3 implementation (includes new
 *			calling sequences, new routines for Catalog manager
 *			development, etc.)...dm
 *	25-jul-85	Implement F_UPDATE file open mode...dm
 *	07-aug-85	Implement file deletion (unlink) with F_DELETE 
 *			option at file close time...dm
 *	12-sep-85	Pretect against non-text files in f_read()...dm
 *	4-dec-86	Don't append file type for /dev files...palm
 *	12-dec-86	Fix lint warnings...peb
 *	05-jan-87	Check pointer after getwd() call...peb
 *	19-jan-87	PR1181: new f_force_lower entry...palm
 *	17-mar-88	PR1499: add isTerm entry (dummy module for UNIX)...ljn
 *	05-may-88	isTerm() -> f_isterm()...ljn
 *	23-jun-88	Include chartype.inc...tp
 *	08-nov-88	System V has getcwd() instead of getwd()...ljn
 *	29-nov-88	Deleted errno checking in f_write (SYSV problem)...ljn
 *	13-feb-89	Allow "+" and "-" as valid file character...palm
 *	13-jul-89	Some platforms complain about redeclare of fgetc...ljn
 *	19-jan-90	HP complains about re-decl of fgetc()...ljn
 *	25-sep-90	Added f_exists()...ljn
 *	07-feb-90	Only declare fgetc() if sun...ljn
 *	11-mar-91	Force_lower defaults to false for UNIX...ljn
 *	27-feb-92	Removed decl of fgetc()...ljn
 *	14-aug-92	PR1528: Except in VMS, allow spaces in fileSpecs in
 *			f_parse...crb
 * 	11-sep-92 PR875 Added f_readstring, a f_read that has size arg...tpl
 */


#include	"taeconf.inp"
#include	"fileinc.inp"
#include	"chartype.inc"
#include "taeintproto.h"
#include <unistd.h>
#ifdef macII
#define SYSV
#endif

#if defined(__linux) || defined(linux) || defined(__APPLE__) /* for strerror */
#include <string.h>
#endif


#ifndef testmain




static  BOOL  Force_lower = FALSE; 


#define    ERR_OPEN	-2	/* error in file open		*/
#define	   ERR_READ	-3	/* error during file read	*/
#define	   ERR_SIZE	-4	/* error in user buffer size	*/
#define	   ERR_FILE	-5	/* not an opened file		*/
#define    ERR_SECTOR	-6	/* bad start sector for block I/O */
#define	   SENTINEL	0xadbc1423   /* sentinel for opened file */

FUNCTION CODE f_bwrite(
     struct SFILE	*f,		/* in/out: SFILE for the file	*/
     GENPTR		buffer,		/* in: record to be written	*/
     COUNT		size);		/* in: size of buffer in bytes  */

FUNCTION CODE f_ophf(
     struct SFILE 	*f,		/* out: file context block	*/
     FUNINT 		lun,		/* in: lun to use for file	*/
     TEXT		fspec[],	/* in: host file name		*/
     FUNINT 		access);		/* in: F_READ, F_WRITE,F_EXTEND	*/

FUNCTION CODE f_parse(
     TEXT	spec[],			/* in: file specfication	*/
     TEXT	libr[FLIBRSIZ+1],	/* out: library component	*/
     TEXT	name[FNAMESIZ+1],	/* out: name component		*/
     TEXT	type[FTYPESIZ+1],	/* out: type component		*/
     TEXT	attr[FATTRSIZ+1],	/* out: version string		*/
     TEXT	errstr[STRINGSIZ+1]);	/* out: 'at or near' string if	*/

FUNCTION CODE f_readstring(
     struct SFILE 	*f,		/* in/out: SFILE for an opened file  */
     COUNT	        maxsiz,	/* in: max string siz */
     TEXT   		string[]);	/* out: record with EOS terminator   */

FUNCTION static VOID err_txt
(
 struct SFILE 	*f		/* in/out: SFILE for an opened file */
);
FUNCTION  static  BOOL fileopen
(
 struct  SFILE  *f
);
FUNCTION COUNT f_spec
(
 struct FSBLOCK	*fsblock,		/* in: file spec block	*/
 TEXT		fspec[FSPECSIZ+1]	/* out: VMS file spec	*/
 );

/*
 *	UNIX-dependent TAE File Package for C callers.
 * 
 *	The maximum record size for text records is STRINGSIZ.
 *
 *	For each open file, a SFILE structure exists.  The structure
 *	is allocated by the caller and built by f_open.
 *
 *	The lun argument to f_open is not used here.  The argument exists
 * 	for systems like RSX where a lun is required in order to access
 *	a file.
 *
 *	Whenever a host-independent error code is received, the caller
 *	may access a description of the error  either generated by the
 *	host system, or internally by the file package (in the absence of
 *	a corresponding host-dependent message) in the 	errmsg field of
 *	the SFILE structure.
 *
 * 	The posctx field of SFILE has positioning context of the
 *	current record.  posctx also contains a flag indicating whether
 *	the position is currently defined.  posctx may be moved around
 *	with the f_movpos function;  this function is required because the user
 *	does not know the "real" type of the field and cannot move it directly.
 *

 *
 * NOTE:
 *	Since a file, under UNIX operating system, consists of only a linear
 *	array of data bytes but no physical records, we simulate a record
 *	in the "file" package in the following way:
 *
 *	A newline ("n/l") character is used as the terminator of a text
 *	record. The user specified text data (terminated by an EOS) is
 *	appended by a "n/l" character when written to the file. At file
 *	read time, data is read upto the "n/l" character or maximum buffer
 *	size, whichever occurs first. In the later case, however, the file
 *	is positioned past the "n/l" character, such that the next read
 *	starts with the next record.
 *
 *	When binary data is written to the disk, the user supplied data is
 *	pre-fixed with two bytes of information indicating the number of
 *	bytes being written. When a binary read is performed, these first
 *	two bytes are accessed first to derive the length of the record.
 *	If user supplied buffer is smaller than the record length, the
 *	excess data is discarded, and the file is positioned at the
 *	beginning of the next record.
 *
 *	Note that under this scheme, any ASCII data written as text
 * 	records to a file can not be read back in binary format.
 *
 **************************************************************************
 */

/*
 *	copy_alpha.  Bounded copy.   Terminate on any non-alphanumeric.
 */

FUNCTION static COUNT copy_alpha
(
 TEXT	instr[],		/* in: string		*/
 TEXT	outstr[],		/* out: string		*/
 FUNINT	maxsiz			/* in: max size 	*/
 )
    {
    COUNT	i;

    for (i=0; i < maxsiz; i++)
	{
	if ((!isalpha(instr[i])  &&  !isdigit(instr[i]))
		&& instr[i] != '$')		/* if '$' okay	*/
	    break;
	outstr[i] = instr[i];
	}
    outstr[i] = EOS;
    return (i);
    }

/* 	chk_error. Check the error code and put message in SFILE.
 *
 *	If a UNIX error code and error text exist for the error condition, then
 * 	they are returned in the host_code and errmsg field of the SFILE.
 *	Otherwise, an internal code and message are returned in SFILE.
 *
 *
 *	Return codes:
 *	
 *		A F_XXX code to be  returned to the user.
 */

FUNCTION  CODE  chk_error
(
 struct  SFILE	*f,		/* in: pointer to SFILE		*/
 CODE		err_type	/* in: type of error 		*/
 )

    {
    CODE		ret_code = 0;	/* return code for user		*/

    if (err_type == ERR_OPEN)		/* error in file open		*/
	{
	err_txt(f);			/* get system err num, err msg	*/
	ret_code = ((*f).host_code == ENOENT) ?
	    F_NOFILE : F_FILERR;	/* not a file or error		*/
	}
    else if (err_type == ERR_READ)	/* file read related		*/
	{
	if (errno == 0)			/* not really any error		*/
	    {
	    ret_code = (*f).host_code = F_EOF;		/* end of file	*/
	    s_copy ("End of file. ", (*f).errmsg);
	    }
	else
	    {
	    ret_code = F_FILERR;
	    err_txt(f);			/* get UNIX error		*/
	    }
	}
    else if (err_type == ERR_SIZE)	/* error in buffer size		*/
	{
	ret_code = (*f).host_code = F_BTOOSMALL;	/* buffer too small */
	s_copy("Buffer size too small", (*f).errmsg);
	}
    else if (err_type == ERR_FILE)	/* not an open file		*/
	{
	ret_code = (*f).host_code = F_FILERR;
	s_copy("File not open", (*f).errmsg);
	}
    else if (err_type == ERR_SECTOR)	/* invalid start sector number   */
	{
	ret_code = (*f).host_code = F_FILERR;
	s_copy("Invalid sector number", (*f).errmsg);
	}
    return (ret_code);
    }

/*
 *	err_txt. Generate a UNIX error message and place in SFILE.
 *
 *	Return codes:
 *
 *		NONE
 *
 */

FUNCTION static VOID err_txt
(
 struct SFILE 	*f		/* in/out: SFILE for an opened file */
)
    {
#if !(defined(linux) || defined(__linux) || defined(__APPLE__)) /* sys_nerr gone */
    IMPORT	int	sys_nerr;	/* highest UNIX error number    */
    IMPORT	char	*sys_errlist[];	/* system error messages	*/
#endif


    (*f).errmsg[0] = EOS;		/* clean up previous msg	 */
    (*f).host_code = errno;		/* get system saved error number */
#if defined(linux) || defined(__linux) || defined(__APPLE__)
    s_copy(strerror(errno), (*f).errmsg);
#else
    if ((0 < errno) && (errno <= sys_nerr))	/* error and msg exists	 */
	s_copy (sys_errlist[errno], (*f).errmsg);
#endif
    return;
    }

/*
 *	f_isterm. Is this a terminal device?
 *
 *	So far, there is not the need for this on UNIX that there
 *	is on VMS. UNIX, unlike VMS, completely parses such constructions
 *	as '/dev/ttyp0/.pdf' whereas VMS only incompletely parses
 *	'sys$command:.pdf'. (VMS thinks you want sys$command.)
 *	If a user accidently enters such a file spec, UNIX does not
 *	think you want a terminal device as does VMS. See PR 1499.
 *
 *	TBD TBD TBD - Flesh this routine out. Not clear
 *	how STAT(2) or some other function can best use SFILE struct
 *	to get this info.
 *
 *	Return codes: FALSE.
 *
 */

FUNCTION BOOL f_isterm
(
 struct SFILE    *file
)

    {
    return (FALSE);
    }

/*
 *	f_attr.  Get attributes from a file spec.
 *	For UNIX this means return a NULL string.
 */
FUNCTION CODE f_attr
(
 TEXT	fspec[],		/* in: host file spec		*/
 TEXT	attr[]			/* out: attribute field		*/
 )

    {
    attr[0] = EOS;			/* no real attribute exits	*/
    return (SUCCESS);
    }

/*
 *	f_bread.  Read binary record.
 *
 *	Return codes:
 *
 *		SUCCESS
 *		F_EOF    - end of file
 *		F_BTOOSMALL - User buffer smaller than record size
 *		F_FILERR - error
 *
 *	NOTE:
 *	     -  The record length is determined from the first two bytes
 *	        of data.
 *	     -	The F_XXX error codes are received from chk_error().
 */

FUNCTION CODE f_bread
(
 struct SFILE 	*f,		/* in/out: SFILE for an opened file */
 GENPTR		buffer,		/* out: record read from file	    */
 FUNINT		bufsize,	/* in: size of user buffer 	    */
 COUNT		*recsize	/* out: Number of data bytes read   */
 )
    {
    COUNT		bytenum;
    COUNT		bytes;		/* number of bytes read		  */
    BOOL		truncate;	/* TRUE if input record truncated */

    if (!fileopen(f))
	return (chk_error(f, ERR_FILE));	/* not an opened file	  */

    errno = 0;				/* clean up previous I/O error	  */
    (*f).posctx.pos = ftell((*f).fileptr);	/* save current pos-ctx   */
    (*f).posctx.possav = TRUE;			/* mark as saved    	  */
    bytes = fread((GENPTR) &bytenum, sizeof(COUNT),
		1, (*f).fileptr);		/* first word=count  */
    if (bytes == 0)				/* no data read 	  */
	return (chk_error(f, ERR_READ));        /* check and return error */

    truncate = (bytenum > bufsize);	        /* record longer than buffer */
    bytes = (truncate) ? bufsize : bytenum;	/* actual bytes to read   */
    *recsize = fread(buffer, sizeof(char), bytes, (*f).fileptr);	
    if (*recsize != bytes)
	return (chk_error(f, ERR_READ));	/* check and return error */

    (*f).posctx.line_num += 1;				/* new record number */
    if (truncate)					/* truncated record  */
	{
	fseek((*f).fileptr, (long)(bytenum-bufsize), 1);   	/* position at next rec  */
 	return (chk_error(f, ERR_SIZE));		/* small buffer size */
	}
    return (SUCCESS);
    }

/*
 *	f_brewrite. Update a binary record.
 *
 *	Return codes:
 *		
 *		SUCCESS
 *		F_FILERR -- record cannot be written
 *
 *	NOTE: Since under standard UNIX we can not read and write from the 
 *	same stream properly (does not work), f_brewrite is same as f_write.
 *	The caller must position to the proper record in the file 
 *	before writing to it again.
 */

FUNCTION  CODE  f_brewrite
(
 struct SFILE	*f,		/* in/out: SFILE for the file	*/
 GENPTR		buffer,		/* in: record to be written	*/
 COUNT		size		/* in: size of buffer in bytes  */
 )
    {
    CODE  		code;

    code = f_bwrite(f, buffer, size);	/* write the record		 */
    return (code);
    }


FUNCTION CODE f_bwrite
(
 struct SFILE	*f,		/* in/out: SFILE for the file	*/
 GENPTR		buffer,		/* in: record to be written	*/
 COUNT		size		/* in: size of buffer in bytes  */
 )
    {
    COUNT		elem;		/* number of elements written	 */

    if (!fileopen(f))
	return (chk_error(f, ERR_FILE));	/* not an open file	 */

    errno = 0;				/* clean up previous I/O error	 */
    (*f).posctx.pos = ftell((*f).fileptr);	/* save position context */
    (*f).posctx.possav = TRUE;
    elem = fwrite((GENPTR) &size, sizeof(COUNT),
		1, (*f).fileptr);	/* write size  			*/
    if (elem > 0)
	elem = fwrite(buffer, sizeof(char), size, (*f).fileptr);  /* write data */
    if (elem == size)
	{
        (*f).posctx.line_num += 1;	/* new record number		 */
	return (SUCCESS);
	}
    err_txt (f);			/* get error msg and put in SFILE */
    return(F_FILERR);
    }

/*
 *	f_close.  Close file.
 *
 *	Return codes:
 *
 *		SUCCESS
 *		F_FILERR
 */

FUNCTION CODE f_close
(

 struct SFILE 	*f,		/* in/out: SFILE for open file	  */
 FUNINT		disp		/* in: F_KEEP or F_DELETE
					   disposition */
 )
    {
    CODE  code;

    errno = 0;				/* clean up previous I/O error	  */
    (*f).posctx.possav = FALSE;		/* posctx no longer saved 	  */
    if (!fileopen(f))			/* if file not open		  */
	return (SUCCESS);		/* do not attempt to close	  */
    code = fclose((*f).fileptr);	/* close the file		  */
    if (code == 0)
	{
	(*f).fileptr = NULL;
	(*f).sentinel = 0;		/* mark file no longer open	  */
	if (disp == F_DELETE)		/* wants to delete the file	  */
	    unlink((*f).full_spec);	/* unlink it for deletion	  */
	return (SUCCESS);
	}
    return (F_FILERR);
    }

#ifdef  XXXXXXXXXXXXX
/*	This routine is not being currently used.	*/

/*
 * 	f_chkopen. Enable/disable checking for file open at close time
 */

FUNCTION  VOID  f_chkopen
(
 struct  SFILE 	*f,		/* in: SFILE for the file	*/
 FUNINT		flag		/* in: enable check if TRUE	*/
)
    {
    (*f).chkopen = flag;		/* enable/disable check-open	*/
    return;
    }
#endif


/*	f_crack.
 *
 *	Build FSBLOCK from a host file spec.  This permits manipulation
 *	of file spec components before opening with f_opnblk.
 *
 *	We do substitutions for file spec until all symbols are replaced.
 *	(Only one level of substitution is performed to get the
 *	equivalence string.) This permits file names like SLOGOFF, LAST,
 *	etc. to be assigned to special files.
 *
 *	Return codes:
 *		SUCCESS
 *		FAIL		-- error in host file spec
 */

FUNCTION CODE f_crack
(
 TEXT		fspec[],	/* in: host file specification	*/
 TEXT		deflibr[],	/* in: default library		*/
 TEXT		defname[],	/* in: default name		*/
 TEXT		deftype[],	/* in: default type		*/
 struct FSBLOCK	*fsblock,	/* out: constructed FSBLOCK	*/
 TEXT		errstr[]	/* out: 'at or near' string     */
					/* (if code is fail)		*/
 )
    {
    TEXT		tspec[FSPECSIZ+1];  /* file spec after substitution */
    CODE		code;
    TEXT		substring[STRINGSIZ+1];		/* working buffer    */


    code = f_subst (fspec, tspec);	/* perform substitution, if any	*/
    if (code != SUCCESS)
	{
	s_copy("File name substitution.", errstr);
	return (code);			/* error return			*/
        }

    code = f_parse (tspec, (*fsblock).libr, (*fsblock).name, (*fsblock).type,
                    (*fsblock).attr, errstr);
    /* TBD: check code from f_parse */
    if (NULLSTR ((*fsblock).libr))
	{
	f_subst(deflibr, substring);
	s_bcopy(substring, (*fsblock).libr, FLIBRSIZ);
	}
    if (NULLSTR ((*fsblock).name))
	{
	f_subst(defname, substring);
	s_bcopy(substring, (*fsblock).name, FNAMESIZ);
	}
    if (NULLSTR ((*fsblock).type)  &&  !s_equal("/dev",(*fsblock).libr))
	{
	f_subst(deftype, substring);
	s_bcopy(substring, (*fsblock).type, FTYPESIZ); 
    	}
    return(code);
    }


/*	f_force_lower.   Set/Clear flag that determines whether
 *	file specs are converted to lowercase before UNIX open.
 *
 *	Returns old state of the force lower flag
 */
FUNCTION BOOL f_force_lower
(
 BOOL	flag		/* TRUE for force_lower	*/
)
	{
	BOOL	old_flag;

	old_flag = Force_lower;
	Force_lower = flag;
	return (old_flag);
	}

/*
 *	f_movpos.  Move position context.
 */

FUNCTION VOID f_movpos
(
 struct POSCTX *from,	/* in: source of position context	*/
 struct POSCTX *to		/* out: destination			*/
)
    {

    (*to).pos = (*from).pos;
    (*to).possav = (*from).possav;
    (*to).line_num = (*from).line_num;
    return;
    }

/*
 *	f_libr.  Extract library component from file spec.
 *
 *	Return codes: SUCCESS or FAIL (if error in file spec)
 */

FUNCTION CODE f_libr
(
 TEXT	fspec[],		/* in: host file specification	    */
 TEXT	library[FLIBRSIZ+1]	/* out: library field if any	    */
					/* if this address is NULL, then ok */
 )
    {
    TEXT	dummy[STRINGSIZ+1];
    TEXT	loc_libr[FLIBRSIZ+1];
    CODE	code;

    code = f_parse (fspec, loc_libr, dummy, dummy, dummy, dummy);
    if (library != NULL)
        s_copy (loc_libr, library);
    return (code);
    }

/*
 *	f_name.  Extracts the file name field from a host file spec.
 *
 *	Return codes: SUCCESS or FAIL (if syntax error)
 */

FUNCTION CODE f_name
(
 TEXT	fspec[],		/* in: host file specifiation	*/
 TEXT	name[FNAMESIZ+1]	/* out: file name field		*/
 )
    {
    TEXT	dummy[STRINGSIZ+1];
    CODE	code;

    code = f_parse (fspec, dummy, name, dummy, dummy, dummy);
    return (code);
    }


/*
 *	f_opnbio. Open a file for block I/O.
 *
 *	Return codes:
 *
 *		SUCCESS
 *		F_NOFILE -- File does not exist
 *		F_FILERR -- File exists but can not be opened.
 *
 *	NOTE: Under UNIX, there is no difference between opening a file
 *	for block I/O and record I/O. 
 *
 */
FUNCTION CODE f_opnbio
(
 struct SFILE 	*f,		/* out: file context block	*/
 FUNINT 	lun,		/* in: lun to use for file	*/
 TEXT 		fspec[],	/* in: Host file name 		*/
 FUNINT 	access,		/* in: F_READ, F_WRITE, 	*/
					/* F_EXTEND, F_OVER, F_CREATE	*/
 TEXT		filename[]	/* Out: Resultant file name	*/
 )
    {
    CODE		code;

    code = f_ophf(f, lun, fspec, access);
    if (code == SUCCESS)
	s_copy((*f).full_spec, filename);
    return (code);	
    }

/*
 *	f_opnblk.   Open file given an FSBLOCK.
 *
 *	The caller of this typically builds fsblock by stuffing fields
 *	or with f_crack (or a combination).
 *
 *	The access argument and return codes are same as for f_open.
 */

FUNCTION CODE f_opnblk
(
 struct SFILE	*sfile,		/* in/out: sfile structure	*/
 FUNINT		lun,		/* in: lun to use		*/
 struct FSBLOCK	*fsblock,	/* in: fsblock 			*/
 FUNINT		access		/* in: F_READ, F_WRITE, ...	*/
 )
    {
    TEXT	newspec[FSPECSIZ+1];
    CODE	code;

    f_spec(fsblock, newspec);
    code = f_ophf(sfile, lun, newspec, access);
    return (code);
    }

/*	f_open.   Open sequential file.
 *
 *	return codes:
 *
 *		SUCCESS
 *		F_NOFILE - Attempt to READ or EXTEND non-existent file.
 *		F_FILERR - Cannot create a F_WRITE file.  Cannot access an
 *		 	   existing (F_READ or F_EXTEND) file.
 *	
 *
 *	For F_READ and F_EXTEND access, F_NOFILE means "the file does not exist"
 *	and F_FILERR  means "the file  exists but it cannot be opened because
 *      of a  host-dependent  problem (protection, etc.)"
 *
 *	Access: F_READ (read only), F_WRITE (file create), F_EXTEND
 *	(write to end of existing file), and F_OVER (overwrite over the
 *	existing file: same as F_WRITE for UNIX system, retained for
 *	portability only.)
 */

FUNCTION CODE f_open
(
 struct SFILE 	*f,		/* out: file context block	*/
 FUNINT 	lun,		/* in: lun to use for file	*/
 TEXT 		library[],	/* in: name of library		*/
 TEXT 		name[],		/* in: name of file		*/
 TEXT 		type[],		/* in: type of file. no period.	*/
 FUNINT 	access		/* in: F_READ, F_WRITE, 	*/
					/* F_EXTEND, F_OVER		*/
 )
    {
    TEXT fspec[FSPECSIZ+1];		/* host file specification	*/
    CODE code;
    struct FSBLOCK  fsblock;

    s_bcopy(library, fsblock.libr, FLIBRSIZ);
    s_bcopy(name, fsblock.name, FNAMESIZ);
    s_bcopy(type, fsblock.type, FTYPESIZ);
    fsblock.attr[0] = EOS;			/* no attributes	*/

    f_spec(&fsblock, fspec);			/* build file spec	*/
    code = f_ophf(f, lun, fspec, access);	/* open with host file	*/
    return (code);
    }

/*
 *	f_ophf.  Open file given a host-dependent file spec.
 *	
 *
 * 	The access argument and return codes are identical to f_open.
 */

FUNCTION CODE f_ophf
(
 struct SFILE 	*f,		/* out: file context block	*/
 FUNINT 	lun,		/* in: lun to use for file	*/
 TEXT		fspec[],	/* in: host file name		*/
 FUNINT 	access		/* in: F_READ, F_WRITE,F_EXTEND	*/
				 	/* F_OVER, or'ed with F_NOLOWER   */
 )
    {
    TEXT		type[3];
    CODE		faccess;		/* file access		*/
    TEXT		newspec[FSPECSIZ+1];	/* fspec in lower case  */
    struct  FSBLOCK	fsblock;
    TEXT		errstr[STRINGSIZ+1];
    TEXT		dummy[STRINGSIZ+1];
    TEXT    		deflibr[FLIBRSIZ+1];	/* default library name */
#define  MAXPATHLEN 1024
    TEXT		pathname[MAXPATHLEN];	/* max length of path   */
    TEXT		*ptr;

    (*f).lun = lun;
    (*f).posctx.pos = 0L;
    (*f).posctx.possav = FALSE;		/* position not yet saved here	*/
    (*f).posctx.line_num = 0;
    (*f).errmsg[0] = EOS;

    faccess = (access & ~F_NOLOWER);	/* ignore bit for lower case conv  */
    if  (faccess == F_READ)  	 s_copy("r", type);	/* read	mode	   */
    else if (faccess == F_EXTEND) s_copy("a", type);	/* append mode     */
    else if (faccess == F_UPDATE)			/* block i/o update */
	s_copy("r+", type);
    else s_copy("w", type);				/* default is write */

    errno = 0;				/* clean up previous I/O error     */
    f_subst(fspec, newspec);		/* perform substitution		   */
    if (access & F_NOLOWER)		/* no conversion if explicit	   */
	;
    else if (Force_lower)		
	s_lower (newspec);		/* convert to lower case	   */
    (*f).fileptr = fopen(newspec, type);	/* open the file   	   */
    if ((*f).fileptr == NULL)			/* open error	   	   */
	return (chk_error(f, ERR_OPEN));	/* check code and return   */
    (*f).sentinel = SENTINEL;			/* write the sentinel	   */
/*
 *	get the full file specification
 */
    ptr = getcwd(pathname, MAXPATHLEN);		/* get working dir name	   */
    if (ptr == NULL)				/* if any kind of error	   */
	s_copy (".", deflibr);			/* could not get directory */
    else
	s_bcopy(ptr, deflibr, FLIBRSIZ);	/* copy with truncate	   */
    dummy[0] = EOS;
    f_crack(newspec, deflibr, dummy, dummy, &fsblock, errstr);
    f_spec(&fsblock, (*f).full_spec);
    return (SUCCESS);				/* file now open     	   */
    }

/*	f_opnspc.  Open file given filespec and defaults.
 *	
 *	The access argument and return codes are same as f_open.
 */

FUNCTION CODE f_opnspc
(
 struct SFILE	*sfile,		/* in/out: SFILE struct		*/
 FUNINT		lun,		/* in: lun to use		*/
 TEXT		fspec[],	/* in: host file spec		*/
 TEXT		deflibr[],	/* in: default library		*/
 TEXT		defname[],	/* in: default file name	*/
 TEXT		deftype[],	/* in: default file type	*/
 FUNINT		access		/* in: F_READ, F_WRITE...	*/
 )
    {
    struct FSBLOCK	fsblock;	/* file spec block		*/
    CODE		code;
    TEXT		newspec[FSPECSIZ+1];
    TEXT		errstr[STRINGSIZ+1];

    f_crack(fspec, deflibr, defname, deftype, &fsblock, errstr);
    f_spec(&fsblock, newspec);
    code = f_ophf(sfile, lun, newspec, access);
    return (code);
    }


/*	f_parse.    Parse file specification.
 *
 */

FUNCTION CODE f_parse
(
 TEXT	spec[],			/* in: file specfication	*/
 TEXT	libr[FLIBRSIZ+1],	/* out: library component	*/
 TEXT	name[FNAMESIZ+1],	/* out: name component		*/
 TEXT	type[FTYPESIZ+1],	/* out: type component		*/
 TEXT	attr[FATTRSIZ+1],	/* out: version string		*/
 TEXT	errstr[STRINGSIZ+1]	/* out: 'at or near' string if	*/
					/* syntax of spec is bad	*/
 )
    {
    TEXT	tspec[FSPECSIZ+1];	/* substituted file name	*/
    COUNT	i, len, end;
    CODE	code;

    code = f_subst (spec, tspec);	/* perform substitution, if any	*/
    if (code != SUCCESS)
	{
	s_copy("File name substitution.", errstr);
	return (code);			/* error return			*/
        }
    len = s_length(tspec);
    for (i = 0; i < len; i++)
	{
	int c = tspec[i];
#ifndef VMS
	if (!isalpha(c) && !isdigit(c)
	    && (c != '.') && (c != '/') && (c != '_')
	    && (c != '-') && (c != '+') && (c != ' '))	/* allow spaces */
#else
	if (!isalpha(c) && !isdigit(c)
	    && (c != '.') && (c != '/') && (c != '_')
	    && (c != '-') && (c != '+'))		/* disallow spaces */
#endif
	    {
	    s_bcopy(&tspec[i-3], errstr, 8);	/* give upto 8 char in errstr */
	    return (FAIL);
	    }
	}
    type[0] = name[0] = libr[0] = attr[0] = EOS;
    end = len-1;					/* index to end search   */

/* extract the type field
 */	
    for (i = end; i >= 0 && tspec[i] != '/';  i--)
        {
	if (tspec[i] == '.')				/* type specified     */
	    {
	    end = i-1;					/* new search end index   */
	    copy_alpha(&tspec[i+1], type, FTYPESIZ);
	    tspec[i] = EOS;
	    break;
	    }
	}

/* extract the file name field
 */
    for (i = end; i >= 0; i--)			/* find begin of name	*/
	{
	if (tspec[i] == '/')			/* cases /xx and /xx/   */
   	    break;
	}
    s_bcopy(&tspec[i+1], name, FNAMESIZ);       /* if no '/', i = -1	*/
    tspec[i+1] = EOS;

/* copy the rest, including the last '/' as library name
 */
    s_bcopy(tspec, libr, FLIBRSIZ);
    return (SUCCESS);
    }

/*
 *	f_rdbio. Read using block i/o.
 *
 *	Return codes:
 *
 *		SUCCESS
 *		F_EOF    - end of file
 *		F_FILERR - error
 *
 *	NOTE: Under UNIX block I/O is performed using fread and fwrite
 *	routines. The files are assumed to be a contigous stream of data
 *	with records starting at block boundaries (but with no interecord
 *	mark or count put by the TAE f_ package.)
 *
 */

FUNCTION  CODE f_rdbio
(
 struct SFILE	*f,		/* in/out: SFILE for the file	*/
 int		sector,		/* in: sector number		*/
 GENPTR		buffer,		/* out: buffer with output data */	
 int		size		/* in: size of buffer in bytes  */
 )
    {
    LONG		offset;
    LONG		count;
    int			num_bytes;

    if (!fileopen(f))
	return (chk_error(f, ERR_FILE));	/* not an open file	 */

    offset  = sector * FSECTSIZ;		/* offset into the file	 */
    count =  fseek((*f).fileptr, offset, 0);	/* position at offset    */
    if (count == -1)
	return (chk_error(f, ERR_SECTOR));	/* invalid sector number */
    num_bytes = fread(buffer, sizeof(char), size, (*f).fileptr);	
    if (num_bytes != size)
	return (chk_error(f, ERR_READ));	/* check and return error */
    return (SUCCESS);
    }

/*
 *	f_read.  Read record.
 *
 *	Return codes:
 *
 *		SUCCESS
 *		F_EOF    - end of file
 *		F_FILERR - error
 *
 *	Notes:
 *
 *	  - The "newline" character, used as the record terminator is
 *	    not returned to the user.
 *	  - If the record size is longer than STRINGSIZ, the rest of
 *	    the record is discarded.
 */

FUNCTION CODE f_read
(
 struct SFILE 	*f,		/* in/out: SFILE for an opened file  */
 TEXT           string[]	/* out: record with EOS
					   terminator   */
 )
{
    return ( f_readstring ( f, STRINGSIZ , string ) );

}
FUNCTION CODE f_readstring
(
 struct SFILE 	*f,		/* in/out: SFILE for an opened file  */
 COUNT	        maxsiz,	/* in: max string siz */
 TEXT  		string[]	/* out: record with EOS terminator   */
)    

    {
    FAST  COUNT  	i;
    FAST  TEXT		*ptr;

    if (!fileopen(f))
	return (chk_error(f, ERR_FILE));	/* not an open file	 */

    errno = 0;				/* clean up previous I/O error	     */
    (*f).posctx.pos = ftell((*f).fileptr);		/* save position ctx */
    (*f).posctx.possav = TRUE;				/* mark as saved     */
    zero_block(string, maxsiz+1);			/* null out buffer   */
    ptr = fgets(string, maxsiz+1, (*f).fileptr);	/* read next string  */
    if (ptr == NULL)					/* if error or EOF   */
	return (chk_error(f, ERR_READ));	   /* check error and return */

    for (ptr=string, i=0; i <= maxsiz; ptr++,i++)	/* scan each char    */
	if (*ptr == '\n') break;			/* full record read  */
    if (*ptr == '\n')
	*ptr = EOS;					/* change n/l to EOS */
    else						/* no n/l in buffer  */
	while ((fgetc((*f).fileptr) != '\n')  && 		
		(fgetc((*f).fileptr) != EOF))		/* go past it in file*/
    (*f).posctx.line_num += 1;				/* new record number */
    return (SUCCESS);
    }


/*
 *	f_rewind.  Rewind file.
 *
 *	Return codes:
 *
 *		SUCCESS
 *		F_FILERR - error
 */

FUNCTION CODE f_rewind
(
 FAST  struct SFILE 	*f		/* in/out: opened SFILE structure */
 )
    {
    FAST  CODE 		code;
	
    if (!fileopen(f))
	return (chk_error(f, ERR_FILE));	/* not an open file	 */

    errno = 0;				/* clean up previous I/O error	  */
    (*f).posctx.pos = 0L;
    (*f).posctx.possav = FALSE;
    code = fseek((*f).fileptr, 0L, 0);		/* rewind file		  */
    (*f).posctx.line_num = 0;
    if (code == 0)
	return (SUCCESS);
    else
	{
	err_txt (f);			/* get error msg and put in SFILE */
	return (F_FILERR);
	}
    }

/*
 *	f_setpos.  Set positioning context for next read.
 *
 *	After a read or write operation, the postion context in SFILE
 * 	can be saved (via f_movpos).  Calling f_setpos with the saved
 *	context causes the next I/O to access the desired record.
 */

FUNCTION VOID f_setpos
(
 struct SFILE 	*f,		/* in/out: opened SFILE		    */
 struct POSCTX	*posctx	/* in: postion context 		    */
 )
    {
    if (!fileopen(f))
	return;				/* closed file, cann't set pos	    */
    (*f).posctx.line_num = (*posctx).line_num - 1;    /* (f_read will bump) */
    fseek((*f).fileptr, (*posctx).pos, 0);	/* position at new offset   */
    return;
    }

/*
 *	f_spec.  Build host file specification.
 *
 *	Returns length of spec string.
 *
 *	NOTE:
 *	    If library exists but does not terminate with a '/', the latter
 *	    is added to the file spec before the file name. However, if no
 *	    library exists, we do not add the '/'. This way we differentiate
 *	    between file specs  /xx/yy, /yy and yy.
 */

FUNCTION COUNT f_spec
(
 struct FSBLOCK	*fsblock,		/* in: file spec block	*/
 TEXT		fspec[FSPECSIZ+1]	/* out: VMS file spec	*/
 )
    {
    FAST    COUNT	i;
    COUNT		liblen;			/* length of libr field */
    COUNT		typelen;		/* length of type field */

    liblen = s_bcopy((*fsblock).libr, fspec, FLIBRSIZ);
    if (liblen > 0 && (*fsblock).libr[liblen-1] != '/' ) /* if no '/' at end */
	fspec[liblen++] = '/';				/* add as terminator */
    i = liblen;
    i += s_bcopy((*fsblock).name, &fspec[i], FNAMESIZ);
    typelen = FNAMESIZ - (i-liblen) - 1;	   /* allowed length for type */
    if ((*fsblock).type[0] != EOS && typelen > 0)	/* room left for type */
	{
	fspec[i++] = '.';
	i += s_bcopy((*fsblock).type, &fspec[i], typelen);
	}	
    return (i);				/* no attribute field   */
    }

/*
 *	f_type.  Extracts the file type  field from a host file spec.
 *
 *	Return codes: SUCCESS or FAIL (if syntax error)
 */

FUNCTION CODE f_type
(
 TEXT	fspec[],		/* in: host file specifiation	*/
 TEXT	type[FTYPESIZ+1]	/* out: file type field		*/
 )
    {
    TEXT	dummy[STRINGSIZ+1];
    CODE	code;

    code = f_parse (fspec, dummy, dummy, type, dummy, dummy);
    return (code);
    }

/*
 *	f_write.   Write text record.
 *
 *	Return codes:
 *		
 *		SUCCESS
 *		F_FILERR -- record cannot be written
 */

FUNCTION CODE f_write
(
 struct SFILE	*f,		/* in/out: SFILE for the file	*/
 TEXT 		string[]	/* in: record to be written	*/
 )
    {

    if (!fileopen(f))
	return (chk_error(f, ERR_FILE));	/* not an open file	 */

    (*f).posctx.pos = ftell((*f).fileptr);	/* save position context */
    (*f).posctx.possav = TRUE;
    fputs(string, (*f).fileptr); 		/* write the text record */
    putc('\n', (*f).fileptr);			/* n/l is record separator */
    (*f).posctx.line_num += 1;			/* new record number	 */
    return (SUCCESS);
    }

/*
 *	f_wrtbio.   Write using block I/O
 *
 *	Return codes:
 *		
 *		SUCCESS
 *		F_FILERR -- record cannot be written
 *
 *
 *	NOTE: Under UNIX block I/O is performed using fread and fwrite
 *	routines. The files are assumed to be a contigous stream of data
 *	with records starting at block boundaries (but with no interecord
 *	mark or count put by the TAE f_ package.)
 *
 */

FUNCTION  CODE f_wrtbio
(
 struct SFILE	*f,		/* in/out: SFILE for the file	*/
 int		sector,		/* in: sector number		*/
 GENPTR		buffer,		/* in: buffer with data to write */	
 int		size		/* in: size of buffer in bytes  */
 )
    {
    LONG		offset;
    LONG		count;
    int			num_bytes;

    if (!fileopen(f))
	return (chk_error(f, ERR_FILE));	/* not an open file	 */

    offset  = sector * FSECTSIZ;		/* offset into the file	 */
    count =  fseek((*f).fileptr, offset, 0);	/* position at offset    */
    if (count == -1)
	return (chk_error(f, ERR_SECTOR));	/* invalid sector number */
    num_bytes = fwrite(buffer, sizeof(char), size, (*f).fileptr);	
    if (num_bytes != size)			/* error in writing      */
	{
	err_txt (f);			/* get error msg and put in SFILE */
	return(F_FILERR);
	}
    return (SUCCESS);
    }

/*
 *	fileopen. Check if the file is really open for I/O
 */

FUNCTION  static  BOOL fileopen
(
 struct  SFILE  *f
 )
    {
    if ((*f).fileptr == NULL  || (*f).sentinel != SENTINEL)
	return (FALSE);			/* file not open	*/
    else
	return (TRUE);
    }

/*
 *	f_exists. See if file exists.
 */

FUNCTION BOOL f_exists
(
 TEXT		fspec[],	/* in: host file spec		*/
 TEXT		deflibr[],	/* in: default library		*/
 TEXT		defname[],	/* in: default file name	*/
 TEXT		deftype[]	/* in: default file type	*/
 )
    {

    CODE 	code;
    struct SFILE sfile;                        /* file context block */

    code = f_opnspc (&sfile, 1, fspec, deflibr, defname, deftype, F_READ);
    f_close (&sfile, F_KEEP);
    if (code != SUCCESS && sfile.host_code == ENOENT)
     	return FALSE;
    else
    	return TRUE;
    }



#else

#include "terminc.inc"
    main()
    {
    static struct SFILE f;
    static COUNT i, j, k;
    static TEXT record[133];
    static struct POSCTX p;
    static CODE code;
    static COUNT  recsize;
    static TEXT fspec[FSPECSIZ+1], deflibr[FLIBRSIZ+1], defname[FNAMESIZ+1];
    static TEXT deftype[FTYPESIZ+1];
    static struct FSBLOCK fsblock;
    static short  outbuf[25];
    static short  inbuf[100];
    static TEXT	  errstr[STRINGSIZ+1];


    if (f_open(&f, 1, "", "test", "dat", F_WRITE) != SUCCESS) goto fail;
    if (f_write(&f, "record 1") != SUCCESS) goto fail;
    if (f_write(&f, "record 2") != SUCCESS) goto fail;
    if (f_write(&f, "last record") != SUCCESS) goto fail;
    if (f_close(&f, F_KEEP) != SUCCESS) goto fail;

    if (f_open(&f, 1, "", "test", "dat", F_READ) != SUCCESS) goto fail;
    for (i=1; i <= 3; i++)
	{
        if (f_read(&f, record) != SUCCESS) goto fail;
    	f_movpos(&(f.posctx), &p);			/* save context */
    	}
    if (f_read(&f, record) != F_EOF) goto fail;
    f_setpos(&f, &p);					/* set to last  */
    f_read(&f, record);
    printf("\n");
    printf ("line_num of last record after re-position = %d",
	    f.posctx.line_num);
    if (!s_equal(record, "last record")) goto fail;
    f_close(&f, F_KEEP);

    if (f_open(&f, 1, "", "noexist", "dat", F_READ) != F_NOFILE) goto fail;
     printf( "\n");
     printf("expected error: ");
     printf(f.errmsg);					
     printf("\n");

    f_open(&f, 1, "", "test", "dat", F_EXTEND);
    f_write(&f, "appended record");
    f_close(&f, F_KEEP);

    if (f_ophf(&f, 1, "last", F_OVER) != SUCCESS) goto fail;
    if (f_write(&f, "over-write record; others truncated.") != SUCCESS)
 	goto fail;
    f_close(&f, F_KEEP);


/* 	test for binary record read and write		*/

    if (f_open(&f, 1, "", "bintest", "dat", F_WRITE) != SUCCESS) goto fail;
    for (i=1; i<= 5; i++)
	{
	for (j=0; j < i+20; j++)
            outbuf[j] = i+j;
  	f_bwrite(&f, outbuf, (i+20)*2);
  	if (i==3) f_movpos(&(f.posctx), &p);	/* save context of 4th record*/
	}
    f_close(&f, F_KEEP);

    i = 0;
    if (f_open(&f, 1, "", "bintest", "dat", F_READ) != SUCCESS) goto fail;
    while (code = f_bread(&f, inbuf, 200, &recsize) == SUCCESS)
	{
	printf("record number: %d, size: %d \n", f.posctx.line_num, recsize);
	printf("first and last numbers: %d, %d \n", inbuf[0], inbuf[i+20]);
	i++;
	};
    printf("\n");
    printf( "truncated record \n");
    f_setpos(&f, &p);				/* set to 3rd  record */
    for (i=0; i<= 2; i++)			/* repeat three times */
	{
	if (code = f_bread(&f, inbuf, 20, &recsize) == F_FILERR) goto fail;
	printf("record number: %d, size: %d \n", f.posctx.line_num, recsize);
	printf("first and last numbers: %d, %d\n",inbuf[0],inbuf[recsize/2-1]);
	printf("error message and code: %s, %d.\n", f.errmsg, f.host_code);
	}
    f_close(&f, F_KEEP);


/* 	test file spec manipulation		*/

    t_init(&code, &code, &code);
	
loop:
    t_write("SPEC =", T_PROMPT);
    t_read(fspec, &code);
    t_write("DEFLIBR =", T_PROMPT);
    t_read(deflibr, &code);
    t_write("DEFNAME =", T_PROMPT);
    t_read(defname, &code);
    t_write("DEFTYPE =", T_PROMPT);
    t_read(deftype, &code);

    f_crack(fspec, deflibr, defname, deftype, &fsblock, errstr);
    f_spec(&fsblock, fspec);
    t_write(fspec, T_STDCC);		/* should be the same	*/
    goto loop;

    exit();

fail:
    printf("failure \n");
    exit();
    }
#endif
